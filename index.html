<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mage Tower Idle</title>
  <style>
    :root {
      --bg-deep: #0c0e14;
      --bg-panel: #12161e;
      --bg-card: #181c28;
      --bg-elevated: #1e2432;
      --border: #2a3040;
      --border-focus: #3d4558;
      --text: #e2e4ec;
      --text-muted: #7c8498;
      --accent: #7c9cf4;
      --accent-dim: rgba(124, 156, 244, 0.12);
      --accent-glow: rgba(124, 156, 244, 0.28);
      --stamina: #d4a574;
      --focus-color: #a5b8e8;
      --shadow: 0 4px 24px rgba(0, 0, 0, 0.45);
      --shadow-glow: 0 0 18px rgba(124, 156, 244, 0.12);
      --radius: 10px;
      --radius-sm: 6px;
      --font: 'Segoe UI', system-ui, -apple-system, sans-serif;
      --toast-bg: var(--bg-card);
      --toast-border: var(--accent);
    }
    * { box-sizing: border-box; }
    body {
      font-family: var(--font);
      font-size: 15px;
      line-height: 1.45;
      letter-spacing: 0.01em;
      background: var(--bg-deep);
      color: var(--text);
      margin: 0;
      display: flex;
      min-height: 100vh;
      flex-direction: column;
      -webkit-font-smoothing: antialiased;
    }
    button {
      width: 100%;
      margin: 8px 0;
      padding: 12px 16px;
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      color: var(--text);
      cursor: pointer;
      border-radius: var(--radius-sm);
      transition: background 0.2s, border-color 0.2s, transform 0.1s;
      position: relative;
      font-family: inherit;
      font-size: 0.95em;
      font-weight: 600;
    }
    button:hover:not(:disabled) {
      background: var(--border-focus);
      border-color: var(--border-focus);
    }
    button:active:not(:disabled) { transform: scale(0.99); }
    button:disabled { background: #1a1520; border-color: transparent; opacity: 0.6; cursor: not-allowed; }

    .tower-upgrade {
      background: #1c2232;
      border-color: #2a3446;
      color: #c7d1e6;
      transition: color 1.4s ease, text-shadow 1.4s ease, background 0.25s ease, border-color 0.25s ease, box-shadow 0.25s ease;
    }
    .tower-upgrade.affordable {
      background: #2f62d6;
      border-color: #6a8fff;
      color: #f7f9ff;
      text-shadow: 0 0 12px rgba(255, 255, 255, 0.35);
      box-shadow: 0 0 16px rgba(106, 143, 255, 0.35);
    }
    .tower-upgrade.affordable:hover:not(:disabled) {
      background: #3b6ff0;
      border-color: #7ea0ff;
    }
    .tower-upgrade .cost { color: rgba(199, 209, 230, 0.78); }
    .tower-upgrade.affordable .cost { color: rgba(244, 248, 255, 0.92); }

    .tooltip {
      visibility: hidden;
      opacity: 0;
      width: 280px;
      max-width: calc(100% - 8px);
      background: var(--bg-elevated);
      color: var(--text);
      text-align: left;
      border-radius: var(--radius-sm);
      padding: 10px 12px;
      position: absolute;
      z-index: 20;
      top: calc(100% + 8px);
      left: 4px;
      transition: opacity 0.2s;
      font-size: 0.88em;
      line-height: 1.4;
      pointer-events: none;
      white-space: pre-line;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    button .desc { display: block; font-size: 0.82em; opacity: 0.8; margin-top: 4px; font-weight: 500; }
    button .desc .detail { display: block; margin-top: 6px; opacity: 0.9; }
    .unlock-hint { font-size: 0.78em; opacity: 0.75; margin-top: 4px; color: var(--text-muted); }
    #tutorialLayer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 14;
    }
    .tutorial-tip {
      position: fixed;
      max-width: 280px;
      background: linear-gradient(180deg, rgba(24, 28, 40, 0.98), rgba(20, 24, 34, 0.98));
      color: var(--text);
      border: 1px solid rgba(124, 156, 244, 0.6);
      border-radius: 12px;
      padding: 12px 14px;
      font-size: 0.9em;
      line-height: 1.4;
      box-shadow: var(--shadow), 0 0 18px rgba(124, 156, 244, 0.18);
    }
    .tutorial-tip strong { color: var(--accent); }
    .tutorial-tip::before,
    .tutorial-tip::after {
      content: "";
      position: absolute;
      width: 0;
      height: 0;
      border-style: solid;
    }
    .tutorial-tip.pos-top::before {
      bottom: -10px;
      left: 24px;
      border-width: 10px 10px 0 10px;
      border-color: var(--accent) transparent transparent transparent;
    }
    .tutorial-tip.pos-top::after {
      bottom: -8px;
      left: 24px;
      border-width: 8px 8px 0 8px;
      border-color: var(--bg-card) transparent transparent transparent;
    }
    .tutorial-tip.pos-bottom::before {
      top: -10px;
      left: 24px;
      border-width: 0 10px 10px 10px;
      border-color: transparent transparent var(--accent) transparent;
    }
    .tutorial-tip.pos-bottom::after {
      top: -8px;
      left: 24px;
      border-width: 0 8px 8px 8px;
      border-color: transparent transparent var(--bg-card) transparent;
    }
    .tutorial-tip.pos-left::before {
      right: -10px;
      top: 18px;
      border-width: 10px 0 10px 10px;
      border-color: transparent transparent transparent var(--accent);
    }
    .tutorial-tip.pos-left::after {
      right: -8px;
      top: 18px;
      border-width: 8px 0 8px 8px;
      border-color: transparent transparent transparent var(--bg-card);
    }
    .tutorial-tip.pos-right::before {
      left: -10px;
      top: 18px;
      border-width: 10px 10px 10px 0;
      border-color: transparent var(--accent) transparent transparent;
    }
    .tutorial-tip.pos-right::after {
      left: -8px;
      top: 18px;
      border-width: 8px 8px 8px 0;
      border-color: transparent var(--bg-card) transparent transparent;
    }
    #loreTip {
      position: fixed;
      top: 92px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 14;
      max-width: 420px;
      display: none;
      pointer-events: auto;
    }
    #loreTip .lore-close {
      width: auto;
      margin-top: 8px;
      padding: 6px 10px;
      font-size: 0.85em;
    }
    .stat { margin: 8px 0; font-size: 0.95em; }
    .cost { font-size: 0.88em; opacity: 0.8; display: block; color: var(--text-muted); margin-top: 2px; }
    .section-divider { margin: 20px 0; height: 1px; background: var(--border); }

    .spell-status {
      margin: 10px 0 6px;
      padding: 12px 14px;
      background: var(--bg-panel);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
    }
    .spell-status .row { display: flex; justify-content: space-between; gap: 12px; align-items: baseline; }
    .spell-status .label { font-weight: 600; }
    .spell-status .sub { font-size: 0.88em; opacity: 0.85; }
    .progress {
      height: 8px;
      background: var(--bg-deep);
      border-radius: 999px;
      overflow: hidden;
      margin-top: 8px;
      border: 1px solid var(--border);
    }
    .progress > .fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), #8ba3f0);
      transition: width 0.1s linear;
    }

    #towerContainer { display: flex; flex-direction: column-reverse; align-items: center; position: relative; }
    .tower-block {
      width: 128px;
      height: 52px;
      margin-top: -6px;
      border-radius: 8px;
      position: relative;
      opacity: 1;
      transition: transform 0.15s;
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.25);
      overflow: hidden;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.2)),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.05) 0 12px, rgba(0,0,0,0.12) 12px 24px),
        repeating-linear-gradient(0deg, rgba(0,0,0,0.12) 0 6px, rgba(255,255,255,0.02) 6px 12px),
        linear-gradient(180deg, #575254 0%, #2f2d31 100%);
    }
    #towerContainer,
    .tower-block,
    .tower-block .room {
      user-select: none;
    }
    .tower-block.foundation {
      background:
        linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.25)),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.06) 0 10px, rgba(0,0,0,0.14) 10px 20px),
        repeating-linear-gradient(0deg, rgba(0,0,0,0.18) 0 6px, rgba(255,255,255,0.02) 6px 12px),
        linear-gradient(180deg, #3a3941 0%, #1d1c22 100%);
      border-color: rgba(255, 255, 255, 0.16);
    }
    .tower-block.foundation .room { opacity: 0.9; }
    /* tier tapering for a carved tower silhouette */
    .tower-block.tier-1 { width: 140px; }
    .tower-block.tier-2 { width: 132px; }
    .tower-block.tier-3 { width: 124px; }
    .tower-block.tier-4 { width: 116px; }
    .tower-block::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, rgba(0,0,0,0.16), rgba(255,255,255,0.05) 40%, rgba(0,0,0,0.22));
      opacity: 0.7;
      pointer-events: none;
    }
    .tower-windows {
      position: absolute;
      inset: 12px 12px 16px 12px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      opacity: 0.7;
      pointer-events: none;
      filter: drop-shadow(0 0 8px rgba(255, 214, 140, 0.18));
    }
    .tower-window {
      border-radius: 3px;
      border: 1px solid rgba(255,255,255,0.1);
      background: radial-gradient(circle at 40% 30%, rgba(255,210,120,0.32), rgba(0,0,0,0.35));
    }
    .tower-block.tier-1 .tower-window { opacity: 0.55; }
    .tower-block.tier-2 .tower-window { opacity: 0.65; }
    .tower-block.tier-3 .tower-window { opacity: 0.75; }
    .tower-block.tier-4 .tower-window { opacity: 0.85; }

    .tower-topper {
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      width: calc(100% - 10px);
      height: 14px;
      pointer-events: none;
    }
    .tower-crenel {
      position: absolute;
      inset: 0;
      border-radius: 6px 6px 0 0;
      background:
        repeating-linear-gradient(90deg,
          rgba(0,0,0,0.00) 0 6px,
          rgba(0,0,0,0.28) 6px 10px),
        linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.22));
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 8px 14px rgba(0,0,0,0.25);
    }
    .tower-turrets {
      position: absolute;
      inset: -2px 0 0 0;
      pointer-events: none;
    }
    .tower-turrets .turret {
      position: absolute;
      top: 0;
      width: 18px;
      height: 18px;
      border-radius: 6px 6px 4px 4px;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.20));
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 8px 14px rgba(0,0,0,0.25);
    }
    .tower-turrets .turret.left { left: -8px; }
    .tower-turrets .turret.right { right: -8px; }
    .tower-turrets .turret::after {
      content: "";
      position: absolute;
      top: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 16px;
      height: 10px;
      border-radius: 6px 6px 0 0;
      background:
        repeating-linear-gradient(90deg,
          rgba(0,0,0,0.00) 0 5px,
          rgba(0,0,0,0.30) 5px 8px),
        linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.22));
      border: 1px solid rgba(255,255,255,0.10);
    }
    .tower-turret {
      position: absolute;
      width: 120px;
      height: 44px;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.2)),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.05) 0 10px, rgba(0,0,0,0.12) 10px 20px),
        linear-gradient(180deg, #4f4a4b 0%, #2b292e 100%);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 8px 8px 6px 6px;
      box-shadow: 0 10px 18px rgba(0,0,0,0.35);
      z-index: 3;
    }
    .tower-turret::before {
      content: "";
      position: absolute;
      top: -10px;
      left: 8px;
      right: 8px;
      height: 12px;
      border-radius: 6px 6px 0 0;
      background:
        repeating-linear-gradient(90deg, rgba(0,0,0,0.0) 0 8px, rgba(0,0,0,0.35) 8px 12px),
        linear-gradient(180deg, rgba(255,255,255,0.1), rgba(0,0,0,0.2));
      border: 1px solid rgba(255,255,255,0.12);
    }
    .tower-turret::after {
      content: "";
      position: absolute;
      bottom: 6px;
      left: 12px;
      right: 12px;
      height: 10px;
      border-radius: 4px;
      background: radial-gradient(circle at 50% 50%, rgba(255,210,120,0.35), rgba(0,0,0,0.5));
      border: 1px solid rgba(255,255,255,0.08);
    }
    .tower-turret.side-left { left: -110px; }
    .tower-turret.side-right { right: -110px; }
    .tower-block.tick-pulse { animation: tickPulse 0.3s ease-out; }
    .tower-block.side-left { transform: translateX(-8px); margin-right: -8px; }
    .tower-block.side-right { transform: translateX(8px); margin-left: -8px; }
    @keyframes tickPulse { 0% { filter: brightness(1); } 50% { filter: brightness(1.2); } 100% { filter: brightness(1); } }
    .room {
      position: absolute;
      bottom: 6px;
      width: 100%;
      text-align: center;
      font-size: 0.66em;
      font-weight: 600;
      text-shadow: none;
      letter-spacing: 0.02em;
      color: rgba(226, 228, 236, 0.78);
      opacity: 0;
      transform: translateY(2px);
      transition: opacity 0.18s ease, transform 0.18s ease;
      pointer-events: none;
    }
    .tower-block:hover .room { opacity: 0.95; transform: translateY(0); }
    .boost-number { position: absolute; color: var(--accent); font-size: 0.9em; font-weight: bold; animation: floatUp 1.2s forwards; pointer-events: none; text-shadow: 0 0 12px var(--accent-glow); }
    .boost-number.crit { color: #e9d5a0; text-shadow: 0 0 10px rgba(233, 213, 160, 0.4); }
    .click-ripple {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 2px solid var(--accent-glow);
      box-shadow: 0 0 18px var(--accent-glow);
      pointer-events: none;
      animation: ripple 520ms ease-out forwards;
      transform: translate(-50%, -50%);
    }
    @keyframes ripple {
      from { opacity: 0.9; transform: translate(-50%, -50%) scale(0.7); }
      to { opacity: 0; transform: translate(-50%, -50%) scale(3.2); }
    }
    @keyframes floatUp { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-40px); opacity: 0; } }
    .tier-1 { filter: brightness(1.05); }
    .tier-2 { filter: brightness(1.02); }
    .tier-3 { filter: brightness(1.0); }
    .tier-4 { filter: brightness(0.97); }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(10, 6, 18, 0.88);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
      backdrop-filter: blur(4px);
    }
    .modal-content {
      background: var(--bg-panel);
      padding: 24px;
      border-radius: var(--radius);
      max-width: 600px;
      width: 90%;
      max-height: 85%;
      overflow-y: auto;
      border: 1px solid var(--border);
      box-shadow: var(--shadow), 0 0 0 1px rgba(255, 255, 255, 0.03);
    }
    #roomModal .modal-content { max-height: 92%; padding-bottom: 140px; display: flex; flex-wrap: wrap; gap: 14px; justify-content: center; }
    .intro-content { max-width: 520px; }
    .intro-content h3 { margin-top: 0; color: var(--accent); }
    .intro-lore, .intro-how { margin: 14px 0; font-size: 0.95em; line-height: 1.5; color: var(--text-muted); }
    .intro-how ul { margin: 8px 0 0 16px; padding-left: 8px; }
    .intro-how li { margin: 6px 0; }
    #introCloseBtn { margin-top: 12px; }
    .room-detail-content { max-width: 380px; position: relative; }
    .room-detail-header { display: flex; align-items: flex-start; justify-content: space-between; gap: 12px; margin-bottom: 12px; }
    .room-detail-header h3 { margin: 0; font-size: 1.2em; color: var(--accent); flex: 1; }
    .room-detail-close {
      flex-shrink: 0; width: 32px; height: 32px; padding: 0; margin: -4px -4px 0 0;
      background: var(--bg-elevated); border: 1px solid var(--border); color: var(--text);
      border-radius: var(--radius-sm); cursor: pointer; font-size: 1.4em; line-height: 1; display: flex; align-items: center; justify-content: center;
    }
    .room-detail-close:hover { background: var(--border-focus); border-color: var(--border-focus); }
    .room-detail-desc { margin: 0 0 12px; font-size: 0.92em; color: var(--text-muted); line-height: 1.45; }
    .room-detail-level { margin: 0 0 14px; font-size: 0.9em; }
    .room-detail-upgrade { margin-top: 4px; }

    .room-card {
      background: var(--bg-card);
      padding: 14px;
      border-radius: var(--radius-sm);
      width: 148px;
      text-align: center;
      cursor: pointer;
      position: relative;
      border: 1px solid var(--border);
      transition: border-color 0.2s, background 0.2s, transform 0.15s;
      font-weight: 600;
      font-size: 0.92em;
    }
    .room-card:hover:not(.disabled) { border-color: var(--accent); background: var(--bg-elevated); transform: translateY(-2px); }
    .room-card.disabled { opacity: 0.5; cursor: not-allowed; }
    .room-card:hover .tooltip { visibility: visible; opacity: 1; }
    .room-card .unlock-hint { display: block; margin-top: 6px; }

    .relic-card {
      background: var(--bg-card);
      padding: 14px;
      border-radius: var(--radius-sm);
      width: 200px;
      text-align: left;
      cursor: pointer;
      position: relative;
      border: 1px solid var(--border);
      transition: border-color 0.2s, background 0.2s, transform 0.15s;
    }
    .relic-card:hover:not(.disabled) { border-color: var(--accent); background: var(--bg-elevated); transform: translateY(-2px); }
    .relic-card.disabled { opacity: 0.5; cursor: not-allowed; }
    .relic-card .relic-tier {
      font-size: 0.7em;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      opacity: 0.7;
      margin-bottom: 6px;
    }
    .relic-card .relic-title { font-weight: 700; margin-bottom: 6px; }
    .relic-card .relic-desc { font-size: 0.86em; color: var(--text-muted); line-height: 1.4; }
    .relic-card.tier-uncommon { border-color: rgba(124, 156, 244, 0.55); }
    .relic-card.tier-rare { border-color: rgba(214, 188, 255, 0.7); box-shadow: 0 0 18px rgba(214, 188, 255, 0.12); }

    #relicModal .modal-content { max-height: 92%; padding-bottom: 140px; display: flex; flex-wrap: wrap; gap: 14px; justify-content: center; }
    .relic-list { display: flex; flex-direction: column; gap: 10px; }
    .relic-item {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 10px 12px;
    }
    .relic-item .relic-name { font-weight: 700; color: var(--accent); }
    .relic-item .relic-note { font-size: 0.86em; color: var(--text-muted); margin-top: 4px; }

    #toastContainer {
      position: fixed;
      bottom: 72px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 30;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }
    .toast {
      background: var(--toast-bg);
      border: 1px solid var(--toast-border);
      color: var(--text);
      padding: 14px 22px;
      border-radius: var(--radius-sm);
      font-size: 0.92em;
      animation: toastIn 0.35s ease-out;
      white-space: nowrap;
      max-width: 92vw;
      box-shadow: var(--shadow);
    }
    @keyframes toastIn { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }
    .toast-title { font-weight: 700; margin-bottom: 4px; }
    .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px 28px; margin: 14px 0; font-size: 0.92em; }
    .stats-grid span { opacity: 0.95; }
    .stats-grid .value { font-weight: 600; color: var(--accent); }

    body { flex-direction: column; min-height: 100vh; }
    #topBar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 16px;
      padding: 14px 24px;
      background: var(--bg-panel);
      border-bottom: 1px solid var(--border);
      min-height: 58px;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.25);
      position: relative;
    }
    #topLeft {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 150px;
      align-items: center;
    }
    .speed-controls {
      display: flex;
      gap: 6px;
      justify-content: center;
    }
    .speed-controls button {
      width: auto;
      padding: 6px 10px;
      font-size: 0.82em;
      border-radius: 999px;
    }
    .speed-controls button.active {
      background: var(--accent-dim);
      border-color: var(--accent);
      color: var(--accent);
      box-shadow: 0 0 10px rgba(124, 156, 244, 0.2);
    }
    #topCenter {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      gap: 16px;
      min-width: 240px;
    }
    #topActions {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      min-width: 160px;
      gap: 12px;
    }
    #topBar .resources { display: flex; align-items: center; justify-content: center; gap: 28px; font-size: 1.05em; flex-wrap: wrap; }
    #topBar .resource-block {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 6px 12px;
      background: var(--bg-card);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      position: relative;
    }
    #topBar .resource-block.has-tooltip { cursor: pointer; }
    #topBar .resource-block .main { font-weight: 700; font-size: 1.02em; }
    #topBar .resource-block .main.mana { color: var(--accent); }
    #topBar .resource-block .main.stamina { color: var(--stamina); }
    #topBar .resource-block .main.focus { color: var(--focus-color); }
    .exhausted-hint {
      font-size: 0.85em;
      color: var(--text);
      background: rgba(212, 165, 116, 0.18);
      border: 1px solid rgba(212, 165, 116, 0.45);
      border-radius: 999px;
      padding: 6px 10px;
      white-space: nowrap;
      position: absolute;
      left: 75%;
      top: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 12px rgba(212, 165, 116, 0.18);
    }
    #topBar .resource-block .sub { font-size: 0.88em; opacity: 0.88; color: var(--text-muted); }
    #topBar .spell-status-inline { display: flex; align-items: center; gap: 10px; font-size: 0.9em; opacity: 0.95; }
    .mini-progress {
      height: 6px;
      background: rgba(0, 0, 0, 0.35);
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.08);
      margin-top: 4px;
    }
    .mini-progress > .mini-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), #8ba3f0);
      transition: width 0.12s linear;
    }
    .mini-progress.stamina > .mini-fill { background: linear-gradient(90deg, var(--stamina), #e9c89a); }
    .mini-progress.focus > .mini-fill { background: linear-gradient(90deg, var(--focus-color), var(--accent)); }
    #main {
      flex: 1;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      background: linear-gradient(180deg, #2a3447 0%, #3b4a5f 38%, #312a22 100%);
      position: relative;
      overflow: hidden;
      min-height: 0;
    }
    /* medieval landscape */
    #main::before, #main::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    #main::before {
      background:
        radial-gradient(circle at 20% 70%, rgba(45, 52, 61, 0.85) 0 120px, transparent 140px),
        radial-gradient(circle at 80% 75%, rgba(38, 44, 52, 0.9) 0 160px, transparent 190px),
        radial-gradient(circle at 55% 60%, rgba(55, 64, 74, 0.85) 0 200px, transparent 230px),
        linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.0) 40%);
      opacity: 0.9;
    }
    #main::after {
      background:
        linear-gradient(180deg, transparent 0 65%, rgba(24, 20, 16, 0.8) 70%, rgba(18, 14, 10, 0.95) 100%),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.03) 0 40px, rgba(0,0,0,0.05) 40px 80px);
      opacity: 0.9;
    }
    #main #towerContainer { margin-bottom: 160px; }
    #towerControls {
      position: absolute;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 16px;
      z-index: 5;
      flex-wrap: wrap;
      justify-content: center;
    }
    .tower-control-card {
      background: rgba(18, 22, 30, 0.9);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 10px 12px;
      min-width: 220px;
      box-shadow: var(--shadow);
    }
    .tower-control-title {
      font-weight: 700;
      color: var(--accent);
      font-size: 0.9em;
      margin-bottom: 6px;
    }
    #bottomNav {
      display: flex;
      justify-content: center;
      gap: 6px;
      background: var(--bg-panel);
      border-top: 1px solid var(--border);
      padding: 8px 12px 10px;
      box-shadow: 0 -4px 24px rgba(0, 0, 0, 0.45);
    }
    #bottomNav .tab {
      flex: 1;
      max-width: 200px;
      padding: 14px 18px;
      border: none;
      border-radius: 12px;
      background: transparent;
      color: var(--text-muted);
      font-size: 0.95em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      border-bottom: 3px solid transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      font-family: inherit;
    }
    #bottomNav .tab .tab-icon { width: 26px; height: 26px; flex-shrink: 0; opacity: 0.9; }
    #bottomNav .tab .tab-badge {
      display: none;
      width: 12px;
      height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(255, 214, 140, 0.9);
      background: radial-gradient(circle at 30% 30%, #fff4da, #f5b94c);
      box-shadow: 0 0 8px rgba(245, 185, 76, 0.6);
      position: absolute;
      top: 6px;
      right: 10px;
    }
    #bottomNav .tab.has-badge .tab-badge { display: inline-flex; }
    #bottomNav .tab:hover { color: var(--text); background: var(--accent-dim); }
    #bottomNav .tab:hover .tab-icon { opacity: 1; }
    #bottomNav .tab.active { color: var(--accent); background: var(--accent-dim); border-bottom-color: var(--accent); }
    #bottomNav .tab.active .tab-icon { opacity: 1; filter: drop-shadow(0 0 8px var(--accent-glow)); }
    #bottomNav .tab { position: relative; }
    #bottomNav .tab.tab-locked { opacity: 0.5; cursor: not-allowed; pointer-events: auto; }
    #bottomNav .tab.tab-locked:hover { color: var(--text-muted); background: transparent; }
    #bottomNav .tab.tab-locked:hover .tab-icon { opacity: 0.9; filter: none; }
    .panel-modal {
      position: fixed;
      inset: 0;
      background: transparent;
      display: none;
      align-items: center;
      justify-content: flex-end;
      z-index: 15;
      pointer-events: none;
      padding: 6vh 0;
    }
    .panel-modal.show { display: flex; }
    .panel-modal .panel-content {
      background: var(--bg-panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 22px 20px;
      width: min(70vw, 760px);
      height: 70vh;
      max-height: none;
      overflow-y: auto;
      box-shadow: -10px 0 28px rgba(0, 0, 0, 0.45);
      transform: translateX(100%);
      transition: transform 0.2s ease, opacity 0.2s ease;
      opacity: 0.98;
      pointer-events: auto;
    }
    .panel-modal.show .panel-content { transform: translateX(0); opacity: 1; }
    .panel-modal .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 22px;
      padding-bottom: 14px;
      border-bottom: 1px solid var(--border);
    }
    .panel-modal .panel-header h2 { margin: 0; font-size: 1.4em; font-weight: 700; color: var(--accent); letter-spacing: 0.02em; }
    .panel-modal .panel-close {
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      color: var(--text);
      width: 38px;
      height: 38px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-size: 1.3em;
      line-height: 1;
      transition: background 0.2s, border-color 0.2s;
    }
    .panel-modal .panel-close:hover { background: var(--border-focus); border-color: var(--border-focus); }
    .panel-modal .section-title { font-size: 0.9em; color: var(--text-muted); margin: 18px 0 10px; font-weight: 600; }
    .grimoire-slots-stat { font-weight: 600; margin-bottom: 6px; font-size: 0.95em; }
    .grimoire-swap-timer { font-size: 0.88em; color: var(--text-muted); margin-bottom: 14px; }
    .spell-row { display: flex; gap: 10px; align-items: stretch; margin-bottom: 8px; }
    .spell-row > button:first-child { flex: 1; }
    .spell-row .spell-slot-btn { flex: 0 0 auto; width: auto; min-width: 80px; }
    .panel-modal .section-title:first-of-type { margin-top: 0; }
    .floors-stat .value { color: var(--accent); font-weight: 700; }
    .panel-modal .stat { padding: 6px 0; }

    #settingsBtn {
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      width: 42px;
      height: 42px;
      border-radius: var(--radius-sm);
      font-size: 1.2em;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      position: fixed;
      left: 14px;
      bottom: 72px;
      z-index: 20;
    }
    #settingsBtn:hover { background: var(--border-focus); border-color: var(--border-focus); }

    .settings-content { max-width: 420px; }
    .settings-header {
      display: flex; align-items: center; justify-content: space-between; gap: 12px;
      margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--border);
    }
    .settings-header h2 { margin: 0; font-size: 1.35em; font-weight: 700; color: var(--accent); letter-spacing: 0.02em; }
    .settings-close {
      width: 36px; height: 36px; padding: 0; margin: 0;
      background: var(--bg-elevated); border: 1px solid var(--border); color: var(--text);
      border-radius: var(--radius-sm); cursor: pointer; font-size: 1.35em; line-height: 1;
      display: flex; align-items: center; justify-content: center;
      transition: background 0.2s, border-color 0.2s;
    }
    .settings-close:hover { background: var(--border-focus); border-color: var(--border-focus); }
    .settings-section { margin-bottom: 16px; }
    .settings-section:last-child { margin-bottom: 0; }
    .settings-section-title {
      font-size: 0.8em; font-weight: 600; text-transform: uppercase; letter-spacing: 0.06em;
      color: var(--text-muted); margin: 0 0 10px 0;
    }
    .settings-row { margin: 0; }
    .settings-toggle { margin-top: 4px; }
    .settings-label {
      display: flex; align-items: center; gap: 12px; cursor: pointer;
      padding: 12px 14px; background: var(--bg-card); border: 1px solid var(--border);
      border-radius: var(--radius-sm); transition: border-color 0.2s, background 0.2s;
    }
    .settings-label:hover { border-color: var(--border-focus); background: var(--bg-elevated); }
    .settings-checkbox {
      width: 20px; height: 20px; margin: 0; accent-color: var(--accent);
      cursor: pointer; flex-shrink: 0;
    }
    .settings-toggle-text { font-weight: 500; font-size: 0.95em; }
    .settings-content .settings-btn {
      width: 100%; margin: 6px 0 0 0; padding: 12px 16px;
      font-size: 0.95em; text-align: left;
    }
    .settings-content .settings-btn:first-of-type { margin-top: 0; }
    .settings-section .settings-btn + .settings-btn { margin-top: 8px; }
    .settings-tabs {
      display: flex;
      gap: 8px;
      margin: -8px 0 14px;
    }
    .settings-tab {
      width: auto;
      margin: 0;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-muted);
      font-weight: 700;
      letter-spacing: 0.02em;
    }
    .settings-tab:hover { background: var(--bg-elevated); color: var(--text); }
    .settings-tab.active {
      color: var(--text);
      border-color: rgba(124, 156, 244, 0.35);
      box-shadow: 0 0 0 3px rgba(124, 156, 244, 0.10);
    }
    .settings-page { display: block; }
    .settings-page.hidden { display: none; }
    .keybinds-list {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 12px;
    }
    .kb-row {
      display: grid;
      grid-template-columns: 56px 1fr auto;
      gap: 12px;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .kb-row:last-child { border-bottom: none; }
    .kb-key {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: 28px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.10);
      background: var(--bg-elevated);
      color: var(--text);
      font-weight: 800;
      font-size: 0.9em;
      letter-spacing: 0.02em;
    }
    .kb-rebind {
      width: auto;
      margin: 0;
      padding: 6px 10px;
      font-size: 0.8em;
      border-radius: 999px;
    }
    .kb-desc { color: var(--text-muted); font-size: 0.95em; }
    .settings-section-danger .settings-section-title { color: #b08080; }
    .settings-btn-danger {
      border-color: rgba(180, 100, 100, 0.4); color: #e0b0b0;
    }
    .settings-btn-danger:hover:not(:disabled) {
      background: rgba(140, 70, 70, 0.2); border-color: #a05050;
    }
    .glossary-list { display: grid; gap: 10px; }
    .glossary-item {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 10px 12px;
    }
    .glossary-item .term { font-weight: 700; color: var(--accent); }
    .glossary-item .desc { color: var(--text-muted); font-size: 0.9em; margin-top: 4px; }
    .game-title {
      margin: 0;
      font-size: 1.15em;
      font-weight: 700;
      color: var(--text-muted);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    @media (max-width: 900px) {
      #towerControls { bottom: 90px; }
    }
    @media (max-width: 520px) {
      .game-title { font-size: 1em; }
      #topBar { padding: 10px 14px; gap: 10px; }
      #topBar .resource-block { padding: 4px 8px; font-size: 0.95em; }
      #topCenter { min-width: 0; flex-wrap: wrap; }
      .exhausted-hint { position: static; transform: none; margin-left: 0; }
      .panel-modal .panel-content { padding: 20px; width: 92vw; height: 82vh; }
    }

    /* ===== POLISH: Resource full glow effect ===== */
    .resource-block.resource-full {
      animation: resourceFullPulse 2s ease-in-out infinite;
      border-color: var(--accent);
    }
    .resource-block.resource-full.mana-block { border-color: var(--accent); }
    .resource-block.resource-full.stamina-block { border-color: var(--stamina); }
    .resource-block.resource-full.focus-block { border-color: var(--focus-color); }
    @keyframes resourceFullPulse {
      0%, 100% { box-shadow: 0 0 8px rgba(124, 156, 244, 0.15); }
      50% { box-shadow: 0 0 16px rgba(124, 156, 244, 0.35); }
    }
    .resource-block.resource-full.stamina-block {
      animation-name: staminaFullPulse;
    }
    @keyframes staminaFullPulse {
      0%, 100% { box-shadow: 0 0 8px rgba(212, 165, 116, 0.15); }
      50% { box-shadow: 0 0 16px rgba(212, 165, 116, 0.35); }
    }
    .resource-block.resource-full.focus-block {
      animation-name: focusFullPulse;
    }
    @keyframes focusFullPulse {
      0%, 100% { box-shadow: 0 0 8px rgba(165, 184, 232, 0.15); }
      50% { box-shadow: 0 0 16px rgba(165, 184, 232, 0.35); }
    }

    /* ===== POLISH: Better button feedback ===== */
    button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    button:not(:disabled):active {
      transform: translateY(0) scale(0.98);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    /* ===== POLISH: Cooldown overlay on buttons ===== */
    button .cooldown-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), var(--focus-color));
      border-radius: 0 0 var(--radius-sm) var(--radius-sm);
      transition: width 0.1s linear;
      pointer-events: none;
    }

    /* ===== POLISH: Upgrade preview tooltip ===== */
    .upgrade-preview {
      font-size: 0.82em;
      color: #8fcf8f;
      margin-top: 4px;
      opacity: 0;
      transition: opacity 0.2s;
    }
    button:hover .upgrade-preview {
      opacity: 1;
    }

    /* ===== POLISH: Offline progress modal ===== */
    .offline-modal {
      text-align: center;
    }
    .offline-modal h3 {
      color: var(--accent);
      margin-bottom: 16px;
    }
    .offline-gains {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 16px;
      margin: 16px 0;
    }
    .offline-gains .gain-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid var(--border);
    }
    .offline-gains .gain-row:last-child {
      border-bottom: none;
    }
    .offline-gains .gain-value {
      color: var(--accent);
      font-weight: 700;
    }
    .offline-gains .gain-value.stamina {
      color: var(--stamina);
    }
    .offline-gains .gain-value.focus {
      color: var(--focus-color);
    }
    /* ===== Expanded systems UI ===== */
    #topBar .secondary-resources {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 6px;
    }
    #topBar .resource-block.compact {
      padding: 4px 10px;
      font-size: 0.9em;
    }
    .resource-block .meta {
      font-size: 0.78em;
      color: var(--text-muted);
      letter-spacing: 0.02em;
    }
    .resource-block.has-tooltip .resource-tooltip {
      position: absolute;
      top: calc(100% + 6px);
      right: 0;
      min-width: 210px;
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 8px 10px;
      font-size: 0.82em;
      color: var(--text);
      box-shadow: var(--shadow);
      display: none;
      z-index: 20;
      white-space: pre-line;
    }
    .resource-block.has-tooltip:hover .resource-tooltip,
    .resource-block.has-tooltip.show-tooltip .resource-tooltip {
      display: block;
    }
    .panel-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      margin-top: 10px;
    }
    .panel-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 12px;
    }
    .panel-card .title {
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 6px;
    }
    .panel-card .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .panel-card .muted { color: var(--text-muted); font-size: 0.88em; }
    .panel-card .small { font-size: 0.85em; }
    .progress-line {
      height: 6px;
      background: var(--bg-deep);
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid var(--border);
      margin-top: 6px;
    }
    .progress-line .fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), #8ba3f0);
      transition: width 0.2s ease;
    }
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      padding: 2px 8px;
      border: 1px solid var(--border);
      background: var(--bg-elevated);
      font-size: 0.75em;
      color: var(--text-muted);
    }
    .tag.good {
      color: #9adbbd;
      border-color: rgba(154, 219, 189, 0.5);
      background: rgba(154, 219, 189, 0.12);
    }
    .tag.warn {
      color: #e0b07d;
      border-color: rgba(224, 176, 125, 0.5);
      background: rgba(224, 176, 125, 0.12);
    }
    .mini-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 8px;
    }
    .choice-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
    }
    .module-slot {
      border: 1px dashed var(--border);
      border-radius: var(--radius-sm);
      padding: 6px;
      font-size: 0.82em;
      color: var(--text-muted);
      text-align: center;
    }
    .module-slot.filled {
      border-style: solid;
      color: var(--text);
    }
    .glyph-active {
      border-color: rgba(124, 156, 244, 0.7);
      box-shadow: 0 0 12px rgba(124, 156, 244, 0.25);
    }
    .contract-item,
    .story-entry {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 10px 12px;
    }
    .story-entry.locked { opacity: 0.5; }
    .rune-grid {
      display: grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap: 6px;
      margin-top: 8px;
    }
    .rune-btn {
      padding: 8px 6px;
      font-size: 0.85em;
      border-radius: 8px;
    }
    .cosmetic-sheen {
      box-shadow: 0 0 16px rgba(124, 156, 244, 0.18), 0 0 26px rgba(124, 156, 244, 0.12);
    }
  </style>
</head>
<body>
  <header id="topBar">
    <div id="topLeft">
      <h1 class="game-title" aria-hidden="true">Mage Tower</h1>
      <div class="speed-controls">
        <button id="pauseBtn" type="button" aria-label="Pause">Pause</button>
        <button id="playBtn" type="button" aria-label="Play">Play</button>
        <button id="speedBtn" type="button" aria-label="Speed x2">2x</button>
      </div>
    </div>
    <div id="topCenter">
      <div class="resources">
        <div id="manaBlock" class="resource-block mana-block">
          <span class="main mana">Mana: <span id="mana">0</span> / <span id="manaMax">1000</span></span>
          <span class="sub">Mana/sec: <span id="manaPerSec">0</span></span>
          <div class="mini-progress" aria-hidden="true"><div id="manaFill" class="mini-fill"></div></div>
        </div>
        <div id="staminaBlock" class="resource-block stamina-block">
          <span class="main stamina">Stamina: <span id="stamina">0</span> / <span id="staminaMax">100</span></span>
          <span class="sub">Stamina/sec: <span id="staminaPerSec">0.20</span></span>
          <div class="mini-progress stamina" aria-hidden="true"><div id="staminaFill" class="mini-fill"></div></div>
        </div>
        <div id="focusBlock" class="resource-block focus-block">
          <span class="main focus">Focus: <span id="focus">0</span> / <span id="focusMax">100</span></span>
          <span class="sub">Focus/sec: <span id="focusPerSec">0</span> <span id="focusIdleHint">(after 60s idle)</span></span>
          <div class="mini-progress focus" aria-hidden="true"><div id="focusFill" class="mini-fill"></div></div>
        </div>
      </div>
      <div id="secondaryResources" class="secondary-resources">
        <div id="followersBlock" class="resource-block compact">
          <span class="main">Followers: <span id="followersTotal">0</span></span>
          <span class="meta">Reputation: <span id="reputation">0</span>%</span>
        </div>
        <div id="goldBlock" class="resource-block compact">
          <span class="main">Gold: <span id="gold">0</span></span>
          <span class="meta">Upkeep: <span id="goldUpkeep">0</span>/min</span>
        </div>
        <div id="essenceBlock" class="resource-block compact has-tooltip">
          <span class="main">Essence: <span id="essenceTotal">0</span></span>
          <span class="meta" style="display:none;">Breakdown</span>
          <div id="essenceTooltip" class="resource-tooltip"></div>
        </div>
      </div>
      <div id="exhaustedHint" class="exhausted-hint" style="display:none"></div>
    </div>
    <div id="topActions">
      <div id="timeDilationStatus" class="spell-status-inline" style="display:none">
        <span class="label">Time Dilation</span>
        <span id="timeDilationTime" class="sub">0.0s left</span>
        <span id="timeDilationBoost" class="sub">Boost: x1.00</span>
        <div class="progress" style="width:80px;margin:0;"><div id="timeDilationFill" class="fill"></div></div>
      </div>
    </div>
  </header>

  <main id="main">
    <div id="towerContainer"></div>
    <div id="towerControls">
      <div class="tower-control-card">
        <div class="tower-control-title">Mana Font</div>
        <button id="manaFontBtn" class="tower-upgrade">Mana Font<span class="cost" id="manaFontCost"></span><span class="upgrade-preview" id="manaFontPreview"></span></button>
      </div>
      <div class="tower-control-card">
        <div class="tower-control-title">Raise Floor</div>
        <button id="towerBtn" class="tower-upgrade">Raise Tower Floor<span class="cost" id="towerCost"></span><span class="upgrade-preview" id="towerPreview"></span></button>
      </div>
    </div>
  </main>

  <nav id="bottomNav">
    <button class="tab" data-panel="activitiesModal">
      <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v18M16 3v18M8 3h8a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/><path d="M10 8h4M10 12h4M10 16h2"/></svg>
      <span>Activities</span>
      <span class="tab-badge" aria-hidden="true"></span>
    </button>
    <button class="tab" data-panel="grimoireModal">
      <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/><path d="M8 7h8M8 11h8M8 15h4"/></svg>
      <span>Grimoire</span>
      <span class="tab-badge" aria-hidden="true"></span>
    </button>
    <button class="tab" data-panel="towerModal">
      <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="18" width="16" height="4" rx="1"/><rect x="9" y="12" width="6" height="6"/><rect x="7" y="6" width="10" height="6"/><rect x="10" y="2" width="4" height="4"/></svg>
      <span>Tower</span>
      <span class="tab-badge" aria-hidden="true"></span>
    </button>
    <button id="academyTab" class="tab tab-locked" data-panel="academyModal" title="Unlocks with followers">
      <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l8 4-8 4-8-4 8-4z"/><path d="M4 10v6a8 8 0 0 0 16 0v-6"/><path d="M8 14h8"/></svg>
      <span>Academy</span>
      <span class="tab-badge" aria-hidden="true"></span>
    </button>
    <button id="libraryTab" class="tab tab-locked" data-panel="libraryModal" title="Unlocks with followers">
      <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 4h6a3 3 0 0 1 3 3v14H6a3 3 0 0 1-3-3V4z"/><path d="M21 4h-6a3 3 0 0 0-3 3v14h6a3 3 0 0 0 3-3V4z"/></svg>
      <span>Library</span>
      <span class="tab-badge" aria-hidden="true"></span>
    </button>
    <button id="observatoryTab" class="tab tab-locked" data-panel="observatoryModal" title="Unlocks with followers">
      <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M4.5 19.5l4.5-4.5"/><path d="M19.5 19.5l-4.5-4.5"/><path d="M12 2v4"/><path d="M2 12h4"/><path d="M18 12h4"/></svg>
      <span>Observatory</span>
      <span class="tab-badge" aria-hidden="true"></span>
    </button>
    <button class="tab" data-panel="relicsModal">
      <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7-9 13-9-13z"/><path d="M3 9h18"/></svg>
      <span>Relics</span>
      <span class="tab-badge" aria-hidden="true"></span>
    </button>
    <button id="ascensionTab" class="tab tab-locked" data-panel="ascensionModal" title="Unlocks at 50 floors">
      <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l3 7 7 3-7 3-3 7-3-7-7-3 7-3 3-7z"/><path d="M12 8v8"/><path d="M8 12h8"/></svg>
      <span>Ascension</span>
      <span class="tab-badge" aria-hidden="true"></span>
    </button>
  </nav>

  <button id="settingsBtn" aria-label="Settings" type="button">&#9881;</button>

  <div id="activitiesModal" class="panel-modal">
    <div class="panel-content">
      <div class="panel-header">
        <h2>Activities</h2>
        <button class="panel-close" aria-label="Close" onclick="closePanel('activitiesModal')">&times;</button>
      </div>
      <p class="section-title">Activities are grouped by focus area. Each group shows how to unlock new actions, while long-term upgrades live in the Library.</p>
      <div id="activities"></div>
    </div>
  </div>

  <div id="grimoireModal" class="panel-modal">
    <div class="panel-content">
      <div class="panel-header">
        <h2>Grimoire</h2>
        <button class="panel-close" aria-label="Close" onclick="closePanel('grimoireModal')">&times;</button>
      </div>
      <div id="grimoireSpellSlots" class="grimoire-slots-stat"></div>
      <div id="grimoireSwapTimer" class="grimoire-swap-timer"></div>
      <p class="section-title">Active Spells</p>
      <div id="activeSpells"></div>
      <p class="section-title">Passive Spells</p>
      <div id="passiveSpells"></div>
    </div>
  </div>

  <div id="towerModal" class="panel-modal">
    <div class="panel-content">
      <div class="panel-header">
        <h2>Tower</h2>
        <button class="panel-close" aria-label="Close" onclick="closePanel('towerModal')">&times;</button>
      </div>
      <div id="towerWardsPanel" class="stat">
        <div><strong>Wards:</strong> <span id="towerWards">0</span> / <span id="towerWardsMax">0</span></div>
        <div class="cost">Regen: <span id="towerWardsPerSec">0</span>/s  Wards absorb encounter damage and overcharge drain.</div>
      </div>
      <div id="towerBlessingPanel" class="stat"></div>
      <div class="stat floors-stat">Floors: <span id="floors" class="value">0</span></div>
      <div id="roomSummary" class="stat"></div>
      <div id="towerUpgradeButtons"></div>
      <div class="section-divider"></div>
      <p class="section-title">Tower Upgrades</p>
      <div class="section-divider"></div>
    </div>
  </div>

  <div id="academyModal" class="panel-modal">
    <div class="panel-content">
      <div class="panel-header">
        <h2>Mage Academy</h2>
        <button class="panel-close" aria-label="Close" onclick="closePanel('academyModal')">&times;</button>
      </div>
      <p class="section-title">Outposts & Leyline Links</p>
      <div id="academySummary" class="stat"></div>
      <div id="outpostList" class="panel-grid"></div>
      <div class="section-divider"></div>
      <p class="section-title">Academy Staff</p>
      <div id="staffList" class="panel-grid"></div>
      <div class="section-divider"></div>
      <p class="section-title">Market & Assignments</p>
      <div id="marketPanel"></div>
      <div class="section-divider"></div>
      <p class="section-title">Tower Modules</p>
      <div id="moduleInventory" class="panel-grid"></div>
    </div>
  </div>

  <div id="libraryModal" class="panel-modal">
    <div class="panel-content">
      <div class="panel-header">
        <h2>Library</h2>
        <button class="panel-close" aria-label="Close" onclick="closePanel('libraryModal')">&times;</button>
      </div>
      <div id="librarySummary" class="stat"></div>
      <p class="section-title">Research Tree</p>
      <div id="researchTree" class="panel-grid"></div>
      <div class="section-divider"></div>
      <p class="section-title">Schools of Magic</p>
      <div id="schoolChoices" class="panel-grid"></div>
      <div class="section-divider"></div>
      <p class="section-title">Risk-Reward Glyphs</p>
      <div id="glyphChoices" class="panel-grid"></div>
      <div class="section-divider"></div>
      <p class="section-title">Rune Etching</p>
      <div id="runeEtchingPanel"></div>
      <div class="section-divider"></div>
      <p class="section-title">Alchemical Crafting</p>
      <div id="craftingPanel"></div>
      <div class="section-divider"></div>
      <p class="section-title">Story & Milestones</p>
      <div id="storyPanel" class="mini-list"></div>
    </div>
  </div>

  <div id="observatoryModal" class="panel-modal">
    <div class="panel-content">
      <div class="panel-header">
        <h2>Observatory</h2>
        <button class="panel-close" aria-label="Close" onclick="closePanel('observatoryModal')">&times;</button>
      </div>
      <div id="encounterSummary" class="stat"></div>
      <p class="section-title">Encounters</p>
      <div id="encounterPanel"></div>
      <div class="section-divider"></div>
      <p class="section-title">Contracts</p>
      <div id="contractsPanel" class="mini-list"></div>
      <div class="section-divider"></div>
      <p class="section-title">Ascension Challenges</p>
      <div id="challengePanel"></div>
      <div class="section-divider"></div>
      <p class="section-title">Cosmetic Progression</p>
      <div id="cosmeticPanel"></div>
    </div>
  </div>

  <div id="relicsModal" class="panel-modal">
    <div class="panel-content">
      <div class="panel-header">
        <h2>Relics</h2>
        <button class="panel-close" aria-label="Close" onclick="closePanel('relicsModal')">&times;</button>
      </div>
      <p class="section-title">Run relics (reset on ascension)</p>
      <div id="relicSummary" class="stat"></div>
      <div id="relicDraftSection" class="section-divider" style="margin-top:16px; display:none;">
        <p class="section-title">Relic draft available</p>
        <button id="relicDraftBtn">Choose a relic</button>
      </div>
    </div>
  </div>

  <div id="ascensionModal" class="panel-modal">
    <div class="panel-content">
      <div class="panel-header">
        <h2>Ascension</h2>
        <button class="panel-close" aria-label="Close" onclick="closePanel('ascensionModal')">&times;</button>
      </div>
      <p class="section-title">Restart your tower for permanent bonuses</p>
      <p class="cost" id="ascensionDesc"></p>
      <button id="ascendBtn">Ascend</button>
      <div id="paragonSection" class="section-divider" style="margin-top:16px; display:none;">
        <p class="section-title">Paragon (post-ascension)</p>
        <p class="cost" id="paragonXpEl">Paragon XP: 0</p>
        <div id="paragonNodes"></div>
      </div>
    </div>
  </div>

  <div id="roomModal" class="modal">
    <div class="modal-content" id="roomChoices"></div>
  </div>

  <div id="relicModal" class="modal">
    <div class="modal-content" id="relicChoices"></div>
  </div>

  <div id="followerEventModal" class="modal">
    <div class="modal-content" id="followerEventContent"></div>
  </div>

  <div id="settingsModal" class="modal">
    <div class="modal-content settings-content">
      <div class="settings-header">
        <h2>Settings</h2>
        <button type="button" class="settings-close" aria-label="Close" onclick="closeSettings()">&times;</button>
      </div>
      <div class="settings-tabs" role="tablist" aria-label="Settings tabs">
        <button type="button" id="settingsTabPrefs" class="settings-tab active" role="tab" aria-selected="true">General</button>
        <button type="button" id="settingsTabGlossary" class="settings-tab" role="tab" aria-selected="false">Glossary</button>
        <button type="button" id="settingsTabKeys" class="settings-tab" role="tab" aria-selected="false">Keybinds</button>
      </div>

      <div id="settingsPagePrefs" class="settings-page">
        <div class="settings-section">
          <p class="settings-section-title">Preferences</p>
          <div class="settings-row settings-toggle">
            <label for="soundCheckbox" class="settings-label">
              <input type="checkbox" id="soundCheckbox" class="settings-checkbox">
              <span class="settings-toggle-text">Sound effects</span>
            </label>
          </div>
          <div class="settings-row settings-toggle" style="margin-top:10px;">
            <label for="tutorialCheckbox" class="settings-label">
              <input type="checkbox" id="tutorialCheckbox" class="settings-checkbox">
              <span class="settings-toggle-text">Show Quick start helper</span>
            </label>
          </div>
          <button type="button" id="tutorialResetBtn" class="settings-btn" style="margin-top:10px;">Restart quick tutorial</button>
        </div>

        <div class="settings-section">
          <p class="settings-section-title">Progress</p>
          <button type="button" id="statsBtn" class="settings-btn">View statistics & achievements</button>
        </div>

        <div class="settings-section">
          <p class="settings-section-title">Save data</p>
          <button type="button" id="exportBtn" class="settings-btn">Export save to clipboard</button>
          <button type="button" id="importBtn" class="settings-btn">Import save from clipboard</button>
        </div>

        <div class="settings-section settings-section-danger">
          <p class="settings-section-title">Reset</p>
          <button type="button" onclick="resetGame()" class="settings-btn settings-btn-danger">Reset save (clear all progress)</button>
        </div>
      </div>

      <div id="settingsPageGlossary" class="settings-page hidden">
        <div class="settings-section">
          <p class="settings-section-title">Glossary</p>
          <div class="glossary-list">
            <div class="glossary-item">
              <div class="term">Mana</div>
              <div class="desc">Your main resource. Generated over time and by clicking the tower. Spend it on spells, rooms, and upgrades.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Stamina</div>
              <div class="desc">Recovers over time. Spend it in Activities to gain permanent or run-long bonuses.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Focus</div>
              <div class="desc">Regenerates after resting (idle). Used to cast powerful spells and perform focused activities.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Followers</div>
              <div class="desc">Your growing base of supporters. They generate mana/sec, unlock tabs, and can be assigned to tasks.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Reputation</div>
              <div class="desc">Measures trust in your academy. Higher reputation attracts followers faster.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Wards</div>
              <div class="desc">Your towers protective integrity. Overcharge and encounters can drain wards.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Essence</div>
              <div class="desc">Elemental materials from encounters and rituals. Types: Wind, Earth, Fire, Water, Arcane, Astral.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Research</div>
              <div class="desc">Long-term upgrades unlocked via research points gained from outposts and followers.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Mana Fonts</div>
              <div class="desc">Click amplifiers that add mana per tap. Boosted by sigils and certain rooms.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Floors & Rooms</div>
              <div class="desc">Each new floor adds a room. Rooms provide bonuses to mana, stamina, or spell effects.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Activities</div>
              <div class="desc">Actions that consume stamina and focus to provide upgrades, buffs, or resources.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Spells</div>
              <div class="desc">Active spells give short bursts; passive spells give permanent boosts when memorized.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Ascension</div>
              <div class="desc">Reset progress for permanent bonuses. Ascension is the main long-term reset.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Relics</div>
              <div class="desc">Run-based modifiers earned from milestones or Relic Hunts. They reshape your build.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Sigils</div>
              <div class="desc">Stacks that boost Mana Font click power. Forged via crafting and reset on Ascension.</div>
            </div>
          </div>
        </div>
      </div>

      <div id="settingsPageKeys" class="settings-page hidden">
        <div class="settings-section">
          <p class="settings-section-title">Keybinds</p>
          <div id="keybindsList" class="keybinds-list"></div>
          <p class="cost" style="margin-top:10px;">
            Tips: Shift-click = x10 and Ctrl-click = max for Mana Fonts + room upgrades.
          </p>
        </div>
      </div>
    </div>
  </div>

  <div id="statsModal" class="modal">
    <div class="modal-content">
      <h3>Statistics</h3>
      <div id="statsGrid" class="stats-grid"></div>
      <h4 style="margin-top:16px;">Achievements</h4>
      <div id="achievementsList"></div>
      <button onclick="closeStats()">Close</button>
    </div>
  </div>

  <div id="introModal" class="modal">
    <div class="modal-content intro-content">
      <h3>Welcome to Mage Tower</h3>
      <div class="intro-lore">
        <p><strong>Why you're here:</strong> You are a mage who has claimed a leyline nexus. To channel its power and grow in influence, you must raise a towerroom by roomso your connection to the mana flow deepens. Each floor and every chamber you build strengthens your hold on the nexus and unlocks new spells and abilities.</p>
      </div>
      <div class="intro-how">
        <p><strong>How to play:</strong></p>
        <ul>
          <li><strong>Mana</strong> is earned over time; Mana Fonts boost clicks while followers drive mana/sec.</li>
          <li><strong>Stamina</strong> recovers over time; spend it in grouped <strong>Activities</strong> (Channel, Outreach, Rituals) to push your loop.</li>
          <li>Use the controls beneath the tower to buy <strong>Mana Fonts</strong> and <strong>Raise Floors</strong> (each floor adds a room).</li>
          <li>Open the <strong>Library</strong> for research, schools, glyphs, and crafting; open the <strong>Observatory</strong> for encounters and contracts.</li>
          <li>Unlock and cast spells from the <strong>Grimoire</strong> to multiply gains; spell swaps now cost focus instead of cooldowns.</li>
          <li>Check the <strong>Tower</strong> tab for wards and todays blessing, then click rooms in the tower view to upgrade them.</li>
          <li>Reach relic milestones to draft run-based relics that reshape your build.</li>
        </ul>
      </div>
      <button id="introCloseBtn">Got it</button>
    </div>
  </div>

  <div id="roomDetailModal" class="modal">
    <div class="modal-content room-detail-content">
      <div class="room-detail-header">
        <h3 id="roomDetailTitle">Room</h3>
        <button type="button" class="room-detail-close" id="roomDetailClose" aria-label="Close">&times;</button>
      </div>
      <p id="roomDetailDesc" class="room-detail-desc"></p>
      <p class="room-detail-level">Level: <span id="roomDetailLevel">1</span></p>
      <button id="roomDetailUpgradeBtn" class="room-detail-upgrade">Upgrade</button>
    </div>
  </div>

  <div id="tutorialLayer" aria-hidden="true"></div>
  <div id="loreTip" class="tutorial-tip pos-bottom">
    <strong>Welcome, mage</strong><br>
    You have claimed a leyline nexus. Raise a towerroom by roomto deepen your bond with the mana flow and grow your influence.
    <button type="button" id="loreCloseBtn" class="lore-close">Got it</button>
  </div>
  <div id="toastContainer"></div>

  <div id="offlineModal" class="modal">
    <div class="modal-content offline-modal">
      <h3>Welcome Back!</h3>
      <p>You were away for <span id="offlineTime">0</span></p>
      <div class="offline-gains">
        <div class="gain-row">
          <span>Mana earned:</span>
          <span id="offlineMana" class="gain-value">+0</span>
        </div>
        <div class="gain-row">
          <span>Stamina recovered:</span>
          <span id="offlineStamina" class="gain-value stamina">+0</span>
        </div>
        <div class="gain-row">
          <span>Focus gained:</span>
          <span id="offlineFocus" class="gain-value focus">+0</span>
        </div>
      </div>
      <button id="offlineCloseBtn">Continue</button>
    </div>
  </div>

  <script>
    // -------------------- CONSTANTS --------------------
    const TICK = 100;
    const SCALE = 1;
    const FLOOR_BONUS = 0.01;
    const UNLOCKS = { TIME: 5, ARCANE: 10, ASTRAL: 20 };
    const MANA_FONT_RATE = 0.35; // click bonus per Mana Font
    const FOLLOWER_MPS_RATE = 0.08;
    const PRESTIGE_FLOOR = 50;
    const PRESTIGE_SOFT_FLOOR = 25;
    const PRESTIGE_BONUS = 0.10;
    const PRESTIGE_SOFT_BONUS = 0.05;
    const ASCENSION_FLOOR = 50;
    const ASCENSION_FLOOR_2 = 100;
    const ASCENSION_TAB_UNLOCK = 50;
    const ASCENSION_BONUS_PER = 0.08;
    const ASCENSION_2_BONUS_PER = 0.12;
    const PRESTIGE_KEEP_FLOORS_PCT = 0.03;
    const OFFLINE_CAP_HOURS = 24;
    const LEYLINE_TAP_DURATION = 22;
    const LEYLINE_TAP_PCT = 0.25;
    const RITUAL_OF_BINDING_COOLDOWN_MS = 60 * 60 * 1000;
    const RITUAL_ACTIVITY_COOLDOWN_MS = 30 * 60 * 1000;
    const SPELL_ECHO_FREE_COOLDOWN_MS = 15 * 60 * 1000;
    const MEDITATE_CAP = 5;
    const MEDITATE_PCT_PER_STACK = 0.05;
    const PARAGON_FLOOR_MIN = 100;
    const PARAGON_NODE_COST = 10;
    const PARAGON_XP_PER_TICK = 0.003;
    const GOAL_MANA_PER_SEC = 1e6;
    const VAULT_CAP = 0.50;
    const LIBRARY_LEYLINE_PCT = 0.01;
    const BASE_MANA_MAX = 1000;
    const BASE_STAMINA_MAX = 100;
    const STAMINA_REGEN_BASE = 0.12;
    const STAMINA_REGEN_CAP = 1.0;
    const STAMINA_ROOM_BONUS_CAP = 0.50;
    const TOWER_STRAIN_FLOOR = 40;
    const TOWER_STRAIN_PCT_PER_10 = 0.10;
    const EXHAUSTED_DURATION_MS = 2 * 60 * 1000;
    const FLOOR_STAMINA_COST_PCT = 0.08;
    const BASE_FOCUS_MAX = 50;
    const FOCUS_REGEN_BASE = 0.1;
    const FOCUS_IDLE_SEC = 60;
    const FOCUS_OFFLINE_DIVISOR = 8;
    const OFFLINE_FOCUS_RATE = 0.25;
    const SIGIL_STACK_PCT = 0.02;
    const SIGIL_STACK_CAP = 12;
    const RELIC_MILESTONES = [6, 16, 30, 50, 75, 100, 140, 180];
    const RELIC_HUNT_COOLDOWN_MS = 25 * 60 * 1000;
    const FOLLOWER_THRESHOLDS = { academy: 100, library: 0, observatory: 0 };
    const MAX_OUTPOSTS = 3;
    const ESSENCE_TYPES = ['wind', 'earth', 'fire', 'water', 'arcane', 'astral'];
    const RITUAL_WINDOW_MS = 10 * 60 * 1000;
    const RITUAL_WINDOW_DURATION_MS = 90 * 1000;
    const OVERCHARGE_GRACE_SEC = 4;
    const OVERCHARGE_DRAIN_PCT = 0.015;
    const WARDS_BASE = 100;
    const WARDS_REGEN_BASE = 0.15;

    let game;
    let awaitingRebind = null;

    // -------------------- NUMBER FORMATTING --------------------
    function formatNum(n) {
      if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B';
      if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M';
      if (n >= 1e3) return (n / 1e3).toFixed(2) + 'K';
      return n.toFixed(1);
    }
    function formatRate(n) {
      if (n >= 1e3) return formatNum(n);
      if (n >= 10) return n.toFixed(1);
      if (n >= 1) return n.toFixed(2);
      if (n >= 0.01) return n.toFixed(3);
      return n.toFixed(2);
    }

    function clamp01(x) { return Math.max(0, Math.min(1, x)); }
    function setMiniBar(fillEl, value, max) {
      if (!fillEl) return;
      const pct = max > 0 ? clamp01(value / max) * 100 : 0;
      fillEl.style.width = pct.toFixed(1) + '%';
    }
    function setTabBadge(panelId, on) {
      const tab = document.querySelector('#bottomNav .tab[data-panel="' + panelId + '"]');
      if (!tab) return;
      if (on) tab.classList.add('has-badge');
      else tab.classList.remove('has-badge');
    }

    // -------------------- POLISH HELPER FUNCTIONS --------------------
    function updateResourceFullState(el, value, max) {
      if (!el) return;
      const isFull = value >= max * 0.99;
      if (isFull) el.classList.add('resource-full');
      else el.classList.remove('resource-full');
    }

    function showSaveIndicator(saving) {
      return;
    }

    function formatDuration(ms) {
      const sec = Math.floor(ms / 1000);
      if (sec < 60) return sec + ' seconds';
      const min = Math.floor(sec / 60);
      if (min < 60) return min + ' minute' + (min !== 1 ? 's' : '');
      const hr = Math.floor(min / 60);
      const remainMin = min % 60;
      if (hr < 24) return hr + ' hour' + (hr !== 1 ? 's' : '') + (remainMin > 0 ? ' ' + remainMin + ' min' : '');
      const days = Math.floor(hr / 24);
      const remainHr = hr % 24;
      return days + ' day' + (days !== 1 ? 's' : '') + (remainHr > 0 ? ' ' + remainHr + ' hr' : '');
    }

    function showOfflineProgress(manaGained, staminaGained, focusGained, duration) {
      const modal = document.getElementById('offlineModal');
      if (!modal) return;
      if (manaGained < 1 && staminaGained < 1 && focusGained < 1) return;
      if (duration < 60000) return;
      const closeBtn = document.getElementById('offlineCloseBtn');
      if (closeBtn) {
        closeBtn.onclick = () => { modal.style.display = 'none'; };
      }
      document.getElementById('offlineTime').textContent = formatDuration(duration);
      document.getElementById('offlineMana').textContent = '+' + formatNum(manaGained);
      document.getElementById('offlineStamina').textContent = '+' + formatNum(staminaGained);
      document.getElementById('offlineFocus').textContent = '+' + formatNum(focusGained);
      modal.style.display = 'flex';
    }

    // -------------------- ROOMS --------------------
    const ROOMS = {
      Stairs: { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec per Stairs', buildableOnce: false },
      Vault: { unlock: () => true, unlockFloors: 0, desc: '+5% mana/sec per level (capped 50%). Build once, then upgrade.', buildableOnce: true, manaPct: 0.05, capMana: true },
      Library: { unlock: () => totalFloors() >= UNLOCKS.ARCANE, unlockFloors: UNLOCKS.ARCANE, desc: '+20% Leyline effect per level. Build once, then upgrade.', buildableOnce: true, spellPct: 0.20 },
      Observatory: { unlock: () => totalFloors() >= UNLOCKS.ASTRAL, unlockFloors: UNLOCKS.ASTRAL, desc: 'Boosts Astral Insight +10% per level. Build once, then upgrade.', buildableOnce: true, astralPct: 0.10 },
      Arcanum: { unlock: () => totalFloors() >= 20, unlockFloors: 20, desc: '+1 spell slot. Unlocks at 20 floors.', buildableOnce: true, extraSpellSlots: 1 },
      'Hall of Preservation': { unlock: () => totalFloors() >= 30, unlockFloors: 30, desc: 'Ascension keeps 3% of current floors (as Stairs).', buildableOnce: true, prestigeKeepFloorsPct: 0.03 },
      'Chronurgy Chamber': { unlock: () => totalFloors() >= 40, unlockFloors: 40, desc: '-10% spell-swap cooldown time per level.', buildableOnce: true, swapCooldownReduction: 0.10 },
      'Leyline Nexus': { unlock: () => totalFloors() >= 50, unlockFloors: 50, desc: '+1% mana/sec per Leyline Manipulation level.', buildableOnce: true, leylineNexusPct: 0.01 },
      'Alchemy Lab': { unlock: () => true, unlockFloors: 0, desc: '+0.5% mana/sec per level.', buildableOnce: true, manaPct: 0.005 },
      Scriptorium: { unlock: () => true, unlockFloors: 0, desc: '+0.4% spell effect per level.', buildableOnce: true, spellPct: 0.004 },
      'Meditation Chamber': { unlock: () => true, unlockFloors: 0, desc: '+1% stamina regen per level.', buildableOnce: true, staminaPct: 0.01 },
      'Crystal Storage': { unlock: () => true, unlockFloors: 0, desc: '+0.3% mana/sec per level.', buildableOnce: true, manaPct: 0.003 },
      'Herb Garden': { unlock: () => true, unlockFloors: 0, desc: '+0.25% mana/sec per level.', buildableOnce: true, manaPct: 0.0025 },
      'Summoning Circle': { unlock: () => true, unlockFloors: 0, desc: '+0.35% mana/sec per level.', buildableOnce: true, manaPct: 0.0035 },
      'Enchantment Table': { unlock: () => true, unlockFloors: 0, desc: '+0.3% spell effect per level.', buildableOnce: true, spellPct: 0.003 },
      Wardstone: { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec per level.', buildableOnce: true, manaPct: 0.002 },
      'Leyline Tap': { unlock: () => true, unlockFloors: 0, desc: '+0.25% mana/sec per level.', buildableOnce: true, manaPct: 0.0025 },
      'Scrying Pool': { unlock: () => true, unlockFloors: 0, desc: '+0.5% stamina regen per level.', buildableOnce: true, staminaPct: 0.005 },
      'Bell Tower': { unlock: () => true, unlockFloors: 0, desc: '+0.15% mana/sec per level.', buildableOnce: true, manaPct: 0.0015 },
      Brewery: { unlock: () => true, unlockFloors: 0, desc: '+0.3% mana/sec per level.', buildableOnce: true, manaPct: 0.003 },
      Archive: { unlock: () => true, unlockFloors: 0, desc: '+0.35% spell effect per level.', buildableOnce: true, spellPct: 0.0035 },
      Greenhouse: { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec per level.', buildableOnce: true, manaPct: 0.002 },
      Workshop: { unlock: () => true, unlockFloors: 0, desc: '+0.4% spell effect per level.', buildableOnce: true, spellPct: 0.004 },
      Sanctum: { unlock: () => true, unlockFloors: 0, desc: '+0.15% mana/sec and +1.5% stamina per level.', buildableOnce: true, manaPct: 0.0015, staminaPct: 0.015 },
      Atrium: { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec per level.', buildableOnce: true, manaPct: 0.001 },
      'Ritual Chamber': { unlock: () => true, unlockFloors: 0, desc: '+0.4% mana/sec per level.', buildableOnce: true, manaPct: 0.004 },
      Reliquary: { unlock: () => true, unlockFloors: 0, desc: '+0.2% spell effect per level.', buildableOnce: true, spellPct: 0.002 },
      Conservatory: { unlock: () => true, unlockFloors: 0, desc: '+0.25% stamina regen per level.', buildableOnce: true, staminaPct: 0.0025 },
      'Lantern Room': { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec per level.', buildableOnce: true, manaPct: 0.001 },
      Dispensary: { unlock: () => true, unlockFloors: 0, desc: '+0.2% stamina regen per level.', buildableOnce: true, staminaPct: 0.002 },
      Lectern: { unlock: () => true, unlockFloors: 0, desc: '+0.3% spell effect per level.', buildableOnce: true, spellPct: 0.003 },
      Spire: { unlock: () => true, unlockFloors: 0, desc: '+0.15% mana/sec per level.', buildableOnce: true, manaPct: 0.0015 },
      Antechamber: { unlock: () => true, unlockFloors: 0, desc: '+0.1% stamina regen per level.', buildableOnce: true, staminaPct: 0.001 },
      'Conduit Room': { unlock: () => true, unlockFloors: 0, desc: '+0.35% mana/sec per level.', buildableOnce: true, manaPct: 0.0035 },
      'Offering Shrine': { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec and +0.1% spell per level.', buildableOnce: true, manaPct: 0.002, spellPct: 0.001 },
      Vestibule: { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec per level.', buildableOnce: true, manaPct: 0.001 },
      Turret: { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec per level.', buildableOnce: true, manaPct: 0.002 },
      // More immersive mage tower rooms (all available from floor 0)
      Cloister: { unlock: () => true, unlockFloors: 0, desc: '+0.15% stamina regen per level.', buildableOnce: true, staminaPct: 0.0015 },
      Refinery: { unlock: () => true, unlockFloors: 0, desc: '+0.25% mana/sec per level.', buildableOnce: true, manaPct: 0.0025 },
      'Mana Well': { unlock: () => true, unlockFloors: 0, desc: '+0.3% mana/sec per level.', buildableOnce: true, manaPct: 0.003 },
      'Star Chart Room': { unlock: () => true, unlockFloors: 0, desc: '+0.2% spell effect per level.', buildableOnce: true, spellPct: 0.002 },
      'Echo Chamber': { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec per level.', buildableOnce: true, manaPct: 0.001 },
      'Dust Vault': { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec per level.', buildableOnce: true, manaPct: 0.002 },
      'Ritual Altar': { unlock: () => true, unlockFloors: 0, desc: '+0.35% mana/sec per level.', buildableOnce: true, manaPct: 0.0035 },
      'Candle Hall': { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec per level.', buildableOnce: true, manaPct: 0.001 },
      'Ink Room': { unlock: () => true, unlockFloors: 0, desc: '+0.25% spell effect per level.', buildableOnce: true, spellPct: 0.0025 },
      'Quill Desk': { unlock: () => true, unlockFloors: 0, desc: '+0.2% spell effect per level.', buildableOnce: true, spellPct: 0.002 },
      'Astrolabe Room': { unlock: () => true, unlockFloors: 0, desc: '+0.15% mana/sec per level.', buildableOnce: true, manaPct: 0.0015 },
      'Gargoyle Perch': { unlock: () => true, unlockFloors: 0, desc: '+0.15% mana/sec per level.', buildableOnce: true, manaPct: 0.0015 },
      'Sigil Wall': { unlock: () => true, unlockFloors: 0, desc: '+0.3% spell effect per level.', buildableOnce: true, spellPct: 0.003 },
      'Rune Stone': { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec and +0.1% spell per level.', buildableOnce: true, manaPct: 0.002, spellPct: 0.001 },
      'Potion Cellar': { unlock: () => true, unlockFloors: 0, desc: '+0.3% mana/sec per level.', buildableOnce: true, manaPct: 0.003 },
      'Mortar Room': { unlock: () => true, unlockFloors: 0, desc: '+0.25% mana/sec per level.', buildableOnce: true, manaPct: 0.0025 },
      'Divination Den': { unlock: () => true, unlockFloors: 0, desc: '+0.4% spell effect per level.', buildableOnce: true, spellPct: 0.004 },
      'Oracle Nook': { unlock: () => true, unlockFloors: 0, desc: '+0.2% stamina regen per level.', buildableOnce: true, staminaPct: 0.002 },
      'Sanctified Hall': { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec and +1% stamina per level.', buildableOnce: true, manaPct: 0.001, staminaPct: 0.01 },
      'Chime Room': { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec per level.', buildableOnce: true, manaPct: 0.001 },
      'Brazier Room': { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec per level.', buildableOnce: true, manaPct: 0.002 },
      'Crystal Ball Room': { unlock: () => true, unlockFloors: 0, desc: '+0.35% spell effect per level.', buildableOnce: true, spellPct: 0.0035 },
      'Mirror Hall': { unlock: () => true, unlockFloors: 0, desc: '+0.15% mana/sec per level.', buildableOnce: true, manaPct: 0.0015 },
      'Shadow Alcove': { unlock: () => true, unlockFloors: 0, desc: '+0.25% spell effect per level.', buildableOnce: true, spellPct: 0.0025 },
      'Fountain Court': { unlock: () => true, unlockFloors: 0, desc: '+0.2% stamina regen per level.', buildableOnce: true, staminaPct: 0.002 },
      'Well of Whispers': { unlock: () => true, unlockFloors: 0, desc: '+0.3% mana/sec per level.', buildableOnce: true, manaPct: 0.003 },
      'Binding Circle': { unlock: () => true, unlockFloors: 0, desc: '+0.3% spell effect per level.', buildableOnce: true, spellPct: 0.003 },
      'Focus Chamber': { unlock: () => true, unlockFloors: 0, desc: '+0.4% stamina regen per level.', buildableOnce: true, staminaPct: 0.004 },
      'Resonance Hall': { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec per level.', buildableOnce: true, manaPct: 0.002 },
      'Aether Pool': { unlock: () => true, unlockFloors: 0, desc: '+0.4% mana/sec per level.', buildableOnce: true, manaPct: 0.004 },
      'Weather Vane': { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec per level.', buildableOnce: true, manaPct: 0.001 },
      'Lectern Hall': { unlock: () => true, unlockFloors: 0, desc: '+0.25% spell effect per level.', buildableOnce: true, spellPct: 0.0025 },
      'Grimoire Shelf': { unlock: () => true, unlockFloors: 0, desc: '+0.2% spell effect per level.', buildableOnce: true, spellPct: 0.002 },
      'Essence Still': { unlock: () => true, unlockFloors: 0, desc: '+0.35% mana/sec per level.', buildableOnce: true, manaPct: 0.0035 },
      'Ward Chamber': { unlock: () => true, unlockFloors: 0, desc: '+0.15% stamina regen per level.', buildableOnce: true, staminaPct: 0.0015 },
      'Beacon Tower': { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec per level.', buildableOnce: true, manaPct: 0.002 },
      Solarium: { unlock: () => true, unlockFloors: 0, desc: '+0.15% mana/sec and +1% stamina per level.', buildableOnce: true, manaPct: 0.0015, staminaPct: 0.01 },
      Crypt: { unlock: () => true, unlockFloors: 0, desc: '+0.25% mana/sec per level.', buildableOnce: true, manaPct: 0.0025 },
      'Offering Table': { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec and +0.1% spell per level.', buildableOnce: true, manaPct: 0.002, spellPct: 0.001 },
      'Prism Room': { unlock: () => true, unlockFloors: 0, desc: '+0.3% spell effect per level.', buildableOnce: true, spellPct: 0.003 },
      'Smoke Alcove': { unlock: () => true, unlockFloors: 0, desc: '+0.2% stamina regen per level.', buildableOnce: true, staminaPct: 0.002 },
      'Tome Vault': { unlock: () => true, unlockFloors: 0, desc: '+0.35% spell effect per level.', buildableOnce: true, spellPct: 0.0035 },
      'Cauldron Nook': { unlock: () => true, unlockFloors: 0, desc: '+0.3% mana/sec per level.', buildableOnce: true, manaPct: 0.003 },
      'Pilgrim Rest': { unlock: () => true, unlockFloors: 0, desc: '+0.25% stamina regen per level.', buildableOnce: true, staminaPct: 0.0025 },
      'Apprentice Quarters': { unlock: () => totalFloors() >= 5, unlockFloors: 5, desc: '+5% max mana per level.', buildableOnce: true, manaCapPct: 0.05 },
      'Focus Alcove': { unlock: () => totalFloors() >= 12, unlockFloors: 12, desc: 'Focus regen starts 5% sooner and +2% focus regen per level.', buildableOnce: true, focusIdlePct: -0.05, focusPct: 0.02 },
      'Aether Loom': { unlock: () => totalFloors() >= 30, unlockFloors: 30, desc: '+4% Mana Font click power per level.', buildableOnce: true, fontPct: 0.04 },
      'Sigil Vault': { unlock: () => totalFloors() >= 45, unlockFloors: 45, desc: 'Room upgrades cost 5% less per level.', buildableOnce: true, upgradeCostPct: -0.05 },
      'Curio Gallery': { unlock: () => totalFloors() >= 70, unlockFloors: 70, desc: '+1% mana/sec per relic per level.', buildableOnce: true, relicManaPct: 0.01 },
      'Planar Gate': { unlock: () => totalFloors() >= 90, unlockFloors: 90, desc: '+4% active spell and ritual duration per level.', buildableOnce: true, activeDurationPct: 0.04 },
    };
    const RELICS = [
      { id: 'glimmerstone', name: 'Glimmerstone', tier: 'common', desc: '+8% mana/sec.', mods: { manaMult: 0.08 } },
      { id: 'scribeCharm', name: 'Scribe Charm', tier: 'common', desc: '+30% click mana.', mods: { clickMult: 0.30 } },
      { id: 'glyphThread', name: 'Glyph Thread', tier: 'common', desc: '+10% Mana Font click power.', mods: { fontRateMult: 0.10 } },
      { id: 'fadedTalisman', name: 'Faded Talisman', tier: 'common', desc: '+12% stamina regen.', mods: { staminaRegenMult: 0.12 } },
      { id: 'quietHourglass', name: 'Quiet Hourglass', tier: 'common', desc: 'Focus regen starts 15% sooner.', mods: { focusIdleMult: -0.15 } },
      { id: 'sapphirePrism', name: 'Sapphire Prism', tier: 'uncommon', desc: '+12% spell effect.', mods: { spellEffectMult: 0.12 } },
      { id: 'ironSigil', name: 'Iron Sigil', tier: 'uncommon', desc: '+25 max stamina.', mods: { maxStaminaBonus: 25 } },
      { id: 'lucentCandle', name: 'Lucent Candle', tier: 'uncommon', desc: '+15% focus regen.', mods: { focusRegenMult: 0.15 } },
      { id: 'mindstone', name: 'Mindstone', tier: 'uncommon', desc: '+20 max focus.', mods: { maxFocusBonus: 20 } },
      { id: 'glassEngine', name: 'Glass Engine', tier: 'uncommon', desc: '+15% mana/sec, -8% stamina regen.', mods: { manaMult: 0.15, staminaRegenMult: -0.08 } },
      { id: 'etchingTools', name: 'Etching Tools', tier: 'uncommon', desc: 'Room upgrades cost 8% less.', mods: { upgradeCostMult: -0.08 } },
      { id: 'eclipseSeal', name: 'Eclipse Seal', tier: 'rare', desc: '+25% mana/sec, floor costs +12%.', mods: { manaMult: 0.25, floorCostMult: 0.12 } },
      { id: 'goldenLoop', name: 'Golden Loop', tier: 'rare', desc: '+15% active spell duration and +10% max mana.', mods: { activeDurationMult: 0.15, maxManaMult: 0.10 } },
      { id: 'voidCompass', name: 'Void Compass', tier: 'rare', desc: '+20% spell effect, -10% mana/sec.', mods: { spellEffectMult: 0.20, manaMult: -0.10 } },
      { id: 'stormcore', name: 'Stormcore Prism', tier: 'rare', desc: '+50% wind spells, -30% fire spells.', mods: { windMult: 0.50, fireMult: -0.30 } },
      { id: 'tideboundMirror', name: 'Tidebound Mirror', tier: 'rare', desc: '+35% water spells, -6% mana/sec.', mods: { waterMult: 0.35, manaMult: -0.06 } },
      { id: 'pyreMantle', name: 'Pyre Mantle', tier: 'rare', desc: '+40% fire spells, -8% focus regen.', mods: { fireMult: 0.40, focusRegenMult: -0.08 } },
    ];
    const RELIC_BY_ID = RELICS.reduce((acc, relic) => {
      acc[relic.id] = relic;
      return acc;
    }, {});
    const SPECIAL_ROOM_NAMES = Object.keys(ROOMS).filter(n => ROOMS[n].buildableOnce);
    function initialSpecialRooms() {
      const o = {};
      SPECIAL_ROOM_NAMES.forEach(n => { o[n] = { built: false, level: 0 }; });
      return o;
    }
    function initialEssence() {
      const o = {};
      ESSENCE_TYPES.forEach(t => { o[t] = 0; });
      return o;
    }
    function initialFollowers() {
      return { novice: 0, acolyte: 0, sage: 0 };
    }
    function initialFollowerAssignments() {
      return { market: 0, research: 0, ritual: 0, scouting: 0 };
    }
    function initialAcademyOutposts() {
      return Array.from({ length: MAX_OUTPOSTS }, () => ({
        built: false,
        role: null,
        level: 0,
        modules: [],
        links: { left: false, right: false },
      }));
    }
    function initialAcademyStaff() {
      return {};
    }
    function initialResearchState() {
      return { points: 0, unlocked: [], levels: {} };
    }
    function initialEncounterState() {
      return { active: false, wave: 0, hp: 0, maxHp: 0, timer: 0, modifiers: [], enemyType: null, bossPhase: 0, threat: 0, lastWaveAt: 0 };
    }
    const KEYBIND_DEFAULTS = {
      activities: '1',
      grimoire: '2',
      tower: '3',
      ascension: '4',
      relics: '5',
      manaFont: 'm',
      settings: 's',
      help: '?',
      close: 'esc',
    };
    const KEYBIND_ACTIONS = [
      { id: 'activities', label: 'Toggle Activities' },
      { id: 'grimoire', label: 'Toggle Grimoire' },
      { id: 'tower', label: 'Toggle Tower' },
      { id: 'ascension', label: 'Toggle Ascension (when unlocked)' },
      { id: 'relics', label: 'Toggle Relics' },
      { id: 'manaFont', label: 'Buy Mana Font' },
      { id: 'settings', label: 'Open/close Settings' },
      { id: 'help', label: 'Open How to play' },
      { id: 'close', label: 'Close overlays' },
    ];
    game = {
      mana: 0,
      stamina: 0,
      focus: 0,
      manaFonts: 0,
      gold: 0,
      wards: WARDS_BASE,
      essence: initialEssence(),
      followers: initialFollowers(),
      reputation: 0,
      followerAssignments: initialFollowerAssignments(),
      followerProgress: 0,
      promotionProgress: { novice: 0, acolyte: 0 },
      scoutingProgress: 0,
      academyOutposts: initialAcademyOutposts(),
      academyStaff: initialAcademyStaff(),
      research: initialResearchState(),
      modules: {},
      schools: { primary: null, secondary: null, slots: 1 },
      glyphs: { active: null },
      challenge: { active: null, completed: [], tokens: 0 },
      encounter: initialEncounterState(),
      contracts: [],
      milestonesClaimed: [],
      storySeen: [],
      dailyBlessing: { id: null, bonus: null, lastAt: 0, nextAt: 0 },
      runeEtching: { date: null, pattern: [], selected: [], solvedAt: 0, attempts: 0 },
      runeEtchingBuffEnd: 0,
      cosmetics: { unlocked: [], active: null },
      spellSynergy: { lastElement: null, lastCastAt: 0, chain: [] },
      followerEvent: null,
      nextFollowerEventAt: 0,
      specialRooms: initialSpecialRooms(),
      stairs: 0,
      passive: { arcane: 0, astral: 0, conduit: 0, towerBond: 0, staminaWell: 0, spellEcho: 0, focusFlow: 0, manaReservoir: 0, ritualMastery: 0, aetherFlux: 0, anchoredRituals: 0, luckyClick: 0 },
      active: {
        boost: 1,
        timer: 0,
        duration: 0,
        cooldown: 0,
        harvestTimer: 0,
        harvestDuration: 0,
        boostTD: 1,
        boostHarvest: 1,
        leylineTapTimer: 0,
        leylineTapPct: 0,
        runeTimer: 0,
        runeStacks: 0,
        focusCondenserTimer: 0,
        spellCostDiscountTimer: 0,
        spellCostDiscountPct: 0,
        overclockTimer: 0,
        overclockMult: 1,
        worldweaveTimer: 0,
        convergenceTimer: 0,
        paradoxTimer: 0,
        overchargeTimer: 0,
        overchargeMult: 1,
        concessionTimer: 0,
        comboTimer: 0,
        comboMult: 1,
        overchargeCharge: 0,
        flameSurgeTimer: 0,
        frostSlowTimer: 0,
      },
      studyCount: 0,
      stats: {
        timeDilationCasts: 0,
        arcaneHarvestCasts: 0,
        leylineSurgeCasts: 0,
        focusSurgeCasts: 0,
        vigorInfusionCasts: 0,
        transmutateCasts: 0,
        manaCapHits: 0,
        zeroManaCasts: 0,
        totalManaEarned: 0,
        totalSpellsCast: 0,
        timePlayedMs: 0,
        achievements: [],
        totalFloorsEver: 0,
        totalStaminaSpent: 0,
        maxFloorsReached: 0,
        maxManaPerSecReached: 0,
      },
      prestige: 0,
      softPrestige: 0,
      ascension: 0,
      ascensionTier2: 0,
      prestigeTokens: 0,
      prestigeTokenChoice: null,
      soundEnabled: false,
      speed: 1,
      settings: { showTutorial: true, keybinds: { ...KEYBIND_DEFAULTS } },
      lastSave: Date.now(),
      memorizedSpells: [],
      spellSwapCooldownEnd: 0,
      wardOfPreservationUsed: false,
      ritualOfBindingCooldownEnd: 0,
      ritualOfBindingNextSwapHalved: false,
      meditateStacks: 0,
      scryLockedRoom: null,
      transcribeBonusPct: 0,
      ritualBuffEnd: 0,
      ritualWindowBonusPct: 0,
      ritualWindowBonusEnd: 0,
      attuneDiscount: 0,
      ritualActivityCooldownEnd: 0,
      spellEchoNextFreeAt: 0,
      transmutateCooldownEnd: 0,
      manaSiphonCooldownEnd: 0,
      runeAccretionCooldownEnd: 0,
      staminaTransmuteCooldownEnd: 0,
      focusCondenserCooldownEnd: 0,
      leylineResonanceCooldownEnd: 0,
      towerPulseCooldownEnd: 0,
      chronoLoopCooldownEnd: 0,
      nexusOverclockCooldownEnd: 0,
      worldweaveCooldownEnd: 0,
      convergenceCooldownEnd: 0,
      paradoxCastCooldownEnd: 0,
      relics: [],
      relicDraft: [],
      relicDraftSeen: false,
      sigilStacks: 0,
      relicHuntCooldownEnd: 0,
      floorsKept: 0,
      nextFloorDuplicate: null,
      nextFloorCursed: false,
      nextFloorBonus: false,
      nextFloorDiscountPct: 0,
      nextFloorOffers: null,
      nextFloorRolled: false,
      paragonXp: 0,
      paragonSpent: { manaPct: 0, spellEffect: 0, stamina: 0, focus: 0 },
      lastActivityOrSpellAt: 0,
      exhaustedUntil: 0,
      wasManaCapped: false,
      tutorial: { clicked: false, done: false, completedToast: false, settingsOpened: false, keysSeen: false, glossarySeen: false, libraryOpened: false, observatoryOpened: false, towerOpened: false, activitiesOpened: false },
    };
    const STAIRS_MANA_PCT = 0.001;
    const UPGRADE_COST_BASE = 80;

    // -------------------- UI ELEMENTS --------------------
    const mana = document.getElementById('mana');
    const manaPerSec = document.getElementById('manaPerSec');
    const staminaEl = document.getElementById('stamina');
    const staminaMaxEl = document.getElementById('staminaMax');
    const staminaPerSecEl = document.getElementById('staminaPerSec');
    const focusEl = document.getElementById('focus');
    const focusMaxEl = document.getElementById('focusMax');
    const focusPerSecEl = document.getElementById('focusPerSec');
    const focusIdleHint = document.getElementById('focusIdleHint');
    const exhaustedHint = document.getElementById('exhaustedHint');
    const floors = document.getElementById('floors');
    const roomSummary = document.getElementById('roomSummary');
    const towerUpgradeButtons = document.getElementById('towerUpgradeButtons');
    const grimoireSpellSlotsEl = document.getElementById('grimoireSpellSlots');
    const grimoireSwapTimerEl = document.getElementById('grimoireSwapTimer');
    const activeSpellsDiv = document.getElementById('activeSpells');
    const passiveSpellsDiv = document.getElementById('passiveSpells');
    const grimoireModal = document.getElementById('grimoireModal');
    const manaFontBtn = document.getElementById('manaFontBtn');
    const manaFontCostEl = document.getElementById('manaFontCost');
    const manaFontPreview = document.getElementById('manaFontPreview');
    const towerBtn = document.getElementById('towerBtn');
    const towerCostEl = document.getElementById('towerCost');
    const towerPreview = document.getElementById('towerPreview');
    const towerContainer = document.getElementById('towerContainer');
    const roomModal = document.getElementById('roomModal');
    const roomChoices = document.getElementById('roomChoices');
    const relicModal = document.getElementById('relicModal');
    const relicChoices = document.getElementById('relicChoices');
    const relicSummary = document.getElementById('relicSummary');
    const relicDraftSection = document.getElementById('relicDraftSection');
    const relicDraftBtn = document.getElementById('relicDraftBtn');
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const ascensionTab = document.getElementById('ascensionTab');
    const relicTab = document.querySelector('#bottomNav .tab[data-panel="relicsModal"]');
    const ascensionDesc = document.getElementById('ascensionDesc');
    const ascendBtn = document.getElementById('ascendBtn');
    const timeDilationStatus = document.getElementById('timeDilationStatus');
    const timeDilationTime = document.getElementById('timeDilationTime');
    const timeDilationFill = document.getElementById('timeDilationFill');
    const timeDilationBoost = document.getElementById('timeDilationBoost');
    const manaMaxEl = document.getElementById('manaMax');
    const manaFillEl = document.getElementById('manaFill');
    const staminaFillEl = document.getElementById('staminaFill');
    const focusFillEl = document.getElementById('focusFill');
    const tutorialLayer = document.getElementById('tutorialLayer');
    const towerTab = document.querySelector('#bottomNav .tab[data-panel="towerModal"]');
    const activitiesTab = document.querySelector('#bottomNav .tab[data-panel="activitiesModal"]');
    const activitiesDiv = document.getElementById('activities');
    const soundCheckbox = document.getElementById('soundCheckbox');
    const tutorialCheckbox = document.getElementById('tutorialCheckbox');
    const tutorialResetBtn = document.getElementById('tutorialResetBtn');
    const settingsTabPrefs = document.getElementById('settingsTabPrefs');
    const settingsTabKeys = document.getElementById('settingsTabKeys');
    const settingsTabGlossary = document.getElementById('settingsTabGlossary');
    const settingsPagePrefs = document.getElementById('settingsPagePrefs');
    const settingsPageKeys = document.getElementById('settingsPageKeys');
    const settingsPageGlossary = document.getElementById('settingsPageGlossary');
    const statsModal = document.getElementById('statsModal');
    const introModal = document.getElementById('introModal');
    const introCloseBtn = document.getElementById('introCloseBtn');
    const roomDetailModal = document.getElementById('roomDetailModal');
    const roomDetailClose = document.getElementById('roomDetailClose');
    const roomDetailTitle = document.getElementById('roomDetailTitle');
    const roomDetailDesc = document.getElementById('roomDetailDesc');
    const roomDetailLevel = document.getElementById('roomDetailLevel');
    const roomDetailUpgradeBtn = document.getElementById('roomDetailUpgradeBtn');
    const statsGrid = document.getElementById('statsGrid');
    const achievementsList = document.getElementById('achievementsList');
    const paragonSection = document.getElementById('paragonSection');
    const paragonXpEl = document.getElementById('paragonXpEl');
    const paragonNodes = document.getElementById('paragonNodes');
    const loreTip = document.getElementById('loreTip');
    const loreCloseBtn = document.getElementById('loreCloseBtn');
    const keybindsList = document.getElementById('keybindsList');
    const toastContainer = document.getElementById('toastContainer');
    const manaBlock = document.getElementById('manaBlock');
    const staminaBlock = document.getElementById('staminaBlock');
    const focusBlock = document.getElementById('focusBlock');
    const essenceBlock = document.getElementById('essenceBlock');
    const pauseBtn = document.getElementById('pauseBtn');
    const playBtn = document.getElementById('playBtn');
    const speedBtn = document.getElementById('speedBtn');

    if (essenceBlock) {
      essenceBlock.addEventListener('click', (e) => {
        e.stopPropagation();
        essenceBlock.classList.toggle('show-tooltip');
      });
      document.addEventListener('click', () => essenceBlock.classList.remove('show-tooltip'));
    }
    const followersTotalEl = document.getElementById('followersTotal');
    const reputationEl = document.getElementById('reputation');
    const goldEl = document.getElementById('gold');
    const goldUpkeepEl = document.getElementById('goldUpkeep');
    const towerWardsEl = document.getElementById('towerWards');
    const towerWardsMaxEl = document.getElementById('towerWardsMax');
    const towerWardsPerSecEl = document.getElementById('towerWardsPerSec');
    const towerBlessingPanel = document.getElementById('towerBlessingPanel');
    const essenceTotalEl = document.getElementById('essenceTotal');
    const essenceTooltipEl = document.getElementById('essenceTooltip');
    const academyTab = document.getElementById('academyTab');
    const libraryTab = document.getElementById('libraryTab');
    const observatoryTab = document.getElementById('observatoryTab');
    const academySummary = document.getElementById('academySummary');
    const outpostList = document.getElementById('outpostList');
    const staffList = document.getElementById('staffList');
    const marketPanel = document.getElementById('marketPanel');
    const moduleInventory = document.getElementById('moduleInventory');
    const librarySummary = document.getElementById('librarySummary');
    const researchTree = document.getElementById('researchTree');
    const schoolChoices = document.getElementById('schoolChoices');
    const glyphChoices = document.getElementById('glyphChoices');
    const runeEtchingPanel = document.getElementById('runeEtchingPanel');
    const craftingPanel = document.getElementById('craftingPanel');
    const storyPanel = document.getElementById('storyPanel');
    const encounterSummary = document.getElementById('encounterSummary');
    const encounterPanel = document.getElementById('encounterPanel');
    const contractsPanel = document.getElementById('contractsPanel');
    const challengePanel = document.getElementById('challengePanel');
    const cosmeticPanel = document.getElementById('cosmeticPanel');
    const followerEventModal = document.getElementById('followerEventModal');
    const followerEventContent = document.getElementById('followerEventContent');

    // -------------------- COSTS --------------------
    const manaFontCost = () => 10 + game.manaFonts * 9;

    function totalManaFontCostFor(n) {
      // linear cost: (10 + 9*fonts) + ... + (10 + 9*(fonts+n-1))
      const nSafe = Math.max(0, Math.floor(n));
      if (nSafe <= 0) return 0;
      const first = manaFontCost();
      return (nSafe / 2) * (2 * first + 9 * (nSafe - 1));
    }
    function maxAffordableManaFonts() {
      const budget = game.mana || 0;
      const first = manaFontCost();
      // Solve: 9n^2 + (2*first - 9)n - 2*budget <= 0
      const A = 9;
      const B = 2 * first - 9;
      const disc = B * B + 72 * budget;
      const n = Math.floor((-B + Math.sqrt(Math.max(0, disc))) / (2 * A));
      // safety
      let nSafe = Math.max(0, n);
      while (nSafe > 0 && totalManaFontCostFor(nSafe) > budget + 1e-9) nSafe--;
      return nSafe;
    }
    function buyManaFonts(nWanted) {
      const n = Math.min(Math.max(0, Math.floor(nWanted)), 100000);
      if (n <= 0) return 0;
      const cost = totalManaFontCostFor(n);
      if (game.mana < cost) return 0;
      game.mana -= cost;
      game.manaFonts += n;
      return n;
    }

    function totalFloors() {
      const sr = game.specialRooms || {};
      let special = 0;
      SPECIAL_ROOM_NAMES.forEach(name => { if (sr[name] && sr[name].built) special++; });
      return (game.stairs || 0) + special + (game.floorsKept || 0);
    }
    function totalFloorsFromGame(g) {
      const sr = g.specialRooms || {};
      let special = 0;
      SPECIAL_ROOM_NAMES.forEach(name => { if (sr[name] && sr[name].built) special++; });
      return (g.stairs || 0) + special + (g.floorsKept || 0);
    }
    function totalFollowers() {
      const f = game.followers || {};
      return (f.novice || 0) + (f.acolyte || 0) + (f.sage || 0);
    }
    function totalFollowersFromGame(g) {
      const f = g.followers || {};
      return (f.novice || 0) + (f.acolyte || 0) + (f.sage || 0);
    }
    function effectiveFollowerScore(f = game.followers || {}) {
      return (f.novice || 0) + (f.acolyte || 0) * 1.4 + (f.sage || 0) * 2.2;
    }
    function assignedFollowers() {
      const a = game.followerAssignments || {};
      return (a.market || 0) + (a.research || 0) + (a.ritual || 0) + (a.scouting || 0);
    }
    function availableFollowers() {
      return Math.max(0, totalFollowers() - assignedFollowers());
    }
    function diminishingBonus(score, per, cap) {
      const raw = score * per;
      if (cap <= 0) return 0;
      return cap * (1 - Math.exp(-raw / cap));
    }
    function followerManaBonusPct() {
      const score = effectiveFollowerScore();
      return diminishingBonus(score, 0.004, 0.5);
    }
    function followerManaPerSecBonus() {
      const score = effectiveFollowerScore();
      return diminishingBonus(score, 0.0016, 0.25);
    }
    function followerSpellEffectBonus() {
      const f = game.followers || {};
      const score = (f.acolyte || 0) * 0.6 + (f.sage || 0) * 1.2;
      return diminishingBonus(score, 0.0025, 0.2);
    }
    function followerReputationMultiplier() {
      return 1 + (game.reputation || 0) * 0.0025;
    }
    function gainGold(amount) {
      if (!amount || amount <= 0) return;
      game.gold = (game.gold || 0) + amount;
    }
    function spendGold(amount) {
      if (!amount || amount <= 0) return true;
      if ((game.gold || 0) < amount) return false;
      game.gold -= amount;
      return true;
    }
    function gainEssence(type, amount) {
      if (!amount || amount <= 0) return;
      if (!game.essence || typeof game.essence !== 'object') game.essence = initialEssence();
      if (typeof game.essence[type] !== 'number') game.essence[type] = 0;
      game.essence[type] += amount;
    }
    function spendEssence(type, amount) {
      if (!amount || amount <= 0) return true;
      if (!game.essence || typeof game.essence !== 'object') game.essence = initialEssence();
      if ((game.essence[type] || 0) < amount) return false;
      game.essence[type] -= amount;
      return true;
    }
    function gainFollowers(count) {
      if (!count || count <= 0) return;
      if (!game.followers || typeof game.followers !== 'object') game.followers = initialFollowers();
      game.followers.novice = (game.followers.novice || 0) + count;
    }
    function loseFollowers(count) {
      if (!count || count <= 0) return;
      if (!game.followers || typeof game.followers !== 'object') game.followers = initialFollowers();
      let remaining = count;
      const remove = (tier) => {
        const avail = game.followers[tier] || 0;
        const take = Math.min(avail, remaining);
        game.followers[tier] = avail - take;
        remaining -= take;
      };
      remove('novice');
      remove('acolyte');
      remove('sage');
    }
    function adjustReputation(delta) {
      const rep = (game.reputation || 0) + delta;
      game.reputation = Math.max(0, Math.min(100, rep));
    }
    function assignmentCount(key) {
      return (game.followerAssignments && game.followerAssignments[key]) ? game.followerAssignments[key] : 0;
    }
    function assignFollowers(task, delta) {
      if (!game.followerAssignments) game.followerAssignments = initialFollowerAssignments();
      const current = game.followerAssignments[task] || 0;
      if (delta > 0 && assignedFollowers() >= totalFollowers()) return;
      if (delta < 0 && current <= 0) return;
      game.followerAssignments[task] = Math.max(0, current + delta);
    }
    function followerGrowthPerSecond() {
      const base = 0;
      const scouting = assignmentCount('scouting') * 0.0006;
      const outpost = outpostEffects().followers || 0;
      const staff = staffEffect('followers') || 0;
      const research = researchEffect('followers') || 0;
      const blessing = dailyBlessingBonus('followers');
      return (base + scouting + outpost + staff) * followerReputationMultiplier() * (1 + research + blessing);
    }
    function promoteFollowers(dt) {
      if (!game.followers) return;
      const promoMult = 1 + (staffEffect('promotion') || 0);
      const noviceRate = 0.0007 * promoMult;
      const acolyteRate = 0.00035 * promoMult;
      game.promotionProgress = game.promotionProgress || { novice: 0, acolyte: 0 };
      const novices = game.followers.novice || 0;
      const acolytes = game.followers.acolyte || 0;
      game.promotionProgress.novice += novices * noviceRate * dt;
      game.promotionProgress.acolyte += acolytes * acolyteRate * dt;
      const toAcolyte = Math.floor(game.promotionProgress.novice);
      const toSage = Math.floor(game.promotionProgress.acolyte);
      if (toAcolyte > 0) {
        game.promotionProgress.novice -= toAcolyte;
        game.followers.novice = Math.max(0, novices - toAcolyte);
        game.followers.acolyte = (game.followers.acolyte || 0) + toAcolyte;
      }
      if (toSage > 0) {
        game.promotionProgress.acolyte -= toSage;
        game.followers.acolyte = Math.max(0, (game.followers.acolyte || 0) - toSage);
        game.followers.sage = (game.followers.sage || 0) + toSage;
      }
    }
    function getDailyBlessing() {
      if (!game.dailyBlessing || !game.dailyBlessing.id) return null;
      return DAILY_BLESSINGS.find(b => b.id === game.dailyBlessing.id) || null;
    }
    function dailyBlessingBonus(key) {
      const b = getDailyBlessing();
      if (!b || !b.mods) return 0;
      const val = b.mods[key];
      return typeof val === 'number' ? val : 0;
    }
    function currentDayKey() {
      const d = new Date();
      return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
    }
    function ensureDailyBlessing() {
      const now = Date.now();
      if (!game.dailyBlessing) game.dailyBlessing = { id: null, bonus: null, lastAt: 0, nextAt: 0 };
      if (game.dailyBlessing.nextAt && now < game.dailyBlessing.nextAt) return;
      const blessing = DAILY_BLESSINGS[Math.floor(Math.random() * DAILY_BLESSINGS.length)];
      game.dailyBlessing = {
        id: blessing.id,
        bonus: blessing.mods,
        lastAt: now,
        nextAt: now + 24 * 60 * 60 * 1000,
      };
      showToast('Daily Blessing', blessing.name + '  ' + blessing.desc);
    }
    function ensureRunePattern() {
      const key = currentDayKey();
      if (!game.runeEtching || game.runeEtching.date !== key) {
        const pattern = [];
        while (pattern.length < 3) {
          pattern.push(RUNE_SYMBOLS[Math.floor(Math.random() * RUNE_SYMBOLS.length)]);
        }
        game.runeEtching = { date: key, pattern, selected: [], solvedAt: 0, attempts: 0 };
      }
    }
    function runeEtchingMaxAttempts() {
      const bonus = staffEffect('rune') || 0;
      return 3 + (bonus >= 0.1 ? 1 : 0);
    }
    function arraysEqual(a, b) {
      if (!Array.isArray(a) || !Array.isArray(b)) return false;
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }
    function attemptRuneEtching() {
      ensureRunePattern();
      const state = game.runeEtching;
      const maxAttempts = runeEtchingMaxAttempts();
      if (!state || (state.attempts || 0) >= maxAttempts) {
        showToast('Rune Etching', 'No attempts left today.');
        return;
      }
      state.attempts = (state.attempts || 0) + 1;
      const success = arraysEqual(state.selected, state.pattern);
      if (success) {
        state.solvedAt = Date.now();
        const duration = 5 * 60 * 1000 * (1 + (staffEffect('rune') || 0));
        game.runeEtchingBuffEnd = Date.now() + duration;
        showToast('Rune Etched', 'Spell power boosted for 5 minutes.');
      } else {
        showToast('Rune Etching', 'The pattern resists your attempt.');
      }
      state.selected = [];
    }
    function researchPointsPerSecond() {
      const base = 0.002;
      const assigned = assignmentCount('research') * 0.0008;
      const outpost = outpostEffects().research || 0;
      const staff = staffEffect('research') || 0;
      const blessing = dailyBlessingBonus('research');
      const researchBoost = researchEffect('research') || 0;
      const challengeBonus = completedChallengeBonus('research') + challengeReward('research');
      return (base + assigned + outpost + staff) * (1 + researchBoost + blessing + challengeBonus);
    }
    function goldPerSecond() {
      const market = assignmentCount('market') * 0.02;
      const staffMult = 1 + (staffEffect('gold') || 0) + (staffEffect('market') || 0);
      const repMult = 1 + (game.reputation || 0) * 0.001;
      const blessing = 1 + dailyBlessingBonus('gold');
      return market * staffMult * repMult * blessing;
    }
    function canAffordCost(cost) {
      if (!cost) return true;
      if (cost.gold && (game.gold || 0) < cost.gold) return false;
      if (cost.essence) {
        return ESSENCE_TYPES.every(t => (game.essence && game.essence[t] || 0) >= (cost.essence[t] || 0));
      }
      return true;
    }
    function payCost(cost) {
      if (!canAffordCost(cost)) return false;
      if (cost.gold) spendGold(cost.gold);
      if (cost.essence) {
        ESSENCE_TYPES.forEach(t => {
          const amt = cost.essence[t] || 0;
          if (amt > 0) spendEssence(t, amt);
        });
      }
      return true;
    }
    function formatCost(cost) {
      if (!cost) return '';
      const parts = [];
      if (cost.gold) parts.push(cost.gold + ' gold');
      if (cost.essence) {
        ESSENCE_TYPES.forEach(t => {
          const amt = cost.essence[t] || 0;
          if (amt > 0) parts.push(amt + ' ' + t);
        });
      }
      return parts.join(', ');
    }
    function moduleSlotsPerOutpost() {
      const base = 1;
      const bonus = researchEffect('moduleSlots') || 0;
      return base + bonus;
    }
    function outpostBuildCost(index) {
      const tier = Math.min(2, Math.max(0, index));
      return { gold: 120 + tier * 80, essence: { arcane: 6 + tier * 4, fire: 4 + tier * 2 } };
    }
    function outpostUpgradeCost(level) {
      const lvl = Math.max(1, level);
      return { gold: 60 + lvl * 45, essence: { arcane: 4 + lvl * 2 } };
    }
    function buildOutpost(index) {
      const outposts = game.academyOutposts || [];
      const o = outposts[index];
      if (!o || o.built) return;
      const cost = outpostBuildCost(index);
      if (!payCost(cost)) return;
      o.built = true;
      o.level = 1;
      o.role = o.role || 'ward';
      o.modules = [];
    }
    function upgradeOutpost(index) {
      const outposts = game.academyOutposts || [];
      const o = outposts[index];
      if (!o || !o.built) return;
      const cost = outpostUpgradeCost(o.level || 1);
      if (!payCost(cost)) return;
      o.level = (o.level || 1) + 1;
    }
    function setOutpostRole(index, roleId) {
      const outposts = game.academyOutposts || [];
      const o = outposts[index];
      if (!o || !o.built) return;
      o.role = roleId;
    }
    function toggleOutpostLink(index, side) {
      const outposts = game.academyOutposts || [];
      const o = outposts[index];
      if (!o || !o.built) return;
      if (!o.links) o.links = { left: false, right: false };
      o.links[side] = !o.links[side];
      if (side === 'left' && outposts[index - 1] && outposts[index - 1].built) {
        if (!outposts[index - 1].links) outposts[index - 1].links = { left: false, right: false };
        outposts[index - 1].links.right = o.links.left;
      }
      if (side === 'right' && outposts[index + 1] && outposts[index + 1].built) {
        if (!outposts[index + 1].links) outposts[index + 1].links = { left: false, right: false };
        outposts[index + 1].links.left = o.links.right;
      }
    }
    function installModule(index, moduleId) {
      const outposts = game.academyOutposts || [];
      const o = outposts[index];
      if (!o || !o.built) return;
      const slots = moduleSlotsPerOutpost();
      if (!Array.isArray(o.modules)) o.modules = [];
      if (o.modules.length >= slots) return;
      if (moduleCount(moduleId) <= 0) return;
      o.modules.push(moduleId);
      removeModule(moduleId, 1);
    }
    function removeModuleFromOutpost(index, slotIdx) {
      const outposts = game.academyOutposts || [];
      const o = outposts[index];
      if (!o || !o.built || !Array.isArray(o.modules)) return;
      const id = o.modules[slotIdx];
      if (!id) return;
      o.modules.splice(slotIdx, 1);
      addModule(id, 1);
    }
    function setSchoolSlot(slot, id) {
      if (!getSchoolById(id)) return;
      if (!game.schools) game.schools = { primary: null, secondary: null, slots: 1 };
      if (slot === 'primary') game.schools.primary = id;
      if (slot === 'secondary' && (game.schools.slots || 1) >= 2) game.schools.secondary = id;
    }
    function clearSchoolSlot(slot) {
      if (!game.schools) return;
      if (slot === 'primary') game.schools.primary = null;
      if (slot === 'secondary') game.schools.secondary = null;
    }
    function toggleGlyph(id) {
      if (!game.glyphs) game.glyphs = { active: null };
      game.glyphs.active = game.glyphs.active === id ? null : id;
    }
    function activeChallenge() {
      const id = game.challenge && game.challenge.active;
      return ASCENSION_CHALLENGES.find(c => c.id === id) || null;
    }
    function challengePenalty(key) {
      const c = activeChallenge();
      if (!c || !c.penalties) return 0;
      const val = c.penalties[key];
      return typeof val === 'number' ? val : 0;
    }
    function challengeReward(key) {
      const c = activeChallenge();
      if (!c || !c.rewards) return 0;
      const val = c.rewards[key];
      return typeof val === 'number' ? val : 0;
    }
    function completedChallengeBonus(key) {
      if (!game.challenge || !Array.isArray(game.challenge.completed)) return 0;
      let total = 0;
      game.challenge.completed.forEach(id => {
        const c = ASCENSION_CHALLENGES.find(ch => ch.id === id);
        if (!c || !c.rewards) return;
        const val = c.rewards[key];
        if (typeof val === 'number') total += val;
      });
      return total;
    }
    function activateChallenge(id) {
      if (!ASCENSION_CHALLENGES.find(c => c.id === id)) return;
      game.challenge.active = id;
    }
    function moduleCount(id) {
      if (!game.modules || typeof game.modules !== 'object') game.modules = {};
      return game.modules[id] || 0;
    }
    function addModule(id, count = 1) {
      if (!game.modules || typeof game.modules !== 'object') game.modules = {};
      game.modules[id] = (game.modules[id] || 0) + count;
    }
    function removeModule(id, count = 1) {
      if (!game.modules || typeof game.modules !== 'object') game.modules = {};
      game.modules[id] = Math.max(0, (game.modules[id] || 0) - count);
    }
    function scheduleNextFollowerEvent() {
      const now = Date.now();
      const variance = (Math.random() * 2 + 4) * 60 * 1000;
      game.nextFollowerEventAt = now + variance;
    }
    function openFollowerEventModal() {
      if (!followerEventModal || !followerEventContent || !game.followerEvent) return;
      const event = game.followerEvent;
      followerEventContent.innerHTML = '';
      const title = document.createElement('h3');
      title.textContent = event.title;
      const body = document.createElement('p');
      body.textContent = event.text;
      followerEventContent.appendChild(title);
      followerEventContent.appendChild(body);
      const choices = document.createElement('div');
      choices.className = 'choice-row';
      event.options.forEach(opt => {
        const btn = document.createElement('button');
        btn.className = 'event-choice';
        btn.textContent = opt.label;
        btn.onclick = () => {
          opt.effect();
          game.followerEvent = null;
          followerEventModal.style.display = 'none';
          scheduleNextFollowerEvent();
          renderAll();
        };
        choices.appendChild(btn);
      });
      followerEventContent.appendChild(choices);
      followerEventModal.style.display = 'flex';
    }
    function maybeTriggerFollowerEvent() {
      if (game.followerEvent) return;
      if (totalFollowers() < 10) return;
      if (!game.nextFollowerEventAt) {
        scheduleNextFollowerEvent();
        return;
      }
      const now = Date.now();
      if ((game.nextFollowerEventAt || 0) > now) return;
      const event = FOLLOWER_EVENTS[Math.floor(Math.random() * FOLLOWER_EVENTS.length)];
      game.followerEvent = event;
      openFollowerEventModal();
    }
    function pickWaveModifiers(count) {
      const bag = WAVE_MODIFIERS.slice();
      const picks = [];
      while (bag.length && picks.length < count) {
        const idx = Math.floor(Math.random() * bag.length);
        picks.push(bag.splice(idx, 1)[0]);
      }
      return picks;
    }
    function encounterSpellPower() {
      const base = manaPerSecond() * 0.12 + maxMana() * 0.01;
      const effect = spellEffectMultiplier() * activeEffectMultiplier();
      const school = 1 + schoolBonus('combo');
      return base * effect * school;
    }
    function encounterPlayerDamageMult(manaRatio, mods, enemy) {
      let mult = 1 + (researchEffect('encounterDamage') || 0);
      const module = moduleEffects().encounterDamage || 0;
      mult += module;
      const comboBonus = schoolBonus('combo');
      mult += comboBonus;
      const glyphPenalty = glyphBonus('spellCost');
      if (glyphPenalty > 0) mult *= 1 - glyphPenalty * 0.25;
      if (enemy && enemy.highMana && manaRatio >= 0.8) mult *= 1 + (enemy.highMana.playerDamage || 0);
      if (enemy && enemy.lowMana && manaRatio <= 0.4) mult *= 1 + (enemy.lowMana.playerDamage || 0);
      if (enemy && enemy.steady) mult *= 1 + (enemy.steady.playerDamage || 0);
      mods.forEach(m => { if (m.playerDamage) mult *= 1 + m.playerDamage; });
      return Math.max(0.2, mult);
    }
    function encounterEnemyDamageMult(manaRatio, mods, enemy) {
      let mult = 1 + glyphBonus('enemyDamage');
      if (enemy && enemy.highMana && manaRatio >= 0.8) mult *= 1 + (enemy.highMana.enemyDamage || 0);
      if (enemy && enemy.overcharge && (game.active && game.active.overchargeTimer > 0)) mult *= 1 + (enemy.overcharge.enemyDamage || 0);
      mods.forEach(m => { if (m.enemyDamage) mult *= 1 + m.enemyDamage; });
      return Math.max(0.1, mult);
    }
    function startEncounter() {
      if (game.encounter && game.encounter.active) return;
      if (!game.encounter) game.encounter = initialEncounterState();
      const wave = (game.encounter.wave || 0) + 1;
      const enemy = ENEMY_TYPES[Math.floor(Math.random() * ENEMY_TYPES.length)];
      const modifierCount = wave % 5 === 0 ? 2 : 1;
      const modifiers = pickWaveModifiers(modifierCount);
      const threat = game.encounter.threat || 0;
      const baseHp = 80 + wave * 25 + totalFloors() * 2;
      let hp = baseHp * (1 + threat * 0.04);
      modifiers.forEach(m => { if (m.hpMult) hp *= m.hpMult; });
      const timeLimit = Math.max(18, 40 - wave * 0.4);
      game.encounter = {
        active: true,
        wave,
        hp,
        maxHp: hp,
        timer: timeLimit,
        modifiers: modifiers.map(m => m.id),
        enemyType: enemy.id,
        bossPhase: 0,
        threat,
        lastWaveAt: Date.now(),
      };
    }
    function resolveEncounterOutcome(success) {
      const enc = game.encounter || initialEncounterState();
      const wave = enc.wave || 0;
      const mods = (enc.modifiers || []).map(id => WAVE_MODIFIERS.find(m => m.id === id)).filter(Boolean);
      let rewardMult = 1;
      mods.forEach(m => { if (m.rewardMult) rewardMult *= m.rewardMult; });
      rewardMult *= 1 + (moduleEffects().essenceDrop || 0) + challengeReward('essenceDrop') + completedChallengeBonus('essenceDrop');
      if (success) {
        const goldGain = Math.round((30 + wave * 6) * rewardMult);
        gainGold(goldGain);
        const essenceType = selectedSchools()[0] || ESSENCE_TYPES[Math.floor(Math.random() * ESSENCE_TYPES.length)];
        const essenceBase = Math.round((4 + wave * 1.2) * rewardMult);
        gainEssence(essenceType, essenceBase);
        if (Math.random() < 0.15) gainFollowers(2);
        showToast('Encounter cleared', '+' + goldGain + ' gold  +' + essenceBase + ' ' + essenceType + ' essence');
        onWaveCompleted(true);
      } else {
        adjustReputation(-3);
        loseFollowers(4);
        showToast('Encounter failed', 'Your wards falter. Reputation slips.');
        onWaveCompleted(false);
      }
      game.encounter.active = false;
    }
    function updateEncounter(dt) {
      if (!game.encounter || !game.encounter.active) return;
      const enc = game.encounter;
      const enemy = ENEMY_TYPES.find(e => e.id === enc.enemyType);
      const mods = (enc.modifiers || []).map(id => WAVE_MODIFIERS.find(m => m.id === id)).filter(Boolean);
      const manaRatio = maxMana() > 0 ? (game.mana || 0) / maxMana() : 0;
      let damageMult = encounterPlayerDamageMult(manaRatio, mods, enemy);
      const moduleBonus = moduleEffects();
      const frostSlow = (game.active && game.active.frostSlowTimer > 0) ? 0.15 : 0;
      const slow = Math.min(0.6, (moduleBonus.slow || 0) + schoolBonus('slow') + frostSlow);
      const speedMult = mods.reduce((acc, m) => acc * (m.speedMult || 1), 1) * Math.max(0.5, 1 - slow);
      const bossWave = enc.wave % 5 === 0;
      if (bossWave && enc.bossPhase >= 1) damageMult *= 0.88;
      const dps = encounterSpellPower() * damageMult;
      enc.hp -= dps * dt;
      enc.timer -= dt * speedMult;
      const baseEnemy = (1 + enc.wave * 0.12) * (1 + (enc.threat || 0) * 0.04);
      let enemyMult = encounterEnemyDamageMult(manaRatio, mods, enemy);
      enemyMult *= Math.max(0.5, 1 - slow);
      if (bossWave && enc.bossPhase >= 2) enemyMult *= 1.2;
      if (moduleBonus.stun && Math.random() < moduleBonus.stun * dt) enemyMult *= 0.5;
      const wardDamage = baseEnemy * enemyMult * dt;
      game.wards = Math.max(0, (game.wards || 0) - wardDamage);
      if (bossWave) {
        const hpPct = enc.maxHp > 0 ? enc.hp / enc.maxHp : 0;
        if (hpPct < 0.6 && enc.bossPhase < 1) {
          enc.bossPhase = 1;
          game.mana = Math.max(0, game.mana - maxMana() * 0.08);
          game.active.spellCostDiscountPct = -0.15;
          game.active.spellCostDiscountTimer = Math.max(game.active.spellCostDiscountTimer || 0, 8);
          showToast('Boss Phase', 'Silence surge: spells cost more.');
        }
        if (hpPct < 0.3 && enc.bossPhase < 2) {
          enc.bossPhase = 2;
        }
      }
      if (enc.hp <= 0) {
        resolveEncounterOutcome(true);
      } else if (enc.timer <= 0 || game.wards <= 0) {
        resolveEncounterOutcome(false);
      }
    }
    function ensureContracts() {
      if (!researchFlag('unlockContracts')) return;
      if (!Array.isArray(game.contracts)) game.contracts = [];
      game.contracts = game.contracts.filter(c => !c.expired && !c.claimed);
      while (game.contracts.length < 2) {
        const canRelic = totalFloors() >= 45 && availableRelics().length > 0 && !(Array.isArray(game.relicDraft) && game.relicDraft.length > 0);
        const pool = CONTRACT_TEMPLATES.filter(t => {
          if (game.contracts.some(c => c.id === t.id)) return false;
          if (t.type === 'relicScout' && !canRelic) return false;
          return true;
        });
        if (pool.length === 0) break;
        const template = pool[Math.floor(Math.random() * pool.length)];
        game.contracts.push({
          ...template,
          progress: 0,
          accepted: false,
          complete: false,
          claimed: false,
          expiresAt: 0,
        });
      }
    }
    function acceptContract(idx) {
      const c = game.contracts[idx];
      if (!c || c.accepted) return;
      c.accepted = true;
      c.expiresAt = Date.now() + c.duration * 1000;
    }
    function claimContract(idx) {
      const c = game.contracts[idx];
      if (!c || !c.complete || c.claimed) return;
      c.claimed = true;
      const reward = c.reward || {};
      if (reward.gold) gainGold(reward.gold);
      if (reward.essence) {
        Object.keys(reward.essence).forEach(t => gainEssence(t, reward.essence[t]));
      }
      if (reward.relicDraft) {
        if (Array.isArray(game.relicDraft) && game.relicDraft.length > 0) {
          showToast('Relic Expedition', 'You already have a relic draft waiting.');
        } else {
          const choices = pickRelicChoices(3);
          if (choices.length === 0) {
            showToast('Relic Expedition', 'No relics remain this run.');
          } else {
            game.relicDraft = choices.map(r => r.id);
            game.relicDraftSeen = false;
            openRelicDraft();
          }
        }
      }
      showToast('Contract complete', 'Rewards delivered.');
    }
    function updateContracts(dt) {
      if (!Array.isArray(game.contracts)) return;
      const now = Date.now();
      game.contracts.forEach(c => {
        if (!c.accepted || c.complete || c.claimed) return;
        if (c.expiresAt && now > c.expiresAt) {
          c.expired = true;
          return;
        }
        if (c.type === 'wardHold') {
          const ratio = maxWards() > 0 ? (game.wards || 0) / maxWards() : 0;
          if (ratio >= 0.4) c.progress += dt;
          else c.progress = Math.max(0, c.progress - dt * 0.5);
          if (c.progress >= c.target) c.complete = true;
        }
      });
    }
    function onWaveCompleted(success) {
      if (!success || !Array.isArray(game.contracts)) return;
      const manaRatio = maxMana() > 0 ? (game.mana || 0) / maxMana() : 0;
      game.contracts.forEach(c => {
        if (!c.accepted || c.complete || c.claimed) return;
        if (c.type === 'waves') {
          c.progress += 1;
          if (c.progress >= c.target) c.complete = true;
        }
        if (c.type === 'manaLimit' && manaRatio <= 0.4) {
          c.progress += 1;
          if (c.progress >= c.target) c.complete = true;
        }
        if (c.type === 'relicScout') {
          c.progress += 1;
          if (c.progress >= c.target) c.complete = true;
        }
      });
    }
    function conduitMasteryMultiplier() {
      const lvl = game.passive.conduit || 0;
      if (lvl <= 0) return 1;
      const score = effectiveFollowerScore();
      return 1 + score * 0.001 * lvl;
    }
    function towerBondMultiplier() {
      const lvl = game.passive.towerBond || 0;
      if (lvl <= 0) return 1;
      return 1 + totalFloors() * 0.001 * lvl;
    }
    function leylineNexusMultiplier() {
      const lvl = countRooms('Leyline Nexus');
      if (lvl <= 0) return 1;
      return 1 + (game.passive.arcane || 0) * 0.01 * lvl;
    }
    function chronurgySwapReduction() {
      const lvl = countRooms('Chronurgy Chamber');
      return lvl * 0.10;
    }

    const floorCost = () => {
      const relicMult = 1 + (relicModifiers().floorCostMult || 0);
      return 50 * (totalFloors() + 1) * Math.max(0.2, relicMult);
    };
    function effectiveFloorCost() {
      let c = floorCost();
      if (game.nextFloorBonus) c = 0;
      else if (game.nextFloorCursed) c *= 1.5;
      const discount = game.nextFloorDiscountPct || 0;
      if (discount > 0) c *= (1 - discount);
      return c;
    }
    function effectiveFloorStaminaCost() {
      const base = maxStamina() * FLOOR_STAMINA_COST_PCT;
      const discount = game.nextFloorDiscountPct || 0;
      return base * (discount > 0 ? (1 - discount) : 1);
    }

    function countRooms(name) {
      if (name === 'Stairs') return game.stairs || 0;
      const sr = game.specialRooms || {};
      const r = sr[name];
      if (!r || !r.built) return 0;
      return r.level || 1;
    }
    function roomEffectSum(key) {
      let total = 0;
      SPECIAL_ROOM_NAMES.forEach(name => {
        const info = ROOMS[name];
        if (!info || !info[key]) return;
        const lvl = countRooms(name);
        if (lvl > 0) total += lvl * info[key];
      });
      return total;
    }
    function unlockedRoomNames() {
      return SPECIAL_ROOM_NAMES.filter(name => ROOMS[name] && ROOMS[name].unlock());
    }
    function ensureKeybinds() {
      if (!game.settings || typeof game.settings !== 'object') game.settings = { showTutorial: true, keybinds: {} };
      if (!game.settings.keybinds || typeof game.settings.keybinds !== 'object') game.settings.keybinds = {};
      Object.keys(KEYBIND_DEFAULTS).forEach(key => {
        if (!game.settings.keybinds[key]) game.settings.keybinds[key] = KEYBIND_DEFAULTS[key];
      });
      return game.settings.keybinds;
    }
    function formatKeyLabel(key) {
      if (!key) return '';
      if (key === 'esc') return 'Esc';
      return key.length === 1 ? key.toUpperCase() : key;
    }
    function renderKeybinds() {
      if (!keybindsList) return;
      const binds = ensureKeybinds();
      keybindsList.innerHTML = '';
      KEYBIND_ACTIONS.forEach(action => {
        const row = document.createElement('div');
        row.className = 'kb-row';
        const keyEl = document.createElement('span');
        keyEl.className = 'kb-key';
        keyEl.textContent = formatKeyLabel(binds[action.id]);
        const desc = document.createElement('span');
        desc.className = 'kb-desc';
        desc.textContent = action.label;
        const btn = document.createElement('button');
        btn.className = 'kb-rebind';
        btn.textContent = (awaitingRebind === action.id) ? 'Press key...' : 'Rebind';
        btn.disabled = awaitingRebind && awaitingRebind !== action.id;
        btn.onclick = () => {
          awaitingRebind = action.id;
          renderKeybinds();
        };
        row.appendChild(keyEl);
        row.appendChild(desc);
        row.appendChild(btn);
        keybindsList.appendChild(row);
      });
    }
    function relicModifiers() {
      const mods = {
        manaMult: 0,
        staminaRegenMult: 0,
        focusRegenMult: 0,
        focusIdleMult: 0,
        clickMult: 0,
        maxManaMult: 0,
        maxStaminaBonus: 0,
        maxFocusBonus: 0,
        fontRateMult: 0,
        spellEffectMult: 0,
        activeDurationMult: 0,
        floorCostMult: 0,
        upgradeCostMult: 0,
        windMult: 0,
        fireMult: 0,
        waterMult: 0,
        earthMult: 0,
      };
      const list = game.relics || [];
      list.forEach(id => {
        const relic = RELIC_BY_ID[id];
        if (!relic || !relic.mods) return;
        Object.keys(relic.mods).forEach(key => {
          mods[key] = (mods[key] || 0) + relic.mods[key];
        });
      });
      return mods;
    }
    function artifactModifiers() {
      const mods = { manaMult: 0, maxFocusBonus: 0, wardsMax: 0 };
      const claimed = new Set(game.milestonesClaimed || []);
      ARTIFACTS.forEach(a => {
        if (!claimed.has(a.id) || !a.mods) return;
        Object.keys(a.mods).forEach(key => {
          mods[key] = (mods[key] || 0) + a.mods[key];
        });
      });
      return mods;
    }
    function claimArtifact(id) {
      const art = ARTIFACTS.find(a => a.id === id);
      if (!art || !art.unlock(game)) return;
      if (!Array.isArray(game.milestonesClaimed)) game.milestonesClaimed = [];
      if (game.milestonesClaimed.includes(id)) return;
      game.milestonesClaimed.push(id);
      showToast('Artifact claimed', art.name + ' acquired.');
    }
    function relicMilestonesReached() {
      const floors = totalFloors();
      return RELIC_MILESTONES.filter(m => floors >= m).length;
    }
    function nextRelicMilestone() {
      const floors = totalFloors();
      return RELIC_MILESTONES.find(m => floors < m) || null;
    }
    function activeDurationMultiplier() {
      const roomBonus = roomEffectSum('activeDurationPct');
      const ritualBonus = (game.passive.ritualMastery || 0) * 0.05;
      const relicBonus = relicModifiers().activeDurationMult || 0;
      return 1 + roomBonus + ritualBonus + relicBonus;
    }
    function focusIdleMultiplier() {
      const roomBonus = roomEffectSum('focusIdlePct');
      const passiveBonus = (game.passive.focusFlow || 0) * -0.03;
      const relicBonus = relicModifiers().focusIdleMult || 0;
      return Math.max(0.35, 1 + roomBonus + passiveBonus + relicBonus);
    }
    function focusRegenMultiplier() {
      const roomBonus = roomEffectSum('focusPct');
      const passiveBonus = (game.passive.focusFlow || 0) * 0.05;
      const relicBonus = relicModifiers().focusRegenMult || 0;
      const school = schoolBonus('focusRegen') || 0;
      const challenge = challengePenalty('focusRegen') + completedChallengeBonus('focusRegen') + challengeReward('focusRegen');
      return 1 + roomBonus + passiveBonus + relicBonus + school + challenge;
    }
    function activeEffectMultiplier() {
      let mult = 1;
      if (game.active && game.active.convergenceTimer > 0) mult *= 2;
      if (game.active && game.active.comboTimer > 0) mult *= (game.active.comboMult || 1);
      return mult;
    }
    function ritualDurationMultiplier() {
      const anchored = (game.passive.anchoredRituals || 0) * 0.04;
      const school = schoolBonus('ritualDuration') || 0;
      const bonus = dailyBlessingBonus('ritualDuration') + completedChallengeBonus('ritualDuration');
      return activeDurationMultiplier() * (1 + anchored + school + bonus);
    }
    function ritualCostMultiplier() {
      const anchored = (game.passive.anchoredRituals || 0) * 0.02;
      const ritualAssist = assignmentCount('ritual') * 0.01;
      const schoolCost = schoolBonus('spellCost') || 0;
      const glyphCost = glyphBonus('spellCost') || 0;
      return Math.max(0.35, 1 - anchored - ritualAssist + schoolCost + glyphCost);
    }
    function ritualWindowInfo() {
      const now = Date.now();
      const offset = now % RITUAL_WINDOW_MS;
      const inWindow = offset <= RITUAL_WINDOW_DURATION_MS;
      const remaining = inWindow ? (RITUAL_WINDOW_DURATION_MS - offset) : (RITUAL_WINDOW_MS - offset);
      return { inWindow, remaining };
    }
    function ritualWindowMultiplier() {
      const info = ritualWindowInfo();
      if (!info.inWindow) return 1;
      const researchBonus = researchEffect('ritualWindow') || 0;
      return 1.2 + researchBonus;
    }
    function currentSpellCostDiscount() {
      if (game.active && game.active.spellCostDiscountTimer > 0) return game.active.spellCostDiscountPct || 0;
      return 0;
    }
    function activeCooldownCount() {
      const now = Date.now();
      let count = 0;
      if (game.active && game.active.cooldown > 0) count++;
      const seen = new Set();
      if (typeof ACTIVE_SPELLS !== 'undefined') {
        ACTIVE_SPELLS.forEach(s => {
          if (!s.cooldownKey) return;
          if (seen.has(s.cooldownKey)) return;
          seen.add(s.cooldownKey);
          if ((game[s.cooldownKey] || 0) > now) count++;
        });
      }
      return count;
    }
    function maxSpellSlots() {
      let slots = 1;
      SPECIAL_ROOM_NAMES.forEach(name => {
        const info = ROOMS[name];
        if (info && (info.extraSpellSlots || 0) > 0) {
          const lvl = countRooms(name);
          slots += lvl * (info.extraSpellSlots || 0);
        }
      });
      return slots;
    }
    function getSpellId(s, isActive) {
      if (isActive && s.id) return s.id;
      if (!isActive && s.key) return s.key;
      return (s.name || '').replace(/\s+/g, '').toLowerCase();
    }
    function isMemorized(spellId) {
      const list = game.memorizedSpells || [];
      return Array.isArray(list) && list.includes(spellId);
    }
    function hasAchievement(id) {
      return (game.stats && Array.isArray(game.stats.achievements)) ? game.stats.achievements.includes(id) : false;
    }
    function isSpellUnlocked(spell, isActive) {
      if (typeof spell.unlockCheck === 'function') return spell.unlockCheck();
      const floors = totalFloors();
      return floors >= (spell.unlock || 0);
    }
    function spellUnlockHint(spell) {
      if (typeof spell.unlockText === 'function') return spell.unlockText();
      if (typeof spell.unlock === 'number') return 'Unlocks at ' + spell.unlock + ' floors';
      return 'Unlock condition not met';
    }
    function spellSwapFocusCost() {
      const focus = game.focus || 0;
      if (focus <= 0) return 0;
      const base = focus * 0.5;
      const mult = game.ritualOfBindingNextSwapHalved ? 0.5 : 1;
      return Math.max(0, base * mult);
    }
    function canSwapSpell() {
      const cost = spellSwapFocusCost();
      return (game.focus || 0) >= cost && cost > 0;
    }
    function spellSwapCooldownRemaining() {
      return 0;
    }
    function forgetSpell(spellId) {
      const cost = spellSwapFocusCost();
      if (!canSwapSpell()) return;
      const list = (game.memorizedSpells || []).filter(id => id !== spellId);
      game.memorizedSpells = list;
      trySpendFocus(cost);
      if (game.ritualOfBindingNextSwapHalved) game.ritualOfBindingNextSwapHalved = false;
      renderAll();
    }
    function memorizeSpell(spellId) {
      const cost = spellSwapFocusCost();
      if (!canSwapSpell()) return;
      const list = game.memorizedSpells || [];
      if (list.length >= maxSpellSlots()) return;
      if (list.includes(spellId)) return;
      game.memorizedSpells = [...list, spellId];
      trySpendFocus(cost);
      if (game.ritualOfBindingNextSwapHalved) game.ritualOfBindingNextSwapHalved = false;
      renderAll();
    }

    function upgradeCost(roomName) {
      const r = (game.specialRooms || {})[roomName];
      const level = (r && r.built && r.level) ? r.level : 1;
      const base = UPGRADE_COST_BASE * Math.pow(1.5, level - 1);
      const roomDiscount = roomEffectSum('upgradeCostPct');
      const relicDiscount = relicModifiers().upgradeCostMult || 0;
      const mult = Math.max(0.2, 1 + roomDiscount + relicDiscount);
      return base * mult;
    }

    function manaReservoirLevel() {
      return (game.research && game.research.levels && game.research.levels.manaReservoir) || game.studyCount || 0;
    }
    function spellEtchingLevel() {
      return (game.research && game.research.levels && game.research.levels.spellEtching) || Math.round(game.transcribeBonusPct || 0);
    }
    function spellEffectMultiplier() {
      const base = 1 + game.passive.arcane * 0.15;
      const libraryLevel = countRooms('Library');
      let mult = base * (1 + libraryLevel * LIBRARY_LEYLINE_PCT);
      SPECIAL_ROOM_NAMES.forEach(name => {
        if (name === 'Library') return;
        const info = ROOMS[name];
        if (!info.spellPct) return;
        const lvl = countRooms(name);
        mult *= (1 + lvl * info.spellPct);
      });
      mult *= (1 + spellEtchingLevel() / 100);
      mult *= (1 + (relicModifiers().spellEffectMult || 0));
      mult *= paragonSpellEffectMultiplier();
      mult *= 1 + followerSpellEffectBonus();
      mult *= 1 + schoolBonus('spellEffect');
      mult *= 1 + glyphBonus('spellEffect');
      mult *= 1 + dailyBlessingBonus('spellEffect');
      mult *= 1 + challengeReward('spellEffect') + completedChallengeBonus('spellEffect');
      if (game.active && game.active.overchargeTimer > 0) {
        mult *= (game.active.overchargeMult || (1.2 + schoolBonus('overcharge')));
      }
      if ((game.runeEtchingBuffEnd || 0) > Date.now()) mult *= 1.1;
      return mult;
    }
    function elementalSpellMultiplier(element) {
      const mods = relicModifiers();
      let mult = 1;
      if (element === 'wind') mult *= 1 + (mods.windMult || 0);
      if (element === 'fire') mult *= 1 + (mods.fireMult || 0);
      if (element === 'water') mult *= 1 + (mods.waterMult || 0);
      if (element === 'earth') mult *= 1 + (mods.earthMult || 0);
      return mult;
    }
    function milestoneManaMultiplier() {
      const ever = game.stats.totalFloorsEver || 0;
      let mult = 1;
      if (ever >= 200) mult += 0.01;
      if (ever >= 500) mult += 0.01;
      if (ever >= 1000) mult += 0.02;
      return mult;
    }
    function paragonManaMultiplier() {
      const s = game.paragonSpent || {};
      return 1 + (s.manaPct || 0) * 0.005;
    }
    function paragonSpellEffectMultiplier() {
      const s = game.paragonSpent || {};
      return 1 + (s.spellEffect || 0) * 0.01;
    }

    function astralManaMultiplier() {
      const obsLevel = countRooms('Observatory');
      const pct = (ROOMS.Observatory && ROOMS.Observatory.astralPct) ? ROOMS.Observatory.astralPct : 0.10;
      return 1 + game.passive.astral * pct * obsLevel;
    }

    function maxMana() {
      const base = BASE_MANA_MAX * Math.pow(1.07, manaReservoirLevel());
      const roomBonus = 1 + roomEffectSum('manaCapPct');
      const passiveBonus = 1 + (game.passive.manaReservoir || 0) * 0.04;
      const relicBonus = 1 + (relicModifiers().maxManaMult || 0);
      const worldweave = (game.active && game.active.worldweaveTimer > 0) ? 2 : 1;
      const followerBonus = 1 + followerManaBonusPct();
      return base * roomBonus * passiveBonus * relicBonus * worldweave * followerBonus;
    }

    function capMana() {
      const cap = maxMana();
      if (game.mana > cap) game.mana = cap;
    }

    function maxWards() {
      const effects = outpostEffects();
      const bonus = (effects.wardsMax || 0) + staffEffect('wardsMax') + researchEffect('wardsMax') + (artifactModifiers().wardsMax || 0);
      const base = WARDS_BASE + bonus;
      const mult = 1 + schoolBonus('wardsMax') + challengePenalty('wardsMax') + completedChallengeBonus('wardsMax') + challengeReward('wardsMax');
      return Math.max(20, base * mult);
    }
    function wardsRegenPerSecond() {
      const effects = outpostEffects();
      let regen = WARDS_REGEN_BASE + (effects.wardsRegen || 0) + staffEffect('wardsRegen');
      regen *= 1 + glyphBonus('wardsRegen') + dailyBlessingBonus('wardsRegen') + completedChallengeBonus('wardsRegen') + challengeReward('wardsRegen');
      return Math.max(0, regen);
    }
    function capWards() {
      const cap = maxWards();
      if ((game.wards || 0) > cap) game.wards = cap;
    }

    function maxStamina() {
      const well = (game.passive.staminaWell || 0) * 5;
      const paragon = (game.paragonSpent && game.paragonSpent.stamina) ? game.paragonSpent.stamina * 5 : 0;
      const relicBonus = relicModifiers().maxStaminaBonus || 0;
      const worldweave = (game.active && game.active.worldweaveTimer > 0) ? 2 : 1;
      return (BASE_STAMINA_MAX + well + paragon + relicBonus) * worldweave;
    }

    function staminaRoomBonusMult() {
      let raw = 0;
      SPECIAL_ROOM_NAMES.forEach(name => {
        const info = ROOMS[name];
        if (!info.staminaPct) return;
        const lvl = countRooms(name);
        raw += lvl * info.staminaPct;
      });
      return 1 + Math.min(raw, STAMINA_ROOM_BONUS_CAP);
    }

    function towerStrainStaminaMult() {
      const tf = totalFloors();
      if (tf < TOWER_STRAIN_FLOOR) return 1;
      const over = tf - TOWER_STRAIN_FLOOR;
      const pct = Math.floor(over / 10) * TOWER_STRAIN_PCT_PER_10;
      return Math.max(0.2, 1 - pct);
    }

    function staminaPerSecond() {
      const roomMult = staminaRoomBonusMult();
      const wellRegen = (game.passive.staminaWell || 0) * 0.01;
      const meditateBonus = Math.min(game.meditateStacks || 0, MEDITATE_CAP) * MEDITATE_PCT_PER_STACK;
      let mult = roomMult - 1 + wellRegen + meditateBonus + 1;
      const base = STAMINA_REGEN_BASE * mult;
      const boostTD = (game.active && game.active.boostTD) ? game.active.boostTD : 1;
      const boostHarvest = (game.active && game.active.boostHarvest) ? game.active.boostHarvest : 1;
      let sps = base * boostTD * boostHarvest;
      if (game.ritualBuffEnd && game.ritualBuffEnd > Date.now()) sps *= 2;
      if (game.ritualWindowBonusEnd && game.ritualWindowBonusEnd > Date.now()) sps *= 1 + (game.ritualWindowBonusPct || 0);
      sps *= towerStrainStaminaMult();
      if ((game.exhaustedUntil || 0) > Date.now()) sps *= 0.5;
      sps *= (1 + (relicModifiers().staminaRegenMult || 0));
      sps *= 1 + schoolBonus('staminaRegen');
      return Math.min(sps, STAMINA_REGEN_CAP);
    }

    function maxFocus() {
      const paragon = (game.paragonSpent && game.paragonSpent.focus) ? game.paragonSpent.focus * 5 : 0;
      const relicBonus = relicModifiers().maxFocusBonus || 0;
      const artifactBonus = artifactModifiers().maxFocusBonus || 0;
      const worldweave = (game.active && game.active.worldweaveTimer > 0) ? 2 : 1;
      return (BASE_FOCUS_MAX + paragon + relicBonus + artifactBonus) * worldweave;
    }

    function focusIdleSeconds() {
      return (Date.now() - (game.lastActivityOrSpellAt || 0)) / 1000;
    }

    function isRestingForFocus() {
      return focusIdleSeconds() >= FOCUS_IDLE_SEC * focusIdleMultiplier();
    }

    function focusPerSecond() {
      if (!isRestingForFocus()) return 0;
      const condenser = (game.active && game.active.focusCondenserTimer > 0) ? 1.5 : 1;
      return FOCUS_REGEN_BASE * focusRegenMultiplier() * condenser;
    }

    function trySpendFocus(amount) {
      if (!amount || amount <= 0) return true;
      const f = game.focus || 0;
      if (f < amount) return false;
      game.focus = f - amount;
      return true;
    }

    function recordActivityOrSpell() {
      game.lastActivityOrSpellAt = Date.now();
    }

    function capFocus() {
      const cap = maxFocus();
      if ((game.focus || 0) > cap) game.focus = cap;
    }

    function setExhausted() {
      game.exhaustedUntil = Date.now() + EXHAUSTED_DURATION_MS;
    }

    function capStamina() {
      const cap = maxStamina();
      if (game.stamina > cap) game.stamina = cap;
    }

    function ensureExpandedDefaults() {
      if (!game.essence || typeof game.essence !== 'object') game.essence = initialEssence();
      ESSENCE_TYPES.forEach(t => { if (typeof game.essence[t] !== 'number') game.essence[t] = 0; });
      if (!game.followers || typeof game.followers !== 'object') game.followers = initialFollowers();
      if (typeof game.followers.novice !== 'number') game.followers.novice = 0;
      if (typeof game.followers.acolyte !== 'number') game.followers.acolyte = 0;
      if (typeof game.followers.sage !== 'number') game.followers.sage = 0;
      if (typeof game.reputation !== 'number') game.reputation = 0;
      if (typeof game.gold !== 'number') game.gold = 0;
      if (typeof game.wards !== 'number') game.wards = WARDS_BASE;
      if (typeof game.speed !== 'number') game.speed = 1;
      if (!game.followerAssignments || typeof game.followerAssignments !== 'object') game.followerAssignments = initialFollowerAssignments();
      ['market', 'research', 'ritual', 'scouting'].forEach(k => {
        if (typeof game.followerAssignments[k] !== 'number') game.followerAssignments[k] = 0;
      });
      if (typeof game.followerProgress !== 'number') game.followerProgress = 0;
      if (!game.promotionProgress || typeof game.promotionProgress !== 'object') game.promotionProgress = { novice: 0, acolyte: 0 };
      if (typeof game.promotionProgress.novice !== 'number') game.promotionProgress.novice = 0;
      if (typeof game.promotionProgress.acolyte !== 'number') game.promotionProgress.acolyte = 0;
      if (typeof game.scoutingProgress !== 'number') game.scoutingProgress = 0;
      if (!Array.isArray(game.academyOutposts)) game.academyOutposts = initialAcademyOutposts();
      if (game.academyOutposts.length < MAX_OUTPOSTS) {
        const missing = MAX_OUTPOSTS - game.academyOutposts.length;
        for (let i = 0; i < missing; i++) game.academyOutposts.push({ built: false, role: null, level: 0, modules: [], links: { left: false, right: false } });
      }
      if (!game.academyStaff || typeof game.academyStaff !== 'object') game.academyStaff = initialAcademyStaff();
      if (!game.research || typeof game.research !== 'object') game.research = initialResearchState();
      if (!Array.isArray(game.research.unlocked)) game.research.unlocked = [];
      if (typeof game.research.points !== 'number') game.research.points = 0;
      if (!game.research.levels || typeof game.research.levels !== 'object') game.research.levels = {};
      if (typeof game.research.levels.manaReservoir !== 'number') game.research.levels.manaReservoir = 0;
      if (typeof game.research.levels.spellEtching !== 'number') game.research.levels.spellEtching = 0;
      if ((game.studyCount || 0) > 0 && game.research.levels.manaReservoir === 0) {
        game.research.levels.manaReservoir = game.studyCount;
      }
      if ((game.transcribeBonusPct || 0) > 0 && game.research.levels.spellEtching === 0) {
        game.research.levels.spellEtching = Math.round(game.transcribeBonusPct || 0);
      }
      if (!game.modules || typeof game.modules !== 'object') game.modules = {};
      if (!game.schools || typeof game.schools !== 'object') game.schools = { primary: null, secondary: null, slots: 1 };
      if (typeof game.schools.slots !== 'number') game.schools.slots = 1;
      if (!game.glyphs || typeof game.glyphs !== 'object') game.glyphs = { active: null };
      if (!game.challenge || typeof game.challenge !== 'object') game.challenge = { active: null, completed: [], tokens: 0 };
      if (!Array.isArray(game.challenge.completed)) game.challenge.completed = [];
      if (typeof game.challenge.tokens !== 'number') game.challenge.tokens = 0;
      if (!game.encounter || typeof game.encounter !== 'object') game.encounter = initialEncounterState();
      if (typeof game.encounter.threat !== 'number') game.encounter.threat = 0;
      if (!Array.isArray(game.contracts)) game.contracts = [];
      if (!Array.isArray(game.milestonesClaimed)) game.milestonesClaimed = [];
      if (!Array.isArray(game.storySeen)) game.storySeen = [];
      if (!game.dailyBlessing || typeof game.dailyBlessing !== 'object') game.dailyBlessing = { id: null, bonus: null, lastAt: 0, nextAt: 0 };
      if (typeof game.dailyBlessing.lastAt !== 'number') game.dailyBlessing.lastAt = 0;
      if (typeof game.dailyBlessing.nextAt !== 'number') game.dailyBlessing.nextAt = 0;
      if (!game.runeEtching || typeof game.runeEtching !== 'object') game.runeEtching = { date: null, pattern: [], selected: [], solvedAt: 0, attempts: 0 };
      if (typeof game.runeEtchingBuffEnd !== 'number') game.runeEtchingBuffEnd = 0;
      if (!game.cosmetics || typeof game.cosmetics !== 'object') game.cosmetics = { unlocked: [], active: null };
      if (!game.spellSynergy || typeof game.spellSynergy !== 'object') game.spellSynergy = { lastElement: null, lastCastAt: 0, chain: [] };
      if (typeof game.nextFollowerEventAt !== 'number') game.nextFollowerEventAt = 0;
      if (typeof game.followerEvent === 'undefined') game.followerEvent = null;
      if (typeof game.ritualWindowBonusPct !== 'number') game.ritualWindowBonusPct = 0;
      if (typeof game.ritualWindowBonusEnd !== 'number') game.ritualWindowBonusEnd = 0;
      if (!Array.isArray(game.nextFloorOffers) && game.nextFloorOffers !== null) game.nextFloorOffers = null;
      if (typeof game.nextFloorRolled !== 'boolean') game.nextFloorRolled = false;
      if (game.active) {
        if (typeof game.active.overchargeTimer !== 'number') game.active.overchargeTimer = 0;
        if (typeof game.active.overchargeMult !== 'number') game.active.overchargeMult = 1;
        if (typeof game.active.concessionTimer !== 'number') game.active.concessionTimer = 0;
        if (typeof game.active.comboTimer !== 'number') game.active.comboTimer = 0;
        if (typeof game.active.comboMult !== 'number') game.active.comboMult = 1;
        if (typeof game.active.overchargeCharge !== 'number') game.active.overchargeCharge = 0;
        if (typeof game.active.flameSurgeTimer !== 'number') game.active.flameSurgeTimer = 0;
        if (typeof game.active.frostSlowTimer !== 'number') game.active.frostSlowTimer = 0;
      }
    }

    function timeDilationCost(casts) {
      let cost = 5;
      const spellMult = spellEffectMultiplier();
      const growthFactor = 1 + 0.07 * spellMult;
      for (let i = 0; i < casts; i++) cost = (cost + 1) * growthFactor;
      return cost;
    }
    function scaledSpellManaCost(baseCost) {
      const poolScale = maxMana() * 0.02;
      return Math.max(0, baseCost + poolScale);
    }
    function studyFocusCost() {
      const base = 1 * Math.pow(1.05, manaReservoirLevel());
      return Math.max(1, base);
    }

    function manaPerSecond() {
      const floors = totalFloors();
      const followerBase = effectiveFollowerScore() * FOLLOWER_MPS_RATE;
      let m = followerBase * (1 + floors * FLOOR_BONUS);
      const vaultLevel = countRooms('Vault');
      m *= Math.min(1 + vaultLevel * 0.05, 1 + VAULT_CAP);
      m *= (1 + (game.stairs || 0) * STAIRS_MANA_PCT);
      SPECIAL_ROOM_NAMES.forEach(name => {
        if (name === 'Vault') return;
        const info = ROOMS[name];
        if (!info.manaPct) return;
        const lvl = countRooms(name);
        m *= (1 + lvl * info.manaPct);
      });
      const relicRoomPct = roomEffectSum('relicManaPct') * (game.relics || []).length;
      if (relicRoomPct > 0) m *= (1 + relicRoomPct);
      m *= astralManaMultiplier();
      m *= conduitMasteryMultiplier();
      m *= towerBondMultiplier();
      m *= leylineNexusMultiplier();
      if (game.active && game.active.runeStacks > 0) m *= (1 + game.active.runeStacks * 0.01);
      const boostTD = (game.active && game.active.boostTD) ? game.active.boostTD : 1;
      const boostHarvest = (game.active && game.active.boostHarvest) ? game.active.boostHarvest : 1;
      m *= boostTD * boostHarvest;
      if (game.active && game.active.leylineTapTimer > 0) m *= (1 + (game.active.leylineTapPct || 0));
      if (game.active && game.active.focusCondenserTimer > 0) m *= 0.8;
      if (game.active && game.active.overclockTimer > 0) m *= (game.active.overclockMult || 5);
      if (game.active && game.active.flameSurgeTimer > 0) m *= 1.15;
      if (game.active && game.active.paradoxTimer > 0) m *= (2 / 3);
      if (game.ritualBuffEnd && game.ritualBuffEnd > Date.now()) m *= 2;
      const aetherLvl = game.passive.aetherFlux || 0;
      if (aetherLvl > 0) {
        const cdCount = activeCooldownCount();
        if (cdCount > 0) m *= (1 + cdCount * aetherLvl * 0.008);
      }
      m *= 1 + game.ascension * ASCENSION_BONUS_PER;
      const asc2 = (game.ascensionTier2 || 0) * ASCENSION_2_BONUS_PER;
      m *= 1 + asc2;
      m *= achievementManaMultiplier();
      m *= milestoneManaMultiplier();
      m *= paragonManaMultiplier();
      m *= (1 + (relicModifiers().manaMult || 0) + (artifactModifiers().manaMult || 0));
      m *= 1 + (outpostEffects().manaMult || 0);
      m *= 1 + schoolBonus('manaMult');
      m *= 1 + glyphBonus('manaMult');
      m *= 1 + dailyBlessingBonus('manaMult');
      m *= 1 + challengePenalty('manaMult') + completedChallengeBonus('manaMult');
      if (game.active && game.active.concessionTimer > 0) m *= 0.94;
      if (game.ritualWindowBonusEnd && game.ritualWindowBonusEnd > Date.now()) m *= 1 + (game.ritualWindowBonusPct || 0);
      if (game.active && game.active.overchargeTimer > 0) {
        const boost = (game.active.overchargeMult || 1) - 1;
        m *= 1 + boost * 0.3;
      }
      m = Math.max(0.05, m);
      return m;
    }

    // -------------------- ACHIEVEMENTS --------------------
    const ACHIEVEMENTS = [
      { id: 'first_10_floors', name: 'First Steps', desc: 'Reach 10 floors', check: g => totalFloorsFromGame(g) >= 10, reward: '+1% mana/sec' },
      { id: 'first_25', name: 'Tower Rising', desc: 'Reach 25 floors', check: g => totalFloorsFromGame(g) >= 25, reward: '+2% mana/sec' },
      { id: 'first_50', name: 'Half Century', desc: 'Reach 50 floors', check: g => totalFloorsFromGame(g) >= 50, reward: '+3% mana/sec' },
      { id: 'first_100', name: 'Century', desc: 'Reach 100 floors', check: g => totalFloorsFromGame(g) >= 100, reward: '+5% mana/sec' },
      { id: 'first_150', name: 'Spire', desc: 'Reach 150 floors', check: g => totalFloorsFromGame(g) >= 150, reward: '+1% mana/sec' },
      { id: 'first_200', name: 'Pinnacle', desc: 'Reach 200 floors', check: g => totalFloorsFromGame(g) >= 200, reward: '+1% mana/sec' },
      { id: 'first_250', name: 'Summit', desc: 'Reach 250 floors', check: g => totalFloorsFromGame(g) >= 250, reward: '+2% mana/sec' },
      { id: 'time_dilation_1', name: 'Time Walker', desc: 'Cast Time Dilation once', check: g => (g.stats && g.stats.timeDilationCasts) >= 1, reward: null },
      { id: 'arcane_harvest_10', name: 'Harvester', desc: 'Cast Arcane Harvest 10 times', check: g => (g.stats && g.stats.arcaneHarvestCasts) >= 10, reward: '+1% mana/sec' },
      { id: 'study_1', name: 'Scholar', desc: 'Research Mana Reservoir once', check: () => manaReservoirLevel() >= 1, reward: null },
      { id: 'study_25', name: 'Sage', desc: 'Research Mana Reservoir 25 times', check: () => manaReservoirLevel() >= 25, reward: '+1% mana/sec' },
      { id: 'ascend_1', name: 'Ascendant', desc: 'Ascend once', check: g => (g.ascension + (g.ascensionTier2 || 0)) >= 1, reward: null },
      { id: 'ascend_3', name: 'Transcendent', desc: 'Ascend 3 times', check: g => (g.ascension + (g.ascensionTier2 || 0)) >= 3, reward: '+1% mana/sec' },
      { id: 'ascend_5', name: 'Eternal', desc: 'Ascend 5 times', check: g => (g.ascension + (g.ascensionTier2 || 0)) >= 5, reward: '+1% mana/sec' },
      { id: 'stamina_1000', name: 'Dedicated', desc: 'Spend 1000 total stamina on activities', check: g => (g.stats && g.stats.totalStaminaSpent) >= 1000, reward: '+1% mana/sec' },
      { id: 'rooms_10', name: 'Diverse', desc: 'Build 10 different room types', check: g => { const sr = g.specialRooms || {}; return SPECIAL_ROOM_NAMES.filter(n => sr[n] && sr[n].built).length >= 10; }, reward: '+1% mana/sec' },
      { id: 'upgrade_5', name: 'Investor', desc: 'Upgrade 5 rooms to level 2+', check: g => { const sr = g.specialRooms || {}; return SPECIAL_ROOM_NAMES.filter(n => sr[n] && sr[n].built && (sr[n].level || 1) >= 2).length >= 5; }, reward: null },
      { id: 'trial_no_arcanum_50', name: 'Pure Tower', desc: 'Reach 50 floors without building Arcanum', check: g => totalFloorsFromGame(g) >= 50 && !(g.specialRooms && g.specialRooms.Arcanum && g.specialRooms.Arcanum.built), reward: '+2% mana/sec' },
      { id: 'relic_1', name: 'Curiosity', desc: 'Claim 1 relic', check: g => (g.relics || []).length >= 1, reward: '+1% mana/sec' },
      { id: 'relic_4', name: 'Collector', desc: 'Claim 4 relics in a run', check: g => (g.relics || []).length >= 4, reward: '+2% mana/sec' },
      { id: 'relic_7', name: 'Vaulted', desc: 'Claim 7 relics in a run', check: g => (g.relics || []).length >= 7, reward: '+2% mana/sec' },
      { id: 'sigil_5', name: 'Rune Smith', desc: 'Forge 5 Sigils', check: g => (g.sigilStacks || 0) >= 5, reward: '+1% mana/sec' },
      { id: 'focus_surge_10', name: 'Mind Lance', desc: 'Cast Focus Surge 10 times', check: g => (g.stats && g.stats.focusSurgeCasts) >= 10, reward: '+1% mana/sec' },
      { id: 'first_300', name: 'Skyreach', desc: 'Reach 300 floors', check: g => totalFloorsFromGame(g) >= 300, reward: '+2% mana/sec' },
      { id: 'loop_master', name: 'Perfecting the Loop', desc: 'Cast 500 spells and reach 200 floors', check: g => (g.stats && g.stats.totalSpellsCast) >= 500 && totalFloorsFromGame(g) >= 200, reward: null },
      { id: 'overcharger', name: 'Overcharger', desc: 'Reach mana cap 50 times', check: g => (g.stats && g.stats.manaCapHits) >= 50, reward: null },
      { id: 'architect_nexus', name: 'Architect of the Nexus', desc: 'Build 1 of every room type', check: g => { const sr = g.specialRooms || {}; return SPECIAL_ROOM_NAMES.every(n => sr[n] && sr[n].built); }, reward: null },
      { id: 'master_grimoire', name: 'Master of the Grimoire', desc: 'Memorize 6 spells at once', check: g => (g.memorizedSpells || []).length >= 6, reward: null },
      { id: 'in_the_red', name: 'In the Red', desc: 'Cast a spell at 0 mana', check: g => (g.stats && g.stats.zeroManaCasts) >= 1, reward: null },
    ];

    function achievementManaMultiplier() {
      let mult = 1;
      ACHIEVEMENTS.forEach(a => {
        if (!a.reward || !(game.stats.achievements || []).includes(a.id)) return;
        const m = a.reward.match(/\+(\d+)%/);
        if (m) mult += Number(m[1]) / 100;
      });
      return mult;
    }

    function checkAchievements() {
      const list = game.stats.achievements || [];
      ACHIEVEMENTS.forEach(a => {
        if (list.includes(a.id)) return;
        if (a.check(game)) {
          game.stats.achievements = [...list, a.id];
          showToast(a.name, a.desc + (a.reward ? '  ' + a.reward : ''));
          playSound('milestone');
        }
      });
    }

    function showToast(title, body) {
      const el = document.createElement('div');
      el.className = 'toast';
      el.innerHTML = '<div class="toast-title">' + title + '</div>' + (body ? body : '');
      toastContainer.appendChild(el);
      setTimeout(() => el.remove(), 3500);
    }

    // -------------------- SOUND --------------------
    let audioCtx = null;
    function playSound(type) {
      if (!game.soundEnabled) return;
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        gain.gain.value = 0.1;
        if (type === 'click') { osc.frequency.value = 400; osc.type = 'sine'; }
        else if (type === 'spell') { osc.frequency.value = 600; osc.type = 'sine'; }
        else { osc.frequency.value = 800; osc.type = 'sine'; }
        osc.start(audioCtx.currentTime);
        osc.stop(audioCtx.currentTime + 0.05);
      } catch (_) {}
    }

    // -------------------- CLICK MANA --------------------
    function clickManaGain() {
      // small, gentle scaling so clicking stays fun without breaking balance
      const f = totalFloors();
      const fonts = game.manaFonts || 0;
      const base = 1 + Math.floor(f / 12);
      const sigilStacks = Math.min(game.sigilStacks || 0, SIGIL_STACK_CAP);
      const sigilMult = 1 + sigilStacks * SIGIL_STACK_PCT;
      const fontMult = sigilMult * (1 + roomEffectSum('fontPct')) * (1 + (relicModifiers().fontRateMult || 0));
      const fontBonus = fonts * MANA_FONT_RATE * fontMult;
      const relicMult = 1 + (relicModifiers().clickMult || 0);
      let amount = (base + fontBonus) * relicMult;
      let crit = false;
      const luckyLvl = game.passive.luckyClick || 0;
      if (luckyLvl > 0) {
        const chance = Math.min(0.25, 0.05 * luckyLvl);
        if (Math.random() < chance) {
          amount += amount * 5;
          crit = true;
        }
      }
      return { amount, crit };
    }
    function centerClick(e) {
      if (!game.tutorial || typeof game.tutorial !== 'object') game.tutorial = { clicked: false, done: false, completedToast: false, settingsOpened: false, keysSeen: false, glossarySeen: false, libraryOpened: false, observatoryOpened: false, towerOpened: false, activitiesOpened: false };
      game.tutorial.clicked = true;
      recordActivityOrSpell();
      if (game.active && game.active.runeTimer > 0) game.active.runeStacks = (game.active.runeStacks || 0) + 1;
      const g = clickManaGain();
      game.mana = Math.min(game.mana + g.amount, maxMana());
      game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + g.amount;
      playSound('click');
      const rect = towerContainer.getBoundingClientRect();
      const el = document.createElement('div');
      el.className = 'boost-number' + (g.crit ? ' crit' : '');
      el.textContent = '+' + formatNum(g.amount);
      el.style.left = (e.clientX - rect.left - 10) + 'px';
      el.style.top = (e.clientY - rect.top - 20) + 'px';
      towerContainer.appendChild(el);
      el.addEventListener('animationend', () => el.remove());

      const ripple = document.createElement('div');
      ripple.className = 'click-ripple';
      ripple.style.left = (e.clientX - rect.left) + 'px';
      ripple.style.top = (e.clientY - rect.top) + 'px';
      towerContainer.appendChild(ripple);
      ripple.addEventListener('animationend', () => ripple.remove());
    }
    document.getElementById('main').addEventListener('click', centerClick);

    // -------------------- SPELL COST (Spell Echo + Attune) --------------------
    function trySpendManaForSpell(baseCost) {
      const discount = (game.attuneDiscount || 0) + currentSpellCostDiscount();
      const scaledCost = baseCost > 0 ? scaledSpellManaCost(baseCost) : 0;
      const costMult = Math.max(0.2, 1 + schoolBonus('spellCost') + glyphBonus('spellCost'));
      const actualCost = Math.max(0, scaledCost * costMult * (1 - Math.min(0.9, discount)));
      const echoLvl = game.passive.spellEcho || 0;
      const now = Date.now();
      if (echoLvl > 0 && (game.spellEchoNextFreeAt || 0) <= now) {
        game.spellEchoNextFreeAt = now + SPELL_ECHO_FREE_COOLDOWN_MS;
        game.attuneDiscount = 0;
        if ((game.mana || 0) <= 0) game.stats.zeroManaCasts = (game.stats.zeroManaCasts || 0) + 1;
        return true;
      }
      if (game.mana < actualCost) return false;
      if ((game.mana || 0) <= 0 && actualCost <= 0) game.stats.zeroManaCasts = (game.stats.zeroManaCasts || 0) + 1;
      game.mana -= actualCost;
      game.attuneDiscount = 0;
      return true;
    }

    function registerSpellElement(element) {
      if (!element) return;
      if (!game.spellSynergy || typeof game.spellSynergy !== 'object') game.spellSynergy = { lastElement: null, lastCastAt: 0, chain: [] };
      const now = Date.now();
      const lastAt = game.spellSynergy.lastCastAt || 0;
      if (now - lastAt > 8000) game.spellSynergy.lastElement = null;
      const last = game.spellSynergy.lastElement;
      let combo = null;
      if (last === 'water' && element === 'wind') combo = 'tempest';
      if (last === 'fire' && element === 'water') combo = 'steam';
      if (last === 'wind' && element === 'fire') combo = 'stormflare';
      if (combo) triggerSpellCombo(combo);
      game.spellSynergy.lastElement = element;
      game.spellSynergy.lastCastAt = now;
    }
    function triggerSpellCombo(combo) {
      if (combo === 'tempest') {
        if (game.encounter && game.encounter.active) {
          game.encounter.hp = Math.max(0, game.encounter.hp - game.encounter.maxHp * 0.12);
        } else {
          const gain = manaPerSecond() * 3;
          game.mana = Math.min((game.mana || 0) + gain, maxMana());
          game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + gain;
        }
        showToast('Combo: Tempest Burst', 'Water and wind collide.');
      }
      if (combo === 'steam') {
        game.active.comboTimer = 12;
        game.active.comboMult = 1.18;
        showToast('Combo: Steam Shock', '+18% spell power for 12s.');
      }
      if (combo === 'stormflare') {
        const focusGain = 12;
        game.focus = Math.min((game.focus || 0) + focusGain, maxFocus());
        gainEssence('wind', 2);
        showToast('Combo: Stormflare', '+12 focus and wind essence.');
      }
    }

    // -------------------- ACTIVE SPELLS --------------------
    const SPELL_SWAP_COOLDOWN_MS = 10 * 60 * 1000; // 10 minutes
    const ACTIVE_SPELLS = [
      {
        id: 'transmutate',
        name: 'Transmutate',
        unlock: 0,
        desc: 'Convert mana into stamina.',
        cooldownMs: 6000,
        cooldownKey: 'transmutateCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.transmutateCooldownEnd || 0) > now) return;
          const mana = game.mana || 0;
          if (mana <= 0) return;
          const casts = game.stats.transmutateCasts || 0;
          const fraction = Math.min(1, 0.30 * (1 + casts * 0.05));
          const efficiency = Math.max(0.4, 1 - casts * 0.05);
          const staminaRoom = maxStamina() - (game.stamina || 0);
          if (staminaRoom <= 0) return;
          const maxSpendForStamina = staminaRoom * 3;
          const manaSpend = Math.min(mana * fraction, maxSpendForStamina);
          if (manaSpend <= 0) return;
          game.mana -= manaSpend;
          game.stamina = Math.min((game.stamina || 0) + (manaSpend / 3) * efficiency, maxStamina());
          recordActivityOrSpell();
          game.stats.transmutateCasts = casts + 1;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.transmutateCooldownEnd = now + 6000;
          playSound('spell');
        },
        costText: () => {
          const casts = game.stats.transmutateCasts || 0;
          const pct = Math.min(1, 0.30 * (1 + casts * 0.05)) * 100;
          const eff = Math.max(0.4, 1 - casts * 0.05) * 100;
          return 'Convert ' + pct.toFixed(0) + '% mana  stamina (3:1). Efficiency ' + eff.toFixed(0) + '%. Cooldown 6s.';
        },
      },
      {
        id: 'timeDilation',
        name: 'Time Dilation',
        unlock: 5,
        focusCost: 15,
        desc: 'Triples passive mana gain.',
        hideWhenActive: true,
        effect: () => {
          if (!trySpendFocus(15)) return;
          const casts = game.stats.timeDilationCasts || 0;
          const baseCost = timeDilationCost(casts);
          if (!trySpendManaForSpell(baseCost)) return;
          recordActivityOrSpell();
          game.stats.timeDilationCasts = casts + 1;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          const mult = spellEffectMultiplier() * activeEffectMultiplier();
          const durMult = activeDurationMultiplier();
          game.active.boostTD = 3 * mult;
          game.active.duration = 10 * mult * durMult;
          game.active.timer = game.active.duration;
          game.active.cooldown = game.active.duration * 1.1;
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(timeDilationCost(game.stats.timeDilationCasts || 0))) + ' mana, 15 focus',
      },
      {
        id: 'manaSiphon',
        name: 'Mana Siphon',
        unlock: 6,
        focusCost: 10,
        desc: 'Instantly gain 5 seconds of mana/sec.',
        cooldownMs: 8000,
        cooldownKey: 'manaSiphonCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.manaSiphonCooldownEnd || 0) > now) return;
          if (!trySpendFocus(10)) return;
          const cost = 120;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const mult = spellEffectMultiplier() * activeEffectMultiplier();
          const gain = manaPerSecond() * 5 * mult;
          game.mana = Math.min(game.mana + gain, maxMana());
          game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + gain;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.manaSiphonCooldownEnd = now + 8000;
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(120)) + ' mana, 10 focus  Cooldown 8s',
      },
      {
        id: 'frostBolt',
        name: 'Water Bolt',
        unlockCheck: () => totalFloors() >= 18 && researchFlag('unlockElements'),
        unlockText: () => 'Unlocks at 18 floors + Elemental Studies',
        focusCost: 10,
        desc: 'Soak waves or restore wards. Combos with Wind.',
        effect: () => {
          if (!trySpendFocus(10)) return;
          const cost = 320;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const mult = spellEffectMultiplier() * activeEffectMultiplier() * elementalSpellMultiplier('water');
          if (game.encounter && game.encounter.active) {
            game.encounter.timer += 3 * mult;
            game.active.frostSlowTimer = Math.max(game.active.frostSlowTimer || 0, 8 * mult);
          } else {
            game.wards = Math.min((game.wards || 0) + 15 * mult, maxWards());
          }
          registerSpellElement('water');
          gainEssence('water', 1);
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(320)) + ' mana, 10 focus',
      },
      {
        id: 'lightningArc',
        name: 'Wind Arc',
        unlockCheck: () => totalFloors() >= 20 && researchFlag('unlockElements'),
        unlockText: () => 'Unlocks at 20 floors + Elemental Studies',
        focusCost: 12,
        desc: 'Burst damage or mana surge. Combos with Water.',
        effect: () => {
          if (!trySpendFocus(12)) return;
          const cost = 360;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const mult = spellEffectMultiplier() * activeEffectMultiplier() * elementalSpellMultiplier('wind');
          if (game.encounter && game.encounter.active) {
            game.encounter.hp = Math.max(0, game.encounter.hp - game.encounter.maxHp * 0.08 * mult);
          } else {
            const gain = manaPerSecond() * 2.5 * mult;
            game.mana = Math.min((game.mana || 0) + gain, maxMana());
            game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + gain;
          }
          registerSpellElement('wind');
          gainEssence('wind', 1);
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(360)) + ' mana, 12 focus',
      },
      {
        id: 'flameSurge',
        name: 'Flame Surge',
        unlockCheck: () => totalFloors() >= 22 && researchFlag('unlockElements'),
        unlockText: () => 'Unlocks at 22 floors + Elemental Studies',
        focusCost: 12,
        desc: 'Ignites output for a short time. Combos with Water.',
        effect: () => {
          if (!trySpendFocus(12)) return;
          const cost = 380;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const mult = spellEffectMultiplier() * activeEffectMultiplier() * elementalSpellMultiplier('fire');
          if (game.encounter && game.encounter.active) {
            game.encounter.hp = Math.max(0, game.encounter.hp - game.encounter.maxHp * 0.06 * mult);
          } else {
            game.active.flameSurgeTimer = Math.max(game.active.flameSurgeTimer || 0, 10 * mult);
          }
          registerSpellElement('fire');
          gainEssence('fire', 1);
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(380)) + ' mana, 12 focus',
      },
      {
        id: 'runeAccretion',
        name: 'Rune of Accretion',
        unlock: 7,
        desc: 'For 15s, each click adds +1% mana/sec (stacking).',
        cooldownMs: 20000,
        cooldownKey: 'runeAccretionCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.runeAccretionCooldownEnd || 0) > now) return;
          const cost = 400;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const mult = activeDurationMultiplier();
          game.active.runeTimer = 15 * mult;
          game.active.runeStacks = 0;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.runeAccretionCooldownEnd = now + 20000;
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(400)) + ' mana  Cooldown 20s',
      },
      {
        id: 'arcaneHarvest',
        name: 'Arcane Harvest',
        unlock: 8,
        focusCost: 20,
        desc: 'Double mana/sec for 5 seconds.',
        hideWhenActive: true,
        harvestKey: true,
        effect: () => {
          if (!trySpendFocus(20)) return;
          const cost = 200 * Math.pow(1.4, game.stats.arcaneHarvestCasts || 0);
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          game.stats.arcaneHarvestCasts = (game.stats.arcaneHarvestCasts || 0) + 1;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          const mult = spellEffectMultiplier() * activeEffectMultiplier();
          const durMult = activeDurationMultiplier();
          game.active.boostHarvest = 2 * mult;
          game.active.harvestTimer = 5 * mult * durMult;
          game.active.harvestDuration = 5 * mult * durMult;
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(200 * Math.pow(1.4, game.stats.arcaneHarvestCasts || 0))) + ' mana, 20 focus',
      },
      {
        id: 'focusSurge',
        name: 'Focus Surge',
        unlock: 12,
        desc: 'Restore 35 focus (scaled by spell effect).',
        effect: () => {
          const casts = game.stats.focusSurgeCasts || 0;
          const cost = 250 * Math.pow(1.35, casts);
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          game.stats.focusSurgeCasts = casts + 1;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          const mult = spellEffectMultiplier() * activeEffectMultiplier();
          const gain = 35 * mult;
          game.focus = Math.min((game.focus || 0) + gain, maxFocus());
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(250 * Math.pow(1.35, game.stats.focusSurgeCasts || 0))) + ' mana',
      },
      {
        id: 'staminaTransmute',
        name: 'Stamina Transmute',
        unlock: 14,
        focusCost: 15,
        desc: 'Convert 10% stamina into 20% mana (scaled by spell effect).',
        cooldownMs: 18000,
        cooldownKey: 'staminaTransmuteCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.staminaTransmuteCooldownEnd || 0) > now) return;
          if (!trySpendFocus(15)) return;
          const staminaCost = maxStamina() * 0.10;
          if ((game.stamina || 0) < staminaCost) return;
          game.stamina -= staminaCost;
          recordActivityOrSpell();
          const mult = spellEffectMultiplier() * activeEffectMultiplier();
          const gain = maxMana() * 0.20 * mult;
          game.mana = Math.min(game.mana + gain, maxMana());
          game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + gain;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.staminaTransmuteCooldownEnd = now + 18000;
          playSound('spell');
        },
        costText: () => 'Cost 10% stamina, 15 focus  Cooldown 18s',
      },
      {
        id: 'leylineSurge',
        name: 'Leyline Surge',
        unlock: 25,
        focusCost: 25,
        desc: '+' + (LEYLINE_TAP_PCT * 100) + '% mana/sec for ' + LEYLINE_TAP_DURATION + 's.',
        hideWhenActive: true,
        leylineTapKey: true,
        effect: () => {
          if (!trySpendFocus(25)) return;
          const casts = game.stats.leylineSurgeCasts || 0;
          const cost = 400 * Math.pow(1.5, casts);
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          game.stats.leylineSurgeCasts = (game.stats.leylineSurgeCasts || 0) + 1;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          const mult = spellEffectMultiplier() * activeEffectMultiplier();
          const durMult = activeDurationMultiplier();
          game.active.leylineTapPct = LEYLINE_TAP_PCT * mult;
          game.active.leylineTapTimer = LEYLINE_TAP_DURATION * mult * durMult;
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(400 * Math.pow(1.5, game.stats.leylineSurgeCasts || 0))) + ' mana, 25 focus',
      },
      {
        id: 'focusCondenser',
        name: 'Focus Condenser',
        unlock: 22,
        desc: 'For 12s, +50% focus regen but -20% mana/sec.',
        cooldownMs: 20000,
        cooldownKey: 'focusCondenserCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.focusCondenserCooldownEnd || 0) > now) return;
          const cost = 600;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const mult = activeDurationMultiplier();
          game.active.focusCondenserTimer = 12 * mult;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.focusCondenserCooldownEnd = now + 20000;
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(600)) + ' mana  Cooldown 20s',
      },
      {
        id: 'leylineResonance',
        name: 'Leyline Resonance',
        unlock: 32,
        focusCost: 25,
        desc: 'For 30s, spells cost 30% less mana.',
        cooldownMs: 45000,
        cooldownKey: 'leylineResonanceCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.leylineResonanceCooldownEnd || 0) > now) return;
          if (!trySpendFocus(25)) return;
          const cost = 1500;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const mult = activeDurationMultiplier();
          game.active.spellCostDiscountTimer = 30 * mult;
          game.active.spellCostDiscountPct = 0.30;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.leylineResonanceCooldownEnd = now + 45000;
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(1500)) + ' mana, 25 focus  Cooldown 45s',
      },
      {
        id: 'wardOfPreservation',
        name: 'Ward of Preservation',
        unlock: 40,
        desc: 'Next ascension keeps 5% of current mana.',
        effect: () => {
          if (game.wardOfPreservationUsed) return;
          const cost = 2000;
          if (!trySpendManaForSpell(cost)) return;
          game.wardOfPreservationUsed = true;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          playSound('spell');
          showToast('Ward of Preservation', 'Next reset will keep 5% of current mana.');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(2000)) + ' mana (one use per run)',
      },
      {
        id: 'ritualOfBinding',
        name: 'Ritual of Binding',
        unlock: 30,
        focusCost: 30,
        desc: 'Next spell swap costs 50% less focus. 1h cooldown.',
        effect: () => {
          if ((game.ritualOfBindingCooldownEnd || 0) > Date.now()) return;
          if (!trySpendFocus(30)) return;
          const cost = 800;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          game.ritualOfBindingCooldownEnd = Date.now() + RITUAL_OF_BINDING_COOLDOWN_MS;
          game.ritualOfBindingNextSwapHalved = true;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          playSound('spell');
          showToast('Ritual of Binding', 'Next spell swap costs half focus.');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(800)) + ' mana, 30 focus',
      },
      {
        id: 'towerPulse',
        name: 'Tower Pulse',
        unlock: 50,
        desc: 'Next floor costs -25% mana and stamina (single use).',
        cooldownMs: 30000,
        cooldownKey: 'towerPulseCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.towerPulseCooldownEnd || 0) > now) return;
          const cost = 3000;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          game.nextFloorDiscountPct = 0.25;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.towerPulseCooldownEnd = now + 30000;
          playSound('spell');
          showToast('Tower Pulse', 'Next floor costs 25% less.');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(3000)) + ' mana  Cooldown 30s',
      },
      {
        id: 'vigorInfusion',
        name: 'Vigor Infusion',
        unlock: 65,
        focusCost: 20,
        desc: 'Restore 25% stamina and 15 focus (scaled by spell effect).',
        effect: () => {
          if (!trySpendFocus(20)) return;
          const casts = game.stats.vigorInfusionCasts || 0;
          const cost = 1200 * Math.pow(1.45, casts);
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          game.stats.vigorInfusionCasts = casts + 1;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          const mult = spellEffectMultiplier() * activeEffectMultiplier();
          const staminaGain = maxStamina() * 0.25 * mult;
          const focusGain = 15 * mult;
          game.stamina = Math.min(game.stamina + staminaGain, maxStamina());
          game.focus = Math.min((game.focus || 0) + focusGain, maxFocus());
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(1200 * Math.pow(1.45, game.stats.vigorInfusionCasts || 0))) + ' mana, 20 focus',
      },
      {
        id: 'chronoLoop',
        name: 'Chrono Loop',
        unlock: 0,
        unlockCheck: () => hasAchievement('loop_master'),
        unlockText: () => 'Unlocks: Perfecting the Loop (500 spells + 200 floors)',
        sortKey: 900,
        desc: 'Replays the last 60s of passive gains instantly.',
        cooldownMs: 60 * 60 * 1000,
        cooldownKey: 'chronoLoopCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.chronoLoopCooldownEnd || 0) > now) return;
          if (!trySpendFocus(35)) return;
          const cost = 5000;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const gainMana = manaPerSecond() * 60;
          const gainStamina = staminaPerSecond() * 60;
          const gainFocus = focusPerSecond() * 60;
          game.mana = Math.min(game.mana + gainMana, maxMana());
          game.stamina = Math.min(game.stamina + gainStamina, maxStamina());
          game.focus = Math.min((game.focus || 0) + gainFocus, maxFocus());
          game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + gainMana;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.chronoLoopCooldownEnd = now + 60 * 60 * 1000;
          playSound('milestone');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(5000)) + ' mana, 35 focus  Cooldown 1h',
      },
      {
        id: 'nexusOverclock',
        name: 'Nexus Overclock',
        unlock: 0,
        unlockCheck: () => hasAchievement('overcharger'),
        unlockText: () => 'Unlocks: Overcharger (cap mana 50 times)',
        sortKey: 901,
        desc: 'x5 mana/sec for 60s, then exhausted for 180s.',
        cooldownMs: 30 * 60 * 1000,
        cooldownKey: 'nexusOverclockCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.nexusOverclockCooldownEnd || 0) > now) return;
          if (!trySpendFocus(40)) return;
          const cost = 8000;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const mult = activeDurationMultiplier();
          game.active.overclockTimer = 60 * mult;
          game.active.overclockMult = 5;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.nexusOverclockCooldownEnd = now + 30 * 60 * 1000;
          playSound('milestone');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(8000)) + ' mana, 40 focus  Cooldown 30m',
      },
      {
        id: 'worldweave',
        name: 'Worldweave',
        unlock: 0,
        unlockCheck: () => hasAchievement('architect_nexus'),
        unlockText: () => 'Unlocks: Architect of the Nexus (build every room type)',
        sortKey: 902,
        desc: 'Double all resource caps for 15 minutes.',
        cooldownMs: 2 * 60 * 60 * 1000,
        cooldownKey: 'worldweaveCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.worldweaveCooldownEnd || 0) > now) return;
          if (!trySpendFocus(50)) return;
          const cost = 10000;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          game.active.worldweaveTimer = 15 * 60;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.worldweaveCooldownEnd = now + 2 * 60 * 60 * 1000;
          playSound('milestone');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(10000)) + ' mana, 50 focus  Cooldown 2h',
      },
      {
        id: 'leylineConvergence',
        name: 'Leyline Convergence',
        unlock: 0,
        unlockCheck: () => hasAchievement('master_grimoire'),
        unlockText: () => 'Unlocks: Master of the Grimoire (memorize 6 spells)',
        sortKey: 903,
        desc: 'All active spell effects +100% for 60s.',
        cooldownMs: 45 * 60 * 1000,
        cooldownKey: 'convergenceCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.convergenceCooldownEnd || 0) > now) return;
          if (!trySpendFocus(35)) return;
          const cost = 6000;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const mult = activeDurationMultiplier();
          game.active.convergenceTimer = 60 * mult;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.convergenceCooldownEnd = now + 45 * 60 * 1000;
          playSound('milestone');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(6000)) + ' mana, 35 focus  Cooldown 45m',
      },
      {
        id: 'paradoxCast',
        name: 'Paradox Cast',
        unlock: 0,
        unlockCheck: () => hasAchievement('in_the_red'),
        unlockText: () => 'Unlocks: In the Red (cast a spell at 0 mana)',
        sortKey: 904,
        desc: 'Refresh all active spell cooldowns, but -33% mana/sec for 120s.',
        cooldownMs: 2 * 60 * 60 * 1000,
        cooldownKey: 'paradoxCastCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.paradoxCastCooldownEnd || 0) > now) return;
          if (!trySpendFocus(30)) return;
          const cost = 4000;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          game.active.paradoxTimer = 120;
          const cooldownKeys = [
            'transmutateCooldownEnd',
            'manaSiphonCooldownEnd',
            'runeAccretionCooldownEnd',
            'staminaTransmuteCooldownEnd',
            'focusCondenserCooldownEnd',
            'leylineResonanceCooldownEnd',
            'towerPulseCooldownEnd',
            'chronoLoopCooldownEnd',
            'nexusOverclockCooldownEnd',
            'worldweaveCooldownEnd',
            'convergenceCooldownEnd',
          ];
          cooldownKeys.forEach(key => { game[key] = 0; });
          if (game.active && game.active.cooldown > 0) game.active.cooldown = 0;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.paradoxCastCooldownEnd = now + 2 * 60 * 60 * 1000;
          playSound('milestone');
        },
        costText: () => 'Cost ' + formatNum(scaledSpellManaCost(4000)) + ' mana, 30 focus  Cooldown 2h',
      },
    ];

    const PASSIVE_SPELLS = [
      {
        key: 'luckyClick',
        name: 'Lucky Clicks',
        unlock: 5,
        desc: '+5% chance per level for a click to add +5 mana.',
        cost: () => 120 * Math.pow(1.6, game.passive.luckyClick || 0),
        effect: () => { game.passive.luckyClick = (game.passive.luckyClick || 0) + 1; },
      },
      {
        key: 'arcane',
        name: 'Leyline Manipulation',
        unlock: 10,
        desc: 'Each level +15% to all spell effects',
        cost: () => 100 * Math.pow(1.6, game.passive.arcane),
        effect: () => game.passive.arcane++,
      },
      {
        key: 'astral',
        name: 'Astral Insight',
        unlock: 20,
        desc: 'Each level +10% mana/sec per Observatory',
        cost: () => 500 * Math.pow(1.7, game.passive.astral),
        effect: () => game.passive.astral++,
      },
      {
        key: 'aetherFlux',
        name: 'Aether Flux',
        unlock: 24,
        desc: '+0.8% mana/sec per active spell on cooldown (per level).',
        cost: () => 900 * Math.pow(1.6, game.passive.aetherFlux),
        effect: () => game.passive.aetherFlux++,
      },
      {
        key: 'conduit',
        name: 'Conduit Mastery',
        unlock: 15,
        desc: '+0.1% mana/sec per follower score per level',
        cost: () => 300 * Math.pow(1.55, game.passive.conduit),
        effect: () => game.passive.conduit++,
      },
      {
        key: 'focusFlow',
        name: 'Focus Flow',
        unlock: 12,
        desc: '-3% focus idle time and +5% focus regen per level',
        cost: () => 260 * Math.pow(1.55, game.passive.focusFlow),
        effect: () => game.passive.focusFlow++,
      },
      {
        key: 'towerBond',
        name: 'Tower Bond',
        unlock: 35,
        desc: '+0.1% mana/sec per floor per level',
        cost: () => 2000 * Math.pow(1.8, game.passive.towerBond),
        effect: () => game.passive.towerBond++,
      },
      {
        key: 'anchoredRituals',
        name: 'Anchored Rituals',
        unlock: 38,
        desc: '+4% ritual duration and -2% ritual cost per level',
        cost: () => 2400 * Math.pow(1.65, game.passive.anchoredRituals),
        effect: () => game.passive.anchoredRituals++,
      },
      {
        key: 'staminaWell',
        name: 'Stamina Well',
        unlock: 18,
        desc: '+5 max stamina and +1% stamina regen per level',
        cost: () => 400 * Math.pow(1.6, game.passive.staminaWell),
        effect: () => game.passive.staminaWell++,
      },
      {
        key: 'manaReservoir',
        name: 'Mana Reservoir',
        unlock: 55,
        desc: '+4% max mana per level',
        cost: () => 2500 * Math.pow(1.7, game.passive.manaReservoir),
        effect: () => game.passive.manaReservoir++,
      },
      {
        key: 'spellEcho',
        name: 'Spell Echo',
        unlock: 45,
        desc: 'Once per 15 min, next spell cast is free (no mana cost).',
        cost: () => 5000 * Math.pow(2, game.passive.spellEcho),
        effect: () => game.passive.spellEcho++,
      },
      {
        key: 'ritualMastery',
        name: 'Ritual Mastery',
        unlock: 70,
        desc: '+5% active spell and ritual duration per level',
        cost: () => 6500 * Math.pow(1.85, game.passive.ritualMastery),
        effect: () => game.passive.ritualMastery++,
      },
    ];

    // -------------------- ACTIVITIES --------------------
    const ACTIVITIES = [
      {
        id: 'channel',
        name: 'Channel',
        desc: 'Convert stamina and focus into a burst of mana.',
        group: 'core',
        unlockFloors: 1,
        costStaminaPct: () => Math.max(0.18, 0.30 * (1 + (researchEffect('channelCost') || 0))),
        focusCost: 8,
        effect: () => {
          if (!trySpendFocus(8)) return;
          const costPct = Math.max(0.18, 0.30 * (1 + (researchEffect('channelCost') || 0)));
          const cost = maxStamina() * costPct;
          if (game.stamina < cost) return;
          game.stamina -= cost;
          recordActivityOrSpell();
          game.stats.totalStaminaSpent = (game.stats.totalStaminaSpent || 0) + cost;
          const baseMult = 1.6 + Math.min(0.6, totalFloors() * 0.01);
          const gain = manaPerSecond() * (baseMult + (researchEffect('channelBoost') || 0));
          game.mana = Math.min(game.mana + gain, maxMana());
          game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + gain;
          playSound('spell');
        },
        costText: () => {
          const costPct = Math.max(0.18, 0.30 * (1 + (researchEffect('channelCost') || 0)));
          return 'Cost ' + Math.round(costPct * 100) + '% max stamina, 8 focus';
        },
      },
      {
        id: 'meditate',
        name: 'Meditate',
        desc: '+5% stamina regen until next ascension. Stackable up to ' + MEDITATE_CAP + '.',
        group: 'core',
        unlockFloors: 10,
        costStaminaPct: 0.25,
        effect: () => {
          const cost = maxStamina() * 0.25;
          if (game.stamina < cost) return;
          game.stamina -= cost;
          game.stats.totalStaminaSpent = (game.stats.totalStaminaSpent || 0) + cost;
          game.meditateStacks = Math.min((game.meditateStacks || 0) + 1, MEDITATE_CAP);
          playSound('spell');
        },
        costText: () => 'Cost 25% max stamina (' + formatNum(Math.floor(maxStamina() * 0.25)) + ')',
      },
      {
        id: 'scry',
        name: 'Scry',
        desc: 'Lock next tower room choice (same room offered again).',
        group: 'tower',
        unlockFloors: 15,
        costStaminaPct: 0.20,
        effect: () => {
          const cost = maxStamina() * 0.20;
          if (game.stamina < cost) return;
          game.stamina -= cost;
          game.stats.totalStaminaSpent = (game.stats.totalStaminaSpent || 0) + cost;
          const sr = game.specialRooms || {};
          const available = unlockedRoomNames().filter(n => !(sr[n] && sr[n].built));
          if (available.length > 0) {
            game.scryLockedRoom = available[Math.floor(Math.random() * available.length)];
            showToast('Scry', 'Next build will offer: ' + game.scryLockedRoom);
          }
          playSound('spell');
        },
        costText: () => 'Cost 20% max stamina (' + formatNum(Math.floor(maxStamina() * 0.20)) + ')',
      },
      {
        id: 'ritual',
        name: 'Ritual',
        desc: '2 all gains for 60s. 30 min cooldown.',
        group: 'rituals',
        unlockFloors: 35,
        costStaminaPct: 0.80,
        focusCost: 25,
        cooldownMs: RITUAL_ACTIVITY_COOLDOWN_MS,
        cooldownKey: 'ritualActivityCooldownEnd',
        effect: () => {
          if (!trySpendFocus(25)) return;
          const cost = maxStamina() * 0.80 * ritualCostMultiplier();
          if (game.stamina < cost) return;
          if ((game.ritualActivityCooldownEnd || 0) > Date.now()) return;
          game.stamina -= cost;
          recordActivityOrSpell();
          setExhausted();
          game.stats.totalStaminaSpent = (game.stats.totalStaminaSpent || 0) + cost;
          const windowMult = ritualWindowMultiplier();
          game.ritualBuffEnd = Date.now() + 60 * 1000 * ritualDurationMultiplier() * windowMult;
          if (windowMult > 1) {
            game.ritualWindowBonusPct = windowMult - 1;
            game.ritualWindowBonusEnd = game.ritualBuffEnd;
          } else {
            game.ritualWindowBonusPct = 0;
            game.ritualWindowBonusEnd = 0;
          }
          game.ritualActivityCooldownEnd = Date.now() + RITUAL_ACTIVITY_COOLDOWN_MS;
          playSound('spell');
          showToast('Ritual', windowMult > 1 ? 'Ritual window! Bonus amplified.' : '2 all gains for 60s.');
        },
        costText: () => 'Cost ' + Math.round(80 * ritualCostMultiplier()) + '% max stamina, 25 focus',
      },
      {
        id: 'outreach',
        name: 'Outreach',
        desc: 'Primary way to gain followers and improve reputation.',
        group: 'influence',
        unlockFloors: 5,
        costStaminaPct: 0.25,
        focusCost: 8,
        effect: () => {
          if (!trySpendFocus(8)) return;
          const cost = maxStamina() * 0.25;
          if (game.stamina < cost) return;
          game.stamina -= cost;
          recordActivityOrSpell();
          game.stats.totalStaminaSpent = (game.stats.totalStaminaSpent || 0) + cost;
          const rep = game.reputation || 0;
          const base = 3 + Math.floor(totalFloors() / 20);
          const repBonus = Math.floor(rep * 0.08);
          const boost = 1 + (researchEffect('outreachBoost') || 0);
          const gain = Math.max(2, Math.floor((base + repBonus) * boost));
          gainFollowers(gain);
          adjustReputation(3);
          playSound('spell');
        },
        costText: () => 'Cost 25% max stamina, 8 focus',
      },
      {
        id: 'refineEssence',
        name: 'Refine Essence',
        desc: 'Convert stamina into elemental essence.',
        group: 'refinement',
        unlockFloors: 20,
        unlockCheck: () => totalFloors() >= 20 && researchFlag('unlockElements'),
        unlockText: () => 'Unlocks at 20 floors + Elemental Studies',
        costStaminaPct: 0.20,
        focusCost: 10,
        effect: () => {
          if (!trySpendFocus(10)) return;
          const cost = maxStamina() * 0.20;
          if (game.stamina < cost) return;
          game.stamina -= cost;
          recordActivityOrSpell();
          game.stats.totalStaminaSpent = (game.stats.totalStaminaSpent || 0) + cost;
          const types = selectedSchools();
          const primary = types.length ? types[0] : ESSENCE_TYPES[Math.floor(Math.random() * ESSENCE_TYPES.length)];
          const secondary = types.length > 1 ? types[1] : ESSENCE_TYPES[Math.floor(Math.random() * ESSENCE_TYPES.length)];
          const bonus = Math.max(0, Math.floor((game.reputation || 0) / 25));
          gainEssence(primary, 2 + bonus);
          gainEssence(secondary, 1 + bonus);
          playSound('spell');
        },
        costText: () => 'Cost 20% max stamina, 10 focus',
      },
    ];

    const ACTIVITY_GROUPS = [
      { id: 'core', name: 'Core Focus', desc: 'Convert stamina into mana and long-run resilience.', unlockFloors: 1 },
      { id: 'tower', name: 'Towercraft', desc: 'Manipulate upcoming room choices and builds.', unlockFloors: 15 },
      { id: 'rituals', name: 'Rituals', desc: 'Timed buffs aligned with ritual windows.', unlockFloors: 35 },
      { id: 'influence', name: 'Influence', desc: 'Followers, reputation, and outreach.', unlockFloors: 5 },
      { id: 'refinement', name: 'Refinement', desc: 'Essence conversion and resource shaping.', unlockFloors: 20 },
    ];

    // -------------------- ACADEMY / EXPANSION DATA --------------------
    const OUTPOST_ROLES = [
      { id: 'ward', name: 'Ward', desc: 'Boost ward integrity and regeneration.', effects: { wardsMax: 14, wardsRegen: 0.04 } },
      { id: 'research', name: 'Research', desc: 'Increase research point gain.', effects: { research: 0.035 } },
      { id: 'summoning', name: 'Summoning', desc: 'Grow your follower base faster.', effects: { followers: 0.02 } },
      { id: 'amplification', name: 'Amplification', desc: 'Increase mana/sec output.', effects: { manaMult: 0.02 } },
    ];
    const STAFF = [
      { id: 'archivist', name: 'Archivist Lysa', cost: { gold: 120, essence: { arcane: 8 } }, upkeep: 4, desc: '+Research gain, faster rune etching.', effects: { research: 0.02, rune: 0.15 } },
      { id: 'warden', name: 'Wardkeeper Bram', cost: { gold: 140, essence: { earth: 5, fire: 3 } }, upkeep: 5, desc: '+Ward regen and max wards.', effects: { wardsMax: 18, wardsRegen: 0.06 } },
      { id: 'summoner', name: 'Summoner Orel', cost: { gold: 160, essence: { wind: 6 } }, upkeep: 6, desc: '+Follower growth and promotions.', effects: { followers: 0.03, promotion: 0.25 } },
      { id: 'broker', name: 'Broker Anya', cost: { gold: 180, essence: { astral: 5 } }, upkeep: 6, desc: '+Gold income, better market trades.', effects: { gold: 0.08, market: 0.15 } },
    ];
    const SCHOOLS = [
      { id: 'arcane', name: 'Arcane', desc: 'Balanced mastery. +5% mana/sec and +5% spell effect.', bonuses: { manaMult: 0.05, spellEffect: 0.05 }, essence: 'arcane' },
      { id: 'water', name: 'Water', desc: 'Control and efficiency. -8% spell cost, slows encounters.', bonuses: { spellCost: -0.08, slow: 0.2 }, essence: 'water' },
      { id: 'fire', name: 'Fire', desc: 'Burn bright. +10% mana/sec, overcharge lasts longer.', bonuses: { manaMult: 0.10, overcharge: 0.2 }, essence: 'fire' },
      { id: 'wind', name: 'Wind', desc: 'Burst combos. +10% spell effect, +combo potency.', bonuses: { spellEffect: 0.10, combo: 0.25 }, essence: 'wind' },
      { id: 'earth', name: 'Earth', desc: 'Steady resilience. +20 max wards and +8% stamina regen.', bonuses: { wardsMax: 0.20, staminaRegen: 0.08 }, essence: 'earth' },
      { id: 'astral', name: 'Astral', desc: 'Patience and foresight. +12% focus regen, +ritual duration.', bonuses: { focusRegen: 0.12, ritualDuration: 0.10 }, essence: 'astral' },
    ];
    const GLYPHS = [
      { id: 'hunger', name: 'Glyph of Hunger', desc: '+15% spell effect, -10% mana/sec, overcharge drains +20% wards.', mods: { spellEffect: 0.15, manaMult: -0.10, overchargeDrain: 0.20 } },
      { id: 'thorns', name: 'Glyph of Thorns', desc: '+20% ward regen, encounters deal +15% damage.', mods: { wardsRegen: 0.20, enemyDamage: 0.15 } },
      { id: 'echoes', name: 'Glyph of Echoes', desc: '+12% mana/sec, spells cost +15% mana.', mods: { manaMult: 0.12, spellCost: 0.15 } },
    ];
    const MODULES = [
      { id: 'rangeLens', name: 'Range Lens', desc: '+8% encounter damage.', effects: { encounterDamage: 0.08 } },
      { id: 'frostMatrix', name: 'Water Matrix', desc: '+20% slow strength on encounters.', effects: { slow: 0.20 } },
      { id: 'stunCoil', name: 'Stun Coil', desc: '5% chance to stun waves (halve enemy damage).', effects: { stun: 0.05 } },
      { id: 'elementalCore', name: 'Elemental Core', desc: '+12% elemental essence drops.', effects: { essenceDrop: 0.12 } },
    ];
    const CRAFTING_RECIPES = [
      {
        id: 'manaTonic',
        name: 'Mana Tonic',
        desc: 'Gain 25% of max mana instantly.',
        cost: { gold: 30, essence: { arcane: 8 } },
        effect: () => {
          const gain = maxMana() * 0.25;
          game.mana = Math.min((game.mana || 0) + gain, maxMana());
          game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + gain;
        },
      },
      {
        id: 'wardSalve',
        name: 'Ward Salve',
        desc: 'Restore 40 wards.',
        cost: { gold: 35, essence: { earth: 5, fire: 3 } },
        effect: () => { game.wards = Math.min((game.wards || 0) + 40, maxWards()); },
      },
      {
        id: 'focusDraught',
        name: 'Focus Draught',
        desc: 'Restore 30 focus.',
        cost: { gold: 25, essence: { astral: 6, water: 2 } },
        effect: () => { game.focus = Math.min((game.focus || 0) + 30, maxFocus()); },
      },
      {
        id: 'attunementSeal',
        name: 'Attunement Seal',
        desc: 'Next spell cast costs 20% less mana.',
        cost: { gold: 40, essence: { arcane: 6, astral: 4 } },
        unlockCheck: () => researchFlag('unlockAttunement'),
        effect: () => {
          game.attuneDiscount = 0.20;
          showToast('Attunement', 'Next spell costs 20% less mana.');
        },
      },
      {
        id: 'sigilPress',
        name: 'Sigil Press',
        desc: 'Forge a Sigil stack (boosts click power).',
        cost: { gold: 55, essence: { arcane: 6, wind: 3 } },
        unlockCheck: () => researchFlag('unlockSigilCrafting'),
        effect: () => {
          game.sigilStacks = Math.min((game.sigilStacks || 0) + 1, SIGIL_STACK_CAP);
          showToast('Sigil Forged', 'Mana Fonts grow stronger.');
        },
        disabled: () => (game.sigilStacks || 0) >= SIGIL_STACK_CAP,
      },
      {
        id: 'forgeModule',
        name: 'Forge Module',
        desc: 'Craft a random tower module.',
        cost: { gold: 60, essence: { arcane: 6, wind: 4 } },
        unlockCheck: () => researchFlag('modularTowers'),
        effect: () => {
          const mod = MODULES[Math.floor(Math.random() * MODULES.length)];
          addModule(mod.id, 1);
        },
      },
    ];
    const RESEARCH_NODES = [
      { id: 'manaReservoir', name: 'Mana Reservoir Studies', repeatable: true, baseCost: 6, costScale: 1.55, maxLevel: 40, desc: '+7% max mana per level.', effects: {} },
      { id: 'spellEtching', name: 'Spell Etching', repeatable: true, baseCost: 8, costScale: 1.6, maxLevel: 50, desc: '+1% spell effect per level.', effects: {} },
      { id: 'channelFocus', name: 'Channel Focus', cost: 10, desc: 'Channel grants +0.4 mana and -5% stamina cost.', effects: { channelBoost: 0.4, channelCost: -0.05 } },
      { id: 'attunementTheory', name: 'Attunement Theory', cost: 12, desc: 'Unlock Attunement Seals in crafting.', effects: { unlockAttunement: true } },
      { id: 'sigilCrafting', name: 'Sigil Crafting', cost: 14, desc: 'Unlock Sigil Press in crafting.', effects: { unlockSigilCrafting: true } },
      { id: 'outreachPacts', name: 'Outreach Pacts', cost: 12, desc: '+15% follower gains from Outreach.', effects: { outreachBoost: 0.15 } },
      { id: 'academyRoots', name: 'Academy Roots', cost: 8, desc: 'Unlock basic academy logistics. +5% research gain.', effects: { research: 0.05 } },
      { id: 'elementalStudies', name: 'Elemental Studies', cost: 12, desc: 'Unlock Water/Fire/Wind spells and essence.', effects: { unlockElements: true } },
      { id: 'modularTowers', name: 'Modular Towers', cost: 14, desc: '+1 module slot per outpost.', effects: { moduleSlots: 1 } },
      { id: 'ritualCalendars', name: 'Ritual Calendars', cost: 10, desc: '+15% ritual window bonus.', effects: { ritualWindow: 0.15 } },
      { id: 'summonerPacts', name: 'Summoner Pacts', cost: 12, desc: '+12% follower growth.', effects: { followers: 0.12 } },
      { id: 'archivalWards', name: 'Archival Wards', cost: 16, desc: '+25 max wards.', effects: { wardsMax: 25 } },
      { id: 'leylineRelay', name: 'Leyline Relay', cost: 18, desc: '+6% outpost bonuses per active link.', effects: { linkBoost: 0.06 } },
      { id: 'combatScriptures', name: 'Combat Scriptures', cost: 20, desc: '+10% encounter damage and unlock contracts.', effects: { encounterDamage: 0.10, unlockContracts: true } },
    ];
    const ENEMY_TYPES = [
      { id: 'manaLeech', name: 'Mana Leech', desc: 'Stronger when your mana is high.', highMana: { enemyDamage: 0.25, playerDamage: -0.10 } },
      { id: 'duskStrider', name: 'Dusk Strider', desc: 'Weakened when your mana is low.', lowMana: { playerDamage: 0.20 } },
      { id: 'voidWarden', name: 'Void Warden', desc: 'Drains wards when overcharged.', overcharge: { enemyDamage: 0.15 } },
      { id: 'mirrorShade', name: 'Mirror Shade', desc: 'Reflects burst damage; steadier output preferred.', steady: { playerDamage: -0.08 } },
    ];
    const WAVE_MODIFIERS = [
      { id: 'swarm', name: 'Swarm', desc: 'Lower HP, faster waves.', hpMult: 0.75, speedMult: 1.25, rewardMult: 1.05 },
      { id: 'shielded', name: 'Shielded', desc: 'Higher HP, reduced player damage.', hpMult: 1.35, playerDamage: -0.12, rewardMult: 1.1 },
      { id: 'fast', name: 'Fast', desc: 'Waves resolve quickly but hit harder.', speedMult: 1.4, enemyDamage: 0.18, rewardMult: 1.08 },
      { id: 'rifted', name: 'Rifted', desc: 'Unstable reality boosts essence drops.', essenceDrop: 0.2, rewardMult: 1.12 },
    ];
    const CONTRACT_TEMPLATES = [
      { id: 'swiftClear', name: 'Swift Clear', desc: 'Clear 2 waves in 90s.', type: 'waves', target: 2, duration: 90, reward: { gold: 60, essence: { arcane: 6 } } },
      { id: 'lowMana', name: 'Humble Focus', desc: 'Clear a wave with mana below 40%.', type: 'manaLimit', target: 1, duration: 120, reward: { gold: 40, essence: { water: 4 } } },
      { id: 'wardHold', name: 'Ward Hold', desc: 'Survive 70s without dropping below 40% wards.', type: 'wardHold', target: 70, duration: 100, reward: { gold: 55, essence: { earth: 4 } } },
      { id: 'relicExpedition', name: 'Relic Expedition', desc: 'Clear 3 waves in 180s to locate a relic draft.', type: 'relicScout', target: 3, duration: 180, reward: { relicDraft: true } },
    ];
    const FOLLOWER_EVENTS = [
      {
        id: 'festival',
        title: 'Festival of Embers',
        text: 'Your followers wish to host a festival. It could inspire devotion or drain supplies.',
        options: [
          { label: 'Fund the festival (-80 gold, +8 rep)', effect: () => { spendGold(80); adjustReputation(8); gainFollowers(8); } },
          { label: 'Keep it modest (+2 rep)', effect: () => { adjustReputation(2); gainFollowers(3); } },
        ],
      },
      {
        id: 'rebellion',
        title: 'Whispers of Rebellion',
        text: 'A faction protests your demands. Their loyalty wavers.',
        options: [
          { label: 'Offer concessions (-6% mana/sec for 3m, +10 rep)', effect: () => { adjustReputation(10); game.active.concessionTimer = 180; } },
          { label: 'Hold your ground (-12 followers, -6 rep)', effect: () => { loseFollowers(12); adjustReputation(-6); } },
        ],
      },
      {
        id: 'pilgrimage',
        title: 'Pilgrimage Request',
        text: 'A group asks to pilgrimage. Bless them for favor or redirect them to work.',
        options: [
          { label: 'Bless them (+essence, +rep)', effect: () => { gainEssence('astral', 6); adjustReputation(6); } },
          { label: 'Redirect to labor (+gold, -rep)', effect: () => { gainGold(70); adjustReputation(-4); } },
        ],
      },
    ];
    const STORY_ENTRIES = [
      { id: 'entry1', title: 'Foundations of the Nexus', unlock: g => totalFloorsFromGame(g) >= 5, text: 'You chart the first leyline fractures. The tower hums with newborn intent.' },
      { id: 'entry2', title: 'Voices in the Atrium', unlock: g => totalFollowersFromGame(g) >= 20, text: 'New voices arrive, chanting in unison. Power now has a chorus.' },
      { id: 'entry3', title: 'The Academy Charter', unlock: g => totalFollowersFromGame(g) >= FOLLOWER_THRESHOLDS.academy, text: 'With followers gathered, you draft the charter of the Mage Academy.' },
      { id: 'entry4', title: 'Starlit Observations', unlock: g => totalFloorsFromGame(g) >= 8, text: 'The skies answer. The Observatory reveals shifting patterns.' },
      { id: 'entry5', title: 'Echoes of Ascension', unlock: g => (g.ascension || 0) >= 1, text: 'You step beyond mortal pacing. The echo remains.' },
    ];
    const ARTIFACTS = [
      { id: 'emberLens', name: 'Ember Lens', desc: '+4% mana/sec.', unlock: g => totalFloorsFromGame(g) >= 20, mods: { manaMult: 0.04 } },
      { id: 'quietBell', name: 'Quiet Bell', desc: '+8 max focus.', unlock: g => totalFollowersFromGame(g) >= 30, mods: { maxFocusBonus: 8 } },
      { id: 'wardSigil', name: 'Ward Sigil', desc: '+12 max wards.', unlock: g => totalFloorsFromGame(g) >= 45, mods: { wardsMax: 12 } },
    ];
    const DAILY_BLESSINGS = [
      { id: 'calm', name: 'Calm Currents', desc: '+6% mana/sec today.', mods: { manaMult: 0.06 } },
      { id: 'vigil', name: 'Vigil of Wards', desc: '+18% ward regen today.', mods: { wardsRegen: 0.18 } },
      { id: 'insight', name: 'Insight Bloom', desc: '+12% research gain today.', mods: { research: 0.12 } },
      { id: 'unity', name: 'Unity Chorus', desc: '+8% follower growth today.', mods: { followers: 0.08 } },
    ];
    const RUNE_SYMBOLS = ['Runic A', 'Runic B', 'Runic C', 'Runic D', 'Runic E', 'Runic F'];
    const COSMETIC_UPGRADES = [
      { id: 'sheen1', name: 'Leyline Sheen', unlock: g => totalFloorsFromGame(g) >= 25, desc: 'Add a soft glow to the tower blocks.', className: 'cosmetic-sheen' },
      { id: 'sheen2', name: 'Astral Halo', unlock: g => totalFollowersFromGame(g) >= 60, desc: 'Mana windows shimmer with astral hue.', className: 'cosmetic-sheen' },
    ];
    const ASCENSION_CHALLENGES = [
      { id: 'manaDrought', name: 'Mana Drought', desc: '-25% mana/sec, +12% essence drops.', penalties: { manaMult: -0.25 }, rewards: { essenceDrop: 0.12 } },
      { id: 'thinWards', name: 'Thin Wards', desc: '-25% max wards, +15% research.', penalties: { wardsMax: -0.25 }, rewards: { research: 0.15 } },
      { id: 'focusStrain', name: 'Focus Strain', desc: '-20% focus regen, +10% spell effect.', penalties: { focusRegen: -0.20 }, rewards: { spellEffect: 0.10 } },
    ];

    function getSchoolById(id) { return SCHOOLS.find(s => s.id === id); }
    function selectedSchools() {
      const list = [];
      if (game.schools && game.schools.primary) list.push(game.schools.primary);
      if (game.schools && game.schools.secondary && game.schools.secondary !== game.schools.primary) list.push(game.schools.secondary);
      return list;
    }
    function schoolBonus(key) {
      let total = 0;
      selectedSchools().forEach(id => {
        const s = getSchoolById(id);
        if (!s || !s.bonuses) return;
        const val = s.bonuses[key];
        if (typeof val === 'number') total += val;
      });
      return total;
    }
    function activeGlyph() {
      const id = game.glyphs && game.glyphs.active;
      return GLYPHS.find(g => g.id === id) || null;
    }
    function glyphBonus(key) {
      const g = activeGlyph();
      if (!g || !g.mods) return 0;
      const val = g.mods[key];
      return typeof val === 'number' ? val : 0;
    }
    function researchNodeLevel(node) {
      if (!node || !node.repeatable) return 0;
      const levels = (game.research && game.research.levels) ? game.research.levels : {};
      return levels[node.id] || 0;
    }
    function researchNodeCost(node) {
      if (!node) return 0;
      if (!node.repeatable) return node.cost || 0;
      const level = researchNodeLevel(node);
      const scale = node.costScale || 1.6;
      const base = node.baseCost || 6;
      return Math.round(base * Math.pow(scale, level));
    }
    function isResearchUnlocked(id) {
      const node = RESEARCH_NODES.find(n => n.id === id);
      if (node && node.repeatable) return researchNodeLevel(node) > 0;
      return !!(game.research && Array.isArray(game.research.unlocked) && game.research.unlocked.includes(id));
    }
    function researchEffect(key) {
      let total = 0;
      RESEARCH_NODES.forEach(n => {
        const val = n.effects ? n.effects[key] : null;
        if (typeof val !== 'number') return;
        if (n.repeatable) {
          total += val * researchNodeLevel(n);
          return;
        }
        if (!isResearchUnlocked(n.id)) return;
        total += val;
      });
      return total;
    }
    function researchFlag(key) {
      return RESEARCH_NODES.some(n => {
        if (!n.effects || !n.effects[key]) return false;
        return n.repeatable ? researchNodeLevel(n) > 0 : isResearchUnlocked(n.id);
      });
    }
    function unlockResearchNode(id) {
      const node = RESEARCH_NODES.find(n => n.id === id);
      if (!node) return;
      if (!game.research) game.research = initialResearchState();
      if (node.repeatable) {
        const level = researchNodeLevel(node);
        if (node.maxLevel && level >= node.maxLevel) return;
        const cost = researchNodeCost(node);
        if ((game.research.points || 0) < cost) return;
        game.research.points -= cost;
        if (!game.research.levels) game.research.levels = {};
        game.research.levels[node.id] = level + 1;
        if (node.id === 'manaReservoir') game.studyCount = game.research.levels[node.id];
        if (node.id === 'spellEtching') game.transcribeBonusPct = game.research.levels[node.id];
        showToast('Research advanced', node.name + ' Lv.' + (level + 1));
        return;
      }
      if (isResearchUnlocked(id)) return;
      const cost = node.cost || 0;
      if ((game.research.points || 0) < cost) return;
      game.research.points -= cost;
      game.research.unlocked = [...(game.research.unlocked || []), id];
      showToast('Research complete', node.name + ' unlocked.');
    }
    function getStaffState(id) {
      if (!game.academyStaff || typeof game.academyStaff !== 'object') game.academyStaff = {};
      if (!game.academyStaff[id]) game.academyStaff[id] = { hired: false, happiness: 60 };
      if (typeof game.academyStaff[id].happiness !== 'number') game.academyStaff[id].happiness = 60;
      if (typeof game.academyStaff[id].hired !== 'boolean') game.academyStaff[id].hired = false;
      return game.academyStaff[id];
    }
    function staffHappinessMultiplier(h) {
      const clamped = Math.max(0, Math.min(100, h));
      return 0.5 + (clamped / 100);
    }
    function staffEffect(key) {
      let total = 0;
      STAFF.forEach(s => {
        const st = getStaffState(s.id);
        if (!st.hired) return;
        const mult = staffHappinessMultiplier(st.happiness || 60);
        const val = s.effects ? s.effects[key] : 0;
        if (typeof val === 'number') total += val * mult;
      });
      return total;
    }
    function staffUpkeepPerMin() {
      let total = 0;
      STAFF.forEach(s => {
        const st = getStaffState(s.id);
        if (!st.hired) return;
        total += s.upkeep || 0;
      });
      return total;
    }
    function hireStaff(id) {
      const staff = STAFF.find(s => s.id === id);
      if (!staff) return;
      const st = getStaffState(id);
      if (st.hired) return;
      if (!payCost(staff.cost)) return;
      st.hired = true;
      st.happiness = Math.max(50, st.happiness || 60);
      showToast('Staff hired', staff.name + ' joins the academy.');
    }
    function treatStaff(id) {
      const st = getStaffState(id);
      if (!st.hired) return;
      const cost = 30;
      if (!spendGold(cost)) return;
      st.happiness = Math.min(100, (st.happiness || 60) + 12);
    }
    function outpostLinkCount() {
      const outposts = game.academyOutposts || [];
      let links = 0;
      for (let i = 0; i < outposts.length - 1; i++) {
        const left = outposts[i];
        const right = outposts[i + 1];
        if (!left || !right || !left.built || !right.built) continue;
        if (left.links && right.links && left.links.right && right.links.left) links++;
      }
      return links;
    }
    function outpostLinkMultiplier() {
      const links = outpostLinkCount();
      const base = 0.04;
      const extra = researchEffect('linkBoost');
      return 1 + links * (base + extra);
    }
    function moduleEffects() {
      const effects = {};
      const outposts = game.academyOutposts || [];
      outposts.forEach(o => {
        if (!o || !o.built || !Array.isArray(o.modules)) return;
        o.modules.forEach(id => {
          const mod = MODULES.find(m => m.id === id);
          if (!mod || !mod.effects) return;
          Object.keys(mod.effects).forEach(k => {
            effects[k] = (effects[k] || 0) + mod.effects[k];
          });
        });
      });
      return effects;
    }
    function outpostEffects() {
      const effects = { wardsMax: 0, wardsRegen: 0, research: 0, followers: 0, manaMult: 0 };
      const outposts = game.academyOutposts || [];
      const linkMult = outpostLinkMultiplier();
      outposts.forEach(o => {
        if (!o || !o.built || !o.role) return;
        const role = OUTPOST_ROLES.find(r => r.id === o.role);
        if (!role) return;
        const level = Math.max(1, o.level || 1);
        Object.keys(role.effects || {}).forEach(k => {
          effects[k] = (effects[k] || 0) + role.effects[k] * level * linkMult;
        });
      });
      const mods = moduleEffects();
      Object.keys(mods).forEach(k => {
        effects[k] = (effects[k] || 0) + mods[k];
      });
      return effects;
    }

    // -------------------- RELICS --------------------
    function availableRelics() {
      const owned = new Set(game.relics || []);
      return RELICS.filter(r => !owned.has(r.id));
    }
    function pickRelicChoices(count) {
      const pool = availableRelics();
      if (pool.length === 0) return [];
      const choices = [];
      const bag = pool.slice();
      while (bag.length > 0 && choices.length < count) {
        const idx = Math.floor(Math.random() * bag.length);
        choices.push(bag.splice(idx, 1)[0]);
      }
      return choices;
    }
    function ensureRelicDraft() {
      if (Array.isArray(game.relicDraft) && game.relicDraft.length > 0) return;
      const reached = relicMilestonesReached();
      const owned = (game.relics || []).length;
      if (reached <= owned) return;
      const choices = pickRelicChoices(3);
      if (choices.length === 0) return;
      game.relicDraft = choices.map(r => r.id);
      game.relicDraftSeen = false;
    }
    function selectRelic(relicId) {
      if (!relicId) return;
      if (!Array.isArray(game.relics)) game.relics = [];
      if (!game.relics.includes(relicId)) game.relics.push(relicId);
      game.relicDraft = [];
      game.relicDraftSeen = false;
      if (relicModal) relicModal.style.display = 'none';
      const relic = RELIC_BY_ID[relicId];
      if (relic) showToast('Relic claimed', relic.name + '  ' + relic.desc);
      playSound('milestone');
      renderAll();
    }
    function openRelicDraft() {
      if (!relicModal || !relicChoices) return;
      if (!Array.isArray(game.relicDraft) || game.relicDraft.length === 0) return;
      relicChoices.innerHTML = '';
      game.relicDraftSeen = true;
      game.relicDraft.forEach(id => {
        const relic = RELIC_BY_ID[id];
        if (!relic) return;
        const card = document.createElement('div');
        card.className = 'relic-card tier-' + relic.tier;
        card.innerHTML =
          '<div class="relic-tier">' + relic.tier + '</div>' +
          '<div class="relic-title">' + relic.name + '</div>' +
          '<div class="relic-desc">' + relic.desc + '</div>';
        card.onclick = () => selectRelic(id);
        relicChoices.appendChild(card);
      });
      relicModal.style.display = 'flex';
    }
    function renderRelicsPanel() {
      if (!relicSummary) return;
      ensureRelicDraft();
      const relics = game.relics || [];
      const next = nextRelicMilestone();
      let html = '<div><strong>Relics</strong></div>';
      html += '<div class="cost">Collected: ' + relics.length + ' / ' + RELIC_MILESTONES.length + '</div>';
      html += next ? '<div class="cost">Next relic at ' + next + ' floors.</div>' : '<div class="cost">All relic milestones reached.</div>';
      if (relics.length === 0) {
        html += '<div class="cost">No relics yet.</div>';
      } else {
        html += '<div class="relic-list">' + relics.map(id => {
          const relic = RELIC_BY_ID[id];
          if (!relic) return '';
          return '<div class="relic-item"><div class="relic-name">' + relic.name + '</div><div class="relic-note">' + relic.desc + '</div></div>';
        }).join('') + '</div>';
      }
      relicSummary.innerHTML = html;
      const hasDraft = Array.isArray(game.relicDraft) && game.relicDraft.length > 0;
      if (relicDraftSection) relicDraftSection.style.display = hasDraft ? 'block' : 'none';
      if (relicDraftBtn) relicDraftBtn.onclick = () => openRelicDraft();
      if (hasDraft && !game.relicDraftSeen) openRelicDraft();
    }

    // -------------------- RENDER --------------------
    function renderAll() { renderUI(); renderSpells(); renderTower(); renderActivities(); renderRelicsPanel(); renderAcademy(); renderLibrary(); renderObservatory(); }

    function clearTutorialLayer() {
      if (!tutorialLayer) return;
      tutorialLayer.innerHTML = '';
    }
    function addTutorialTip(target, html, pos) {
      if (!tutorialLayer || !target) return;
      const tip = document.createElement('div');
      tip.className = 'tutorial-tip pos-' + pos;
      tip.innerHTML = html;
      tutorialLayer.appendChild(tip);
      const rect = target.getBoundingClientRect();
      const tipRect = tip.getBoundingClientRect();
      const gap = 12;
      let top = rect.top;
      let left = rect.left;
      if (pos === 'top') {
        top = rect.top - tipRect.height - gap;
        left = rect.left + rect.width / 2 - tipRect.width / 2;
      } else if (pos === 'bottom') {
        top = rect.bottom + gap;
        left = rect.left + rect.width / 2 - tipRect.width / 2;
      } else if (pos === 'left') {
        top = rect.top + rect.height / 2 - tipRect.height / 2;
        left = rect.left - tipRect.width - gap;
      } else {
        top = rect.top + rect.height / 2 - tipRect.height / 2;
        left = rect.right + gap;
      }
      const pad = 8;
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      left = Math.max(pad, Math.min(left, vw - tipRect.width - pad));
      top = Math.max(pad, Math.min(top, vh - tipRect.height - pad));
      tip.style.left = left + 'px';
      tip.style.top = top + 'px';
    }
    function renderTutorialHints() {
      if (!tutorialLayer) return;
      if (!game.tutorial || typeof game.tutorial !== 'object') {
        game.tutorial = { clicked: false, done: false, completedToast: false, settingsOpened: false, keysSeen: false, glossarySeen: false, libraryOpened: false, observatoryOpened: false, towerOpened: false, activitiesOpened: false };
      }
      if (typeof game.tutorial.settingsOpened !== 'boolean') game.tutorial.settingsOpened = false;
      if (typeof game.tutorial.keysSeen !== 'boolean') game.tutorial.keysSeen = false;
      if (typeof game.tutorial.glossarySeen !== 'boolean') game.tutorial.glossarySeen = false;
      if (typeof game.tutorial.libraryOpened !== 'boolean') game.tutorial.libraryOpened = false;
      if (typeof game.tutorial.observatoryOpened !== 'boolean') game.tutorial.observatoryOpened = false;
      if (typeof game.tutorial.towerOpened !== 'boolean') game.tutorial.towerOpened = false;
      if (typeof game.tutorial.activitiesOpened !== 'boolean') game.tutorial.activitiesOpened = false;
      if (typeof game.wasManaCapped !== 'boolean') game.wasManaCapped = false;
      if (!game.settings || typeof game.settings !== 'object') game.settings = { showTutorial: true, keybinds: {} };
      if (typeof game.settings.showTutorial !== 'boolean') game.settings.showTutorial = true;
      ensureKeybinds();
      if (!game.settings.showTutorial || game.tutorial.done) { clearTutorialLayer(); return; }

      const task1 = !!game.tutorial.clicked;
      const task2 = (game.manaFonts || 0) >= 1;
      const task3 = totalFloors() >= 1;
      const task4 = !!game.tutorial.activitiesOpened && (game.stats && game.stats.totalStaminaSpent) > 0;
      const task5 = !!game.tutorial.libraryOpened;
      const task6 = !!game.tutorial.observatoryOpened;
      const task7 = !!game.tutorial.towerOpened;
      const task8 = !!game.tutorial.keysSeen;
      const task9 = !!game.tutorial.glossarySeen;
      const doneCount = [task1, task2, task3, task4, task5, task6, task7, task8, task9].filter(Boolean).length;
      if (doneCount >= 9) {
        game.tutorial.done = true;
        clearTutorialLayer();
        if (!game.tutorial.completedToast) {
          game.tutorial.completedToast = true;
          showToast('All set', 'Tutorial complete. You can keep building your tower!');
        }
        return;
      }

      clearTutorialLayer();
      if (!task1) {
        addTutorialTip(towerContainer, '<strong>Gather mana</strong><br>Click around the tower to gain mana.', 'bottom');
        return;
      }
      if (!task2) {
        const canBuyFont = (game.mana || 0) >= manaFontCost();
        if (!canBuyFont) {
          addTutorialTip(towerContainer, '<strong>Gather mana</strong><br>Keep clicking until you can buy a Mana Font.', 'right');
          return;
        }
        addTutorialTip(manaFontBtn, '<strong>Mana Font</strong><br>Buy one to strengthen clicks. (Tip: press M)', 'top');
        return;
      }
      if (!task3) {
        const floorCost = effectiveFloorCost();
        const floorStamCost = effectiveFloorStaminaCost();
        const canBuild = (game.mana || 0) >= floorCost && (game.stamina || 0) >= floorStamCost;
        if (!canBuild) {
          const needStam = (game.stamina || 0) < floorStamCost;
          addTutorialTip(needStam ? staminaBlock : manaBlock, '<strong>Prepare</strong><br>Wait for resources to raise a floor.', 'bottom');
          return;
        }
        addTutorialTip(towerBtn, '<strong>Raise a floor</strong><br>Build your first room to grow the tower.', 'top');
        return;
      }
      if (!task4) {
        const now = Date.now();
        const affordable = ACTIVITIES.find(a => {
          const unlockFloors = Number(a.unlockFloors) || 0;
          if (totalFloors() < unlockFloors) return false;
          const stamCost = (a.costStaminaPct || 0) * maxStamina();
          const focusCost = (typeof a.focusCost === 'function') ? a.focusCost() : (a.focusCost || 0);
          if ((game.stamina || 0) < stamCost) return false;
          if ((game.focus || 0) < focusCost) return false;
          const cooldownKey = a.cooldownKey || 'ritualActivityCooldownEnd';
          if (a.cooldownMs && (game[cooldownKey] || 0) > now) return false;
          if (typeof a.disabled === 'function' && a.disabled()) return false;
          return true;
        });
        if (!affordable) { clearTutorialLayer(); return; }
        if (!document.getElementById('activitiesModal').classList.contains('show')) {
          addTutorialTip(activitiesTab, '<strong>Activities</strong><br>Explore activity groups and their unlocks.', 'top');
        } else {
          const firstAction = activitiesDiv ? activitiesDiv.querySelector('button') : null;
          addTutorialTip(firstAction || activitiesTab, '<strong>Try an action</strong><br>Spend stamina to kickstart your loop.', 'left');
        }
        return;
      }
      if (!task5) {
        addTutorialTip(libraryTab, '<strong>Library</strong><br>Open the Library to plan long-term upgrades.', 'top');
        return;
      }
      if (!task6) {
        addTutorialTip(observatoryTab, '<strong>Observatory</strong><br>Open to track encounters and contracts.', 'top');
        return;
      }
      if (!task7) {
        addTutorialTip(towerTab, '<strong>Tower</strong><br>Open the Tower tab to review wards and today\'s blessing.', 'top');
        return;
      }
      if (!task8) {
        if (!settingsModal || settingsModal.style.display !== 'flex') {
          addTutorialTip(settingsBtn, '<strong>Keybinds</strong><br>Open settings to view keybinds.', 'left');
        } else {
          addTutorialTip(settingsTabKeys, '<strong>Keybinds</strong><br>Open this tab to view or rebind keys.', 'bottom');
        }
        return;
      }
      if (!task9) {
        if (!settingsModal || settingsModal.style.display !== 'flex') {
          addTutorialTip(settingsBtn, '<strong>Glossary</strong><br>Open settings to view the glossary.', 'left');
        } else {
          addTutorialTip(settingsTabGlossary, '<strong>Glossary</strong><br>Open this tab to review core concepts.', 'bottom');
        }
      }
    }
    function showLoreTip() {
      if (!loreTip) return;
      loreTip.style.display = 'block';
    }
    function hideLoreTip() {
      if (!loreTip) return;
      loreTip.style.display = 'none';
      try { localStorage.setItem('mageTowerLoreSeen', '1'); } catch (e) {}
    }

    function updateBadges() {
      // Tower: can buy font / build floor / upgrade a room
      const canBuyFont = (game.mana || 0) >= manaFontCost();
      const effCost = effectiveFloorCost();
      const floorStamCost = effectiveFloorStaminaCost();
      const canBuild = (game.mana || 0) >= effCost && (game.stamina || 0) >= floorStamCost;
      let canUpgrade = false;
      const sr = game.specialRooms || {};
      SPECIAL_ROOM_NAMES.forEach(name => {
        if (canUpgrade) return;
        const r = sr[name];
        if (!r || !r.built) return;
        if ((game.mana || 0) >= upgradeCost(name)) canUpgrade = true;
      });
      setTabBadge('towerModal', canBuyFont || canBuild || canUpgrade);

      // Activities: any unlocked activity affordable (basic check)
      const now = Date.now();
      let canAct = false;
      if (typeof ACTIVITIES !== 'undefined') {
        for (const a of ACTIVITIES) {
          if (!isActivityUnlocked(a)) continue;
          const ritualMult = a.id === 'ritual' ? ritualCostMultiplier() : 1;
          const stamCost = activityStaminaCostPct(a) * maxStamina() * ritualMult;
          const focusCost = (typeof a.focusCost === 'function') ? a.focusCost() : (a.focusCost || 0);
          if ((game.stamina || 0) < stamCost) continue;
          if ((game.focus || 0) < focusCost) continue;
          const cooldownKey = a.cooldownKey || 'ritualActivityCooldownEnd';
          if (a.cooldownMs && (game[cooldownKey] || 0) > now) continue;
          if (typeof a.disabled === 'function' && a.disabled()) continue;
          canAct = true;
          break;
        }
      }
      setTabBadge('activitiesModal', canAct);

      // Grimoire: spell swap ready and there exists something new to memorize, or passive upgrade affordable
      const swapReady = canSwapSpell();
      const usedSlots = (game.memorizedSpells || []).length;
      const totalSlots = maxSpellSlots();
      let canMemorize = false;
      if (swapReady && usedSlots < totalSlots) {
        const f = totalFloors();
        const seen = new Set(game.memorizedSpells || []);
        const anyUnlockedUnmemorized = (list, isActive) => list.some(s => isSpellUnlocked(s, isActive) && !seen.has(getSpellId(s, isActive)));
        if (typeof ACTIVE_SPELLS !== 'undefined' && anyUnlockedUnmemorized(ACTIVE_SPELLS, true)) canMemorize = true;
        if (typeof PASSIVE_SPELLS !== 'undefined' && anyUnlockedUnmemorized(PASSIVE_SPELLS, false)) canMemorize = true;
      }
      let canPassiveBuy = false;
      if (typeof PASSIVE_SPELLS !== 'undefined') {
        for (const s of PASSIVE_SPELLS) {
          if (!isSpellUnlocked(s, false)) continue;
          const spellId = getSpellId(s, false);
          if (!isMemorized(spellId)) continue;
          const cost = (s.cost ? s.cost() * SCALE : 0);
          if ((game.mana || 0) >= cost && cost > 0) { canPassiveBuy = true; break; }
        }
      }
      setTabBadge('grimoireModal', canMemorize || canPassiveBuy);

      // Ascension: can ascend now
      setTabBadge('ascensionModal', totalFloors() >= ASCENSION_FLOOR);
      setTabBadge('relicsModal', Array.isArray(game.relicDraft) && game.relicDraft.length > 0);
      const outposts = game.academyOutposts || [];
      const canBuildOutpost = outposts.some((o, i) => !o.built && canAffordCost(outpostBuildCost(i)));
      const canUpgradeOutpost = outposts.some(o => o && o.built && canAffordCost(outpostUpgradeCost(o.level || 1)));
      const canHire = STAFF.some(s => !getStaffState(s.id).hired && canAffordCost(s.cost));
      setTabBadge('academyModal', canBuildOutpost || canUpgradeOutpost || canHire || availableFollowers() > 0);
      const canResearch = RESEARCH_NODES.some(n => {
        const points = (game.research && game.research.points || 0);
        const cost = researchNodeCost(n);
        if (n.repeatable) {
          const level = researchNodeLevel(n);
          if (n.maxLevel && level >= n.maxLevel) return false;
          return points >= cost;
        }
        return !isResearchUnlocked(n.id) && points >= cost;
      });
      setTabBadge('libraryModal', canResearch);
      const contractComplete = Array.isArray(game.contracts) && game.contracts.some(c => c.complete && !c.claimed);
      setTabBadge('observatoryModal', contractComplete || !(game.encounter && game.encounter.active));
    }

    function renderUI() {
      mana.textContent = formatNum(game.mana);
      manaMaxEl.textContent = formatNum(maxMana());
      manaPerSec.textContent = formatRate(manaPerSecond()) + '/s';
      staminaEl.textContent = formatNum(game.stamina);
      staminaMaxEl.textContent = formatNum(maxStamina());
      staminaPerSecEl.textContent = formatRate(staminaPerSecond()) + '/s';
      if (focusEl) focusEl.textContent = formatNum(game.focus || 0);
      if (focusMaxEl) focusMaxEl.textContent = formatNum(maxFocus());
      if (focusPerSecEl) focusPerSecEl.textContent = formatRate(focusPerSecond()) + '/s';
      if (focusIdleHint) {
        const idleSec = Math.round(FOCUS_IDLE_SEC * focusIdleMultiplier());
        focusIdleHint.textContent = '(after ' + idleSec + 's idle)';
      }
      setMiniBar(manaFillEl, game.mana || 0, maxMana());
      setMiniBar(staminaFillEl, game.stamina || 0, maxStamina());
      setMiniBar(focusFillEl, game.focus || 0, maxFocus());
      updateResourceFullState(manaBlock, game.mana, maxMana());
      updateResourceFullState(staminaBlock, game.stamina, maxStamina());
      updateResourceFullState(focusBlock, game.focus || 0, maxFocus());
      if (followersTotalEl) followersTotalEl.textContent = totalFollowers();
      if (reputationEl) reputationEl.textContent = Math.round(game.reputation || 0);
      if (goldEl) goldEl.textContent = formatNum(game.gold || 0);
      if (goldUpkeepEl) goldUpkeepEl.textContent = (staffUpkeepPerMin() || 0).toFixed(1);
      if (towerWardsEl) towerWardsEl.textContent = Math.round(game.wards || 0);
      if (towerWardsMaxEl) towerWardsMaxEl.textContent = Math.round(maxWards());
      if (towerWardsPerSecEl) towerWardsPerSecEl.textContent = wardsRegenPerSecond().toFixed(2);
      if (essenceTotalEl) {
        const totalEssence = ESSENCE_TYPES.reduce((sum, t) => sum + (game.essence && game.essence[t] || 0), 0);
        essenceTotalEl.textContent = formatNum(totalEssence);
      }
      if (essenceTooltipEl) {
        essenceTooltipEl.textContent = ESSENCE_TYPES.map(t => t[0].toUpperCase() + t.slice(1) + ': ' + Math.floor(game.essence && game.essence[t] || 0)).join('\n');
      }
      if (towerBlessingPanel) {
        const blessing = getDailyBlessing();
        towerBlessingPanel.innerHTML = blessing
          ? '<div><strong>Daily Blessing:</strong> ' + blessing.name + '</div><div class="cost">' + blessing.desc + '</div>'
          : '<div><strong>Daily Blessing:</strong> None</div><div class="cost">Next blessing in ' + formatDuration(Math.max(0, (game.dailyBlessing && game.dailyBlessing.nextAt || 0) - Date.now())) + '</div>';
      }
      updateSpeedControls();
      const exhaustedEnd = game.exhaustedUntil || 0;
      if (exhaustedHint) {
        if (exhaustedEnd > Date.now()) {
          exhaustedHint.style.display = 'block';
          const sec = Math.ceil((exhaustedEnd - Date.now()) / 1000);
          const m = Math.floor(sec / 60);
          const s = sec % 60;
          exhaustedHint.textContent = 'Exhausted: ' + m + ':' + (s < 10 ? '0' : '') + s + ' (50% stamina regen)';
        } else {
          exhaustedHint.style.display = 'none';
        }
      }
      floors.textContent = totalFloors();
      manaFontCostEl.textContent = 'Cost: ' + formatNum(manaFontCost()) + ' mana (Shift: x10, Ctrl: max)';
      const canBuyFont = (game.mana || 0) >= manaFontCost();
      if (manaFontBtn) manaFontBtn.classList.toggle('affordable', canBuyFont);
      const sigilStacks = Math.min(game.sigilStacks || 0, SIGIL_STACK_CAP);
      const sigilMult = 1 + sigilStacks * SIGIL_STACK_PCT;
      const fontClick = MANA_FONT_RATE * sigilMult * (1 + roomEffectSum('fontPct')) * (1 + (relicModifiers().fontRateMult || 0));
      if (manaFontPreview) manaFontPreview.textContent = '+' + formatRate(fontClick) + ' mana/click';
      const effCost = effectiveFloorCost();
      const floorStamCost = effectiveFloorStaminaCost();
      const canBuild = (game.mana || 0) >= effCost && (game.stamina || 0) >= floorStamCost;
      if (towerBtn) towerBtn.classList.toggle('affordable', canBuild);
      const discountTag = (game.nextFloorDiscountPct || 0) > 0 ? ' (Tower Pulse: -25%)' : '';
      towerCostEl.textContent = game.nextFloorBonus ? 'Next floor: Free (+ ' + formatNum(floorStamCost) + ' stamina)' : (game.nextFloorCursed ? 'Next floor: ' + formatNum(effCost) + ' mana, ' + formatNum(floorStamCost) + ' stamina (2 cost, 2 effect)' : 'Cost: ' + formatNum(effCost) + ' mana, ' + formatNum(floorStamCost) + ' stamina' + discountTag);
      if (towerPreview) towerPreview.textContent = '+' + (FLOOR_BONUS * 100).toFixed(1) + '% follower mana/sec';

      const canAscend = totalFloors() >= ASCENSION_FLOOR;
      const canAscendTier2 = totalFloors() >= ASCENSION_FLOOR_2;
      const ascTotal = ((game.ascension || 0) * ASCENSION_BONUS_PER + (game.ascensionTier2 || 0) * ASCENSION_2_BONUS_PER) * 100;
      ascensionDesc.textContent = canAscend
        ? (canAscendTier2
          ? 'Ascend Tier 2 (100 floors): +12% mana/sec. Or ascend at 50 for +8%. Current: ' + ascTotal.toFixed(0) + '% total.'
          : 'Ascend: +8% mana/sec (50 floors). Reach 100 for Tier 2 (+12%). Current: ' + totalFloors() + ' floors.')
        : 'Reach ' + ASCENSION_FLOOR + ' floors to ascend. Current: ' + totalFloors() + ' floors.';
      ascendBtn.onclick = () => {
        if (totalFloors() < ASCENSION_FLOOR) return;
        if (!confirm('Ascend? This resets floors, rooms, and upgrades. You keep ascension bonuses. Continue?')) return;
        const keptFollowers = { ...(game.followers || initialFollowers()) };
        const keptReputation = game.reputation || 0;
        const keptOutposts = game.academyOutposts || initialAcademyOutposts();
        const keptStaff = game.academyStaff || initialAcademyStaff();
        const keptResearch = game.research || initialResearchState();
        const keptModules = game.modules || {};
        const keptSchools = game.schools || { primary: null, secondary: null, slots: 1 };
        const keptGold = game.gold || 0;
        const keptEssence = game.essence || initialEssence();
        const keptChallenge = game.challenge || { active: null, completed: [], tokens: 0 };
        const keptCosmetics = game.cosmetics || { unlocked: [], active: null };
        const savedMana = game.wardOfPreservationUsed ? game.mana * 0.05 : 0;
        const hallLvl = countRooms('Hall of Preservation');
        const savedFloorsKept = hallLvl >= 1 ? Math.floor(totalFloors() * PRESTIGE_KEEP_FLOORS_PCT) : 0;
        game.stats.totalFloorsEver = (game.stats.totalFloorsEver || 0) + totalFloors();
        if (totalFloors() >= ASCENSION_FLOOR_2) game.ascensionTier2 = (game.ascensionTier2 || 0) + 1;
        else game.ascension++;
        game.prestige = 0;
        game.softPrestige = 0;
        game.specialRooms = initialSpecialRooms();
        game.memorizedSpells = (game.memorizedSpells || []).slice(0, maxSpellSlots());
        game.stairs = 0;
        game.floorsKept = savedFloorsKept;
        game.mana = savedMana;
        game.manaFonts = 0;
        game.passive = { arcane: 0, astral: 0, conduit: 0, towerBond: 0, staminaWell: 0, spellEcho: 0, focusFlow: 0, manaReservoir: 0, ritualMastery: 0, aetherFlux: 0, anchoredRituals: 0, luckyClick: 0 };
        game.active = {
          boost: 1,
          boostTD: 1,
          boostHarvest: 1,
          timer: 0,
          duration: 0,
          cooldown: 0,
          harvestTimer: 0,
          harvestDuration: 0,
          leylineTapTimer: 0,
          leylineTapPct: 0,
          runeTimer: 0,
          runeStacks: 0,
          focusCondenserTimer: 0,
          spellCostDiscountTimer: 0,
          spellCostDiscountPct: 0,
          overclockTimer: 0,
          overclockMult: 1,
          worldweaveTimer: 0,
          convergenceTimer: 0,
          paradoxTimer: 0,
          overchargeTimer: 0,
          overchargeMult: 1,
          concessionTimer: 0,
          comboTimer: 0,
          comboMult: 1,
          overchargeCharge: 0,
          flameSurgeTimer: 0,
          frostSlowTimer: 0,
        };
        game.studyCount = 0;
        game.stamina = maxStamina();
        game.wardOfPreservationUsed = false;
        game.meditateStacks = 0;
        game.scryLockedRoom = null;
        game.ritualBuffEnd = 0;
        game.ritualWindowBonusPct = 0;
        game.ritualWindowBonusEnd = 0;
        game.attuneDiscount = 0;
        game.relics = [];
        game.relicDraft = [];
        game.relicDraftSeen = false;
        game.sigilStacks = 0;
        game.relicHuntCooldownEnd = 0;
        game.transmutateCooldownEnd = 0;
        game.manaSiphonCooldownEnd = 0;
        game.runeAccretionCooldownEnd = 0;
        game.staminaTransmuteCooldownEnd = 0;
        game.focusCondenserCooldownEnd = 0;
        game.leylineResonanceCooldownEnd = 0;
        game.towerPulseCooldownEnd = 0;
        game.chronoLoopCooldownEnd = 0;
        game.nexusOverclockCooldownEnd = 0;
        game.worldweaveCooldownEnd = 0;
        game.convergenceCooldownEnd = 0;
        game.paradoxCastCooldownEnd = 0;
        game.nextFloorDiscountPct = 0;
        game.nextFloorDuplicate = null;
        game.nextFloorCursed = false;
        game.nextFloorBonus = false;
        game.nextFloorOffers = null;
        game.nextFloorRolled = false;
        game.stats.focusSurgeCasts = 0;
        game.stats.vigorInfusionCasts = 0;
        game.stats.transmutateCasts = 0;
        game.runeEtchingBuffEnd = 0;
        game.followers = keptFollowers;
        game.reputation = keptReputation;
        game.academyOutposts = keptOutposts;
        game.academyStaff = keptStaff;
        game.research = keptResearch;
        game.modules = keptModules;
        game.gold = keptGold;
        game.essence = keptEssence;
        game.challenge = keptChallenge;
        game.cosmetics = keptCosmetics;
        game.schools = keptSchools;
        if (game.schools) game.schools.slots = Math.min(2, (game.schools.slots || 1) + 1);
        game.followerAssignments = initialFollowerAssignments();
        game.followerProgress = 0;
        game.promotionProgress = { novice: 0, acolyte: 0 };
        game.scoutingProgress = 0;
        game.wards = maxWards();
        game.encounter = initialEncounterState();
        game.contracts = [];
        game.followerEvent = null;
        game.nextFollowerEventAt = 0;
        renderAll();
        playSound('milestone');
      };
      ascendBtn.disabled = !canAscend;

      const hasAscended = (game.ascension || 0) + (game.ascensionTier2 || 0) >= 1;
      const showParagon = hasAscended && totalFloors() >= PARAGON_FLOOR_MIN;
      if (paragonSection) paragonSection.style.display = showParagon ? 'block' : 'none';
      if (showParagon && paragonXpEl) {
        const xp = game.paragonXp || 0;
        paragonXpEl.textContent = 'Paragon XP: ' + formatNum(xp);
      }
      if (showParagon && paragonNodes) {
        const s = game.paragonSpent || { manaPct: 0, spellEffect: 0, stamina: 0, focus: 0 };
        const xp = game.paragonXp || 0;
        paragonNodes.innerHTML = '';
        const addNode = (key, label, maxLvl) => {
          const cur = s[key] || 0;
          const btn = document.createElement('button');
          btn.textContent = label + ' (' + cur + '/' + maxLvl + ')  ' + PARAGON_NODE_COST + ' XP';
          btn.disabled = xp < PARAGON_NODE_COST || cur >= maxLvl;
          btn.onclick = () => {
            if (game.paragonXp < PARAGON_NODE_COST) return;
            if ((s[key] || 0) >= maxLvl) return;
            game.paragonXp -= PARAGON_NODE_COST;
            if (!game.paragonSpent) game.paragonSpent = { manaPct: 0, spellEffect: 0, stamina: 0, focus: 0 };
            game.paragonSpent[key] = (game.paragonSpent[key] || 0) + 1;
            renderAll();
          };
          paragonNodes.appendChild(btn);
        };
        addNode('manaPct', '+0.5% mana/sec', 20);
        addNode('spellEffect', '+1% spell effect', 15);
        addNode('stamina', '+5 max stamina', 10);
        addNode('focus', '+5 max focus', 10);
      }

      const ascensionTabUnlocked = totalFloors() >= ASCENSION_TAB_UNLOCK;
      if (ascensionTab) {
        if (ascensionTabUnlocked) {
          ascensionTab.classList.remove('tab-locked');
          ascensionTab.title = 'Ascension';
        } else {
          ascensionTab.classList.add('tab-locked');
          ascensionTab.title = 'Unlocks at ' + ASCENSION_TAB_UNLOCK + ' floors';
        }
      }
      if (relicTab) {
        const relicUnlocked = (game.relics || []).length > 0;
        if (relicUnlocked) {
          relicTab.classList.remove('tab-locked');
          relicTab.title = 'Relics';
        } else {
          relicTab.classList.add('tab-locked');
          relicTab.title = 'Unlocks after claiming your first relic';
        }
      }
      const followerTotal = totalFollowers();
      if (academyTab) {
        if (followerTotal >= FOLLOWER_THRESHOLDS.academy) {
          academyTab.style.display = '';
          academyTab.classList.remove('tab-locked');
          academyTab.title = 'Academy';
        } else {
          academyTab.style.display = 'none';
        }
      }
      if (libraryTab) {
        libraryTab.classList.remove('tab-locked');
        libraryTab.title = 'Library';
      }
      if (observatoryTab) {
        observatoryTab.classList.remove('tab-locked');
        observatoryTab.title = 'Observatory';
      }

      renderRoomSummary();
      renderTowerUpgrades();
      renderTimeDilationStatus();
      renderTutorialHints();
      ensureRelicDraft();
      updateBadges();
    }

    function setGameSpeed(mult) {
      game.speed = mult;
      updateSpeedControls();
    }
    function updateSpeedControls() {
      if (!pauseBtn || !playBtn || !speedBtn) return;
      const speed = (typeof game.speed === 'number') ? game.speed : 1;
      pauseBtn.classList.toggle('active', speed === 0);
      playBtn.classList.toggle('active', speed === 1);
      speedBtn.classList.toggle('active', speed === 2);
    }
    if (pauseBtn) pauseBtn.onclick = () => setGameSpeed(0);
    if (playBtn) playBtn.onclick = () => setGameSpeed(1);
    if (speedBtn) speedBtn.onclick = () => setGameSpeed(2);

    function renderTowerUpgrades() {
      towerUpgradeButtons.innerHTML = '';
      const sr = game.specialRooms || {};
      const built = SPECIAL_ROOM_NAMES.filter(name => sr[name] && sr[name].built);
      if (built.length === 0) return;
      const title = document.createElement('p');
      title.className = 'section-title';
      title.textContent = 'Upgrade built rooms';
      towerUpgradeButtons.appendChild(title);
      built.forEach(name => {
        const r = sr[name];
        const cost = upgradeCost(name);
        const btn = document.createElement('button');
        btn.innerHTML = 'Upgrade ' + name + '<span class="cost">Cost: ' + formatNum(cost) + ' mana</span>';
        btn.onclick = () => {
          if (game.mana < cost) return;
          game.mana -= cost;
          r.level = (r.level || 1) + 1;
          renderAll();
        };
        if (game.mana < cost) btn.disabled = true;
        towerUpgradeButtons.appendChild(btn);
      });
    }

    function isActivityUnlocked(activity) {
      if (typeof activity.unlockCheck === 'function') return activity.unlockCheck();
      if (typeof activity.unlockFloors === 'number') return totalFloors() >= activity.unlockFloors;
      return true;
    }
    function activityUnlockHint(activity) {
      if (typeof activity.unlockText === 'function') return activity.unlockText();
      if (typeof activity.unlockFloors === 'number') return 'Unlocks at ' + activity.unlockFloors + ' floors';
      return 'Unlock condition not met';
    }
    function activityStaminaCostPct(activity) {
      if (typeof activity.costStaminaPct === 'function') return activity.costStaminaPct();
      return activity.costStaminaPct || 0;
    }

    function renderActivities() {
      activitiesDiv.innerHTML = '';
      const floors = Number(totalFloors()) || 0;
      const stamina = Number(game.stamina) || 0;
      const focus = Number(game.focus) || 0;
      const EPS = 1e-3;
      ACTIVITY_GROUPS.forEach(group => {
        const groupWrap = document.createElement('div');
        const header = document.createElement('div');
        header.className = 'panel-card';
        header.innerHTML = '<div class="title">' + group.name + '</div><div class="muted">' + group.desc + '</div>';
        if (floors < group.unlockFloors) {
          const hint = document.createElement('div');
          hint.className = 'unlock-hint';
          hint.textContent = 'Unlocks at ' + group.unlockFloors + ' floors';
          header.appendChild(hint);
        }
        groupWrap.appendChild(header);

        const groupActivities = ACTIVITIES.filter(a => a.group === group.id)
          .sort((a, b) => (Number(a.unlockFloors) || 0) - (Number(b.unlockFloors) || 0));
        groupActivities.forEach(a => {
          const btn = document.createElement('button');
          btn.textContent = a.name;
          const locked = !isActivityUnlocked(a);
          let detail = a.costText ? a.costText() : '';
          if (a.cooldownMs) {
            const cooldownKey = a.cooldownKey || 'ritualActivityCooldownEnd';
            const end = game[cooldownKey] || 0;
            const rem = Math.max(0, (end - Date.now()) / 1000);
            if (rem > 0) {
              const m = Math.floor(rem / 60);
              const s = Math.floor(rem % 60);
              detail = 'Available in ' + m + ':' + (s < 10 ? '0' : '') + s;
            }
          }
          const desc = document.createElement('span');
          desc.className = 'desc';
          desc.innerHTML = a.desc + '<br><span class="detail">' + detail + '</span>';
          btn.appendChild(desc);
          const ritualMult = a.id === 'ritual' ? ritualCostMultiplier() : 1;
          const costAmount = a.costStaminaPct != null ? maxStamina() * activityStaminaCostPct(a) * ritualMult : 0;
          const focusCost = (typeof a.focusCost === 'function') ? a.focusCost() : (a.focusCost || 0);
          const cooldownKey = a.cooldownKey || 'ritualActivityCooldownEnd';
          const onCooldown = a.cooldownMs && (game[cooldownKey] || 0) > Date.now();
          const lowFocus = a.focusCost != null && focus < focusCost - EPS;
          const lowStamina = a.costStaminaPct != null && stamina < costAmount - EPS;
          const customDisabled = typeof a.disabled === 'function' ? a.disabled() : false;
          btn.onclick = () => {
            if (locked) return;
            if (a.costStaminaPct != null && game.stamina < costAmount) return;
            if (onCooldown) return;
            a.effect();
            renderAll();
          };
          btn.disabled = locked || lowFocus || lowStamina || onCooldown || customDisabled;
          if (locked) {
            const hint = document.createElement('span');
            hint.className = 'unlock-hint';
            hint.textContent = activityUnlockHint(a);
            btn.appendChild(hint);
          }
          groupWrap.appendChild(btn);
        });
        activitiesDiv.appendChild(groupWrap);
      });
    }

    function renderAcademy() {
      if (!academySummary || !outpostList || !staffList || !marketPanel || !moduleInventory) return;
      const f = game.followers || {};
      const total = totalFollowers();
      const linkCount = outpostLinkCount();
      academySummary.innerHTML =
        '<div>Followers: ' + total + ' (Novice ' + (f.novice || 0) + ', Acolyte ' + (f.acolyte || 0) + ', Sage ' + (f.sage || 0) + ')</div>' +
        '<div class="cost">Reputation: ' + Math.round(game.reputation || 0) + '%  Leyline links: ' + linkCount + '</div>';

      outpostList.innerHTML = '';
      const outposts = game.academyOutposts || [];
      outposts.forEach((o, idx) => {
        const card = document.createElement('div');
        card.className = 'panel-card';
        const title = document.createElement('div');
        title.className = 'title';
        title.textContent = 'Outpost ' + (idx + 1);
        card.appendChild(title);

        if (!o.built) {
          const cost = outpostBuildCost(idx);
          const desc = document.createElement('div');
          desc.className = 'muted';
          desc.textContent = 'Build a satellite tower to extend your academy.';
          card.appendChild(desc);
          const btn = document.createElement('button');
          btn.textContent = 'Build (' + formatCost(cost) + ')';
          btn.disabled = !canAffordCost(cost);
          btn.onclick = () => { buildOutpost(idx); renderAcademy(); };
          card.appendChild(btn);
          outpostList.appendChild(card);
          return;
        }

        const info = document.createElement('div');
        info.className = 'muted';
        info.textContent = 'Level ' + (o.level || 1) + '  Role: ' + (o.role || '');
        card.appendChild(info);

        const roleRow = document.createElement('div');
        roleRow.className = 'choice-row';
        OUTPOST_ROLES.forEach(r => {
          const btn = document.createElement('button');
          btn.textContent = r.name;
          btn.disabled = o.role === r.id;
          btn.onclick = () => { setOutpostRole(idx, r.id); renderAcademy(); };
          roleRow.appendChild(btn);
        });
        card.appendChild(roleRow);

        const linkRow = document.createElement('div');
        linkRow.className = 'choice-row';
        if (idx > 0) {
          const left = document.createElement('button');
          left.textContent = (o.links && o.links.left ? 'Unlink' : 'Link') + ' Left';
          left.onclick = () => { toggleOutpostLink(idx, 'left'); renderAcademy(); };
          linkRow.appendChild(left);
        }
        if (idx < outposts.length - 1) {
          const right = document.createElement('button');
          right.textContent = (o.links && o.links.right ? 'Unlink' : 'Link') + ' Right';
          right.onclick = () => { toggleOutpostLink(idx, 'right'); renderAcademy(); };
          linkRow.appendChild(right);
        }
        card.appendChild(linkRow);

        const upgrade = document.createElement('button');
        const upgradeCost = outpostUpgradeCost(o.level || 1);
        upgrade.textContent = 'Upgrade (' + formatCost(upgradeCost) + ')';
        upgrade.disabled = !canAffordCost(upgradeCost);
        upgrade.onclick = () => { upgradeOutpost(idx); renderAcademy(); };
        card.appendChild(upgrade);

        const slots = moduleSlotsPerOutpost();
        const slotWrap = document.createElement('div');
        slotWrap.className = 'mini-list';
        for (let s = 0; s < slots; s++) {
          const slot = document.createElement('div');
          slot.className = 'module-slot' + (o.modules && o.modules[s] ? ' filled' : '');
          if (o.modules && o.modules[s]) {
            const mod = MODULES.find(m => m.id === o.modules[s]);
            slot.textContent = mod ? mod.name : o.modules[s];
            const rem = document.createElement('button');
            rem.style.marginTop = '6px';
            rem.textContent = 'Remove';
            rem.onclick = () => { removeModuleFromOutpost(idx, s); renderAcademy(); };
            slot.appendChild(rem);
          } else {
            slot.textContent = 'Empty slot';
          }
          slotWrap.appendChild(slot);
        }
        card.appendChild(slotWrap);

        const invRow = document.createElement('div');
        invRow.className = 'choice-row';
        MODULES.forEach(m => {
          if (moduleCount(m.id) <= 0) return;
          const btn = document.createElement('button');
          btn.textContent = 'Install ' + m.name;
          btn.onclick = () => { installModule(idx, m.id); renderAcademy(); };
          invRow.appendChild(btn);
        });
        if (invRow.children.length) card.appendChild(invRow);

        outpostList.appendChild(card);
      });

      staffList.innerHTML = '';
      STAFF.forEach(s => {
        const st = getStaffState(s.id);
        const card = document.createElement('div');
        card.className = 'panel-card';
        card.innerHTML = '<div class="title">' + s.name + '</div>' +
          '<div class="muted">' + s.desc + '</div>' +
          '<div class="muted">Upkeep: ' + s.upkeep + '/min</div>';
        if (!st.hired) {
          const hire = document.createElement('button');
          hire.textContent = 'Hire (' + formatCost(s.cost) + ')';
          hire.disabled = !canAffordCost(s.cost);
          hire.onclick = () => { hireStaff(s.id); renderAcademy(); };
          card.appendChild(hire);
        } else {
          const happy = document.createElement('div');
          happy.className = 'muted';
          happy.textContent = 'Happiness: ' + Math.round(st.happiness || 0) + '%';
          card.appendChild(happy);
          const treat = document.createElement('button');
          treat.textContent = 'Treat (30 gold)';
          treat.onclick = () => { treatStaff(s.id); renderAcademy(); };
          card.appendChild(treat);
        }
        staffList.appendChild(card);
      });

      const available = availableFollowers();
      const assignmentRows = [
        { key: 'market', label: 'Market' },
        { key: 'research', label: 'Research' },
        { key: 'ritual', label: 'Ritual' },
        { key: 'scouting', label: 'Scouting' },
      ];
      marketPanel.innerHTML = '';
      const eventRem = (game.nextFollowerEventAt || 0) - Date.now();
      const summary = document.createElement('div');
      summary.className = 'stat';
      summary.innerHTML = 'Available followers: <strong>' + available + '</strong><br>' +
        'Gold/sec: ' + goldPerSecond().toFixed(2) + '  Research/sec: ' + researchPointsPerSecond().toFixed(3) +
        '<br>Event: ' + (game.followerEvent ? 'Active' : (eventRem > 0 ? Math.ceil(eventRem / 1000) + 's' : 'Ready'));
      marketPanel.appendChild(summary);
      assignmentRows.forEach(row => {
        const line = document.createElement('div');
        line.className = 'panel-card';
        line.innerHTML = '<div class="row"><strong>' + row.label + '</strong><span>' + assignmentCount(row.key) + '</span></div>';
        const controls = document.createElement('div');
        controls.className = 'choice-row';
        const minus = document.createElement('button');
        minus.textContent = '-';
        minus.onclick = () => { assignFollowers(row.key, -1); renderAcademy(); };
        const plus = document.createElement('button');
        plus.textContent = '+';
        plus.onclick = () => { assignFollowers(row.key, 1); renderAcademy(); };
        controls.appendChild(minus);
        controls.appendChild(plus);
        line.appendChild(controls);
        marketPanel.appendChild(line);
      });

      moduleInventory.innerHTML = '';
      MODULES.forEach(m => {
        const count = moduleCount(m.id);
        const card = document.createElement('div');
        card.className = 'panel-card';
        card.innerHTML = '<div class="title">' + m.name + '</div><div class="muted">' + m.desc + '</div>' +
          '<div class="muted">In inventory: ' + count + '</div>';
        moduleInventory.appendChild(card);
      });
    }

    function renderLibrary() {
      if (!librarySummary || !researchTree || !schoolChoices || !glyphChoices || !runeEtchingPanel || !craftingPanel || !storyPanel) return;
      const ritualInfo = ritualWindowInfo();
      const ritualText = ritualInfo.inWindow ? ('Active (' + Math.ceil(ritualInfo.remaining / 1000) + 's)') : ('Next in ' + Math.ceil(ritualInfo.remaining / 1000) + 's');
      librarySummary.innerHTML = 'Research points: <strong>' + (game.research && game.research.points || 0).toFixed(2) + '</strong>' +
        '<br>Mana Reservoir: <strong>Lv.' + manaReservoirLevel() + '</strong>  Spell Etching: <strong>Lv.' + spellEtchingLevel() + '</strong>' +
        '<br>Daily blessing: <strong>' + (getDailyBlessing() ? getDailyBlessing().name : 'None') + '</strong>' +
        '<br>Ritual window: <strong>' + ritualText + '</strong>';

      researchTree.innerHTML = '';
      RESEARCH_NODES.forEach(n => {
        const unlocked = isResearchUnlocked(n.id);
        const level = n.repeatable ? researchNodeLevel(n) : 0;
        const cost = researchNodeCost(n);
        const card = document.createElement('div');
        card.className = 'panel-card';
        card.innerHTML = '<div class="title">' + n.name + (n.repeatable ? ' Lv.' + level : '') + '</div><div class="muted">' + n.desc + '</div>' +
          '<div class="muted">Cost: ' + cost + ' RP</div>';
        const btn = document.createElement('button');
        const maxed = n.repeatable && n.maxLevel && level >= n.maxLevel;
        btn.textContent = n.repeatable ? (maxed ? 'Maxed' : 'Upgrade') : (unlocked ? 'Unlocked' : 'Unlock');
        btn.disabled = (!n.repeatable && unlocked) || (game.research && game.research.points || 0) < cost || maxed;
        btn.onclick = () => { unlockResearchNode(n.id); renderLibrary(); };
        card.appendChild(btn);
        researchTree.appendChild(card);
      });

      schoolChoices.innerHTML = '';
      const slots = (game.schools && game.schools.slots) || 1;
      SCHOOLS.forEach(s => {
        const card = document.createElement('div');
        card.className = 'panel-card';
        card.innerHTML = '<div class="title">' + s.name + '</div><div class="muted">' + s.desc + '</div>';
        const primaryBtn = document.createElement('button');
        primaryBtn.textContent = (game.schools && game.schools.primary === s.id) ? 'Primary' : 'Set Primary';
        primaryBtn.disabled = game.schools && game.schools.primary === s.id;
        primaryBtn.onclick = () => { setSchoolSlot('primary', s.id); renderLibrary(); };
        card.appendChild(primaryBtn);
        const secondaryBtn = document.createElement('button');
        secondaryBtn.textContent = (game.schools && game.schools.secondary === s.id) ? 'Secondary' : 'Set Secondary';
        secondaryBtn.disabled = slots < 2 || (game.schools && game.schools.secondary === s.id);
        secondaryBtn.onclick = () => { setSchoolSlot('secondary', s.id); renderLibrary(); };
        card.appendChild(secondaryBtn);
        schoolChoices.appendChild(card);
      });

      glyphChoices.innerHTML = '';
      GLYPHS.forEach(g => {
        const card = document.createElement('div');
        card.className = 'panel-card' + ((game.glyphs && game.glyphs.active === g.id) ? ' glyph-active' : '');
        card.innerHTML = '<div class="title">' + g.name + '</div><div class="muted">' + g.desc + '</div>';
        const btn = document.createElement('button');
        btn.textContent = (game.glyphs && game.glyphs.active === g.id) ? 'Deactivate' : 'Activate';
        btn.onclick = () => { toggleGlyph(g.id); renderLibrary(); };
        card.appendChild(btn);
        glyphChoices.appendChild(card);
      });

      renderRuneEtching();
      renderCrafting();
      renderStoryPanel();
    }

    function renderObservatory() {
      if (!encounterSummary || !encounterPanel || !contractsPanel || !challengePanel || !cosmeticPanel) return;
      const enc = game.encounter || initialEncounterState();
      encounterSummary.innerHTML = 'Threat: ' + (enc.threat || 0).toFixed(1) +
        '  Wards: ' + Math.round(game.wards || 0) + '/' + Math.round(maxWards());

      encounterPanel.innerHTML = '';
      const card = document.createElement('div');
      card.className = 'panel-card';
      if (!enc.active) {
        card.innerHTML = '<div class="title">Next Encounter</div><div class="muted">Wave ' + ((enc.wave || 0) + 1) + '</div>';
        const btn = document.createElement('button');
        btn.textContent = 'Start Encounter';
        btn.onclick = () => { startEncounter(); renderObservatory(); };
        card.appendChild(btn);
      } else {
        const enemy = ENEMY_TYPES.find(e => e.id === enc.enemyType);
        const mods = (enc.modifiers || []).map(id => WAVE_MODIFIERS.find(m => m.id === id)).filter(Boolean);
        card.innerHTML = '<div class="title">Wave ' + enc.wave + '</div>' +
          '<div class="muted">Enemy: ' + (enemy ? enemy.name : 'Unknown') + '</div>' +
          '<div class="muted">Modifiers: ' + (mods.length ? mods.map(m => m.name).join(', ') : 'None') + '</div>' +
          '<div class="muted">Time left: ' + Math.max(0, enc.timer).toFixed(1) + 's</div>';
        const bar = document.createElement('div');
        bar.className = 'progress-line';
        const fill = document.createElement('div');
        fill.className = 'fill';
        const pct = enc.maxHp > 0 ? Math.max(0, enc.hp / enc.maxHp) * 100 : 0;
        fill.style.width = pct.toFixed(1) + '%';
        bar.appendChild(fill);
        card.appendChild(bar);
      }
      encounterPanel.appendChild(card);

      contractsPanel.innerHTML = '';
      ensureContracts();
      if (Array.isArray(game.contracts) && game.contracts.length) {
        game.contracts.forEach((c, idx) => {
          const item = document.createElement('div');
          item.className = 'contract-item';
          const timeLeft = c.accepted && c.expiresAt ? Math.max(0, (c.expiresAt - Date.now()) / 1000) : 0;
          const reward = c.reward && c.reward.relicDraft ? 'Relic draft' : 'Gold/Essence';
          item.innerHTML = '<strong>' + c.name + '</strong><div class="muted">' + c.desc + '</div>' +
            '<div class="muted">Reward: ' + reward + '</div>' +
            '<div class="muted">Progress: ' + c.progress.toFixed(1) + '/' + c.target + (c.accepted ? '  ' + timeLeft.toFixed(0) + 's' : '') + '</div>';
          const btn = document.createElement('button');
          if (!c.accepted) {
            btn.textContent = 'Accept';
            btn.onclick = () => { acceptContract(idx); renderObservatory(); };
          } else if (c.complete && !c.claimed) {
            btn.textContent = 'Claim';
            btn.onclick = () => { claimContract(idx); renderObservatory(); };
          } else {
            btn.textContent = c.complete ? 'Complete' : 'In progress';
            btn.disabled = true;
          }
          item.appendChild(btn);
          contractsPanel.appendChild(item);
        });
      } else {
        const empty = document.createElement('div');
        empty.className = 'contract-item';
        empty.textContent = 'No contracts available yet.';
        contractsPanel.appendChild(empty);
      }

      renderChallenges();
      renderCosmetics();
    }

    function renderChallenges() {
      if (!challengePanel) return;
      challengePanel.innerHTML = '';
      const tokenLine = document.createElement('div');
      tokenLine.className = 'stat';
      tokenLine.textContent = 'Challenge Tokens: ' + (game.challenge && game.challenge.tokens || 0);
      challengePanel.appendChild(tokenLine);
      ASCENSION_CHALLENGES.forEach(c => {
        const card = document.createElement('div');
        card.className = 'panel-card';
        card.innerHTML = '<div class="title">' + c.name + '</div><div class="muted">' + c.desc + '</div>';
        const active = game.challenge && game.challenge.active === c.id;
        const done = game.challenge && Array.isArray(game.challenge.completed) && game.challenge.completed.includes(c.id);
        const btn = document.createElement('button');
        if (active) {
          btn.textContent = 'Active';
          btn.disabled = true;
        } else if (done) {
          btn.textContent = 'Completed';
          btn.disabled = true;
        } else {
          btn.textContent = 'Activate Challenge';
          btn.onclick = () => { activateChallenge(c.id); renderChallenges(); };
        }
        card.appendChild(btn);
        challengePanel.appendChild(card);
      });
    }

    function renderCosmetics() {
      if (!cosmeticPanel) return;
      cosmeticPanel.innerHTML = '';
      COSMETIC_UPGRADES.forEach(c => {
        const unlocked = c.unlock(game);
        const card = document.createElement('div');
        card.className = 'panel-card';
        card.innerHTML = '<div class="title">' + c.name + '</div><div class="muted">' + c.desc + '</div>';
        const btn = document.createElement('button');
        if (!unlocked) {
          btn.textContent = 'Locked';
          btn.disabled = true;
        } else {
          const active = game.cosmetics && game.cosmetics.active === c.id;
          btn.textContent = active ? 'Active' : 'Activate';
          btn.onclick = () => {
            if (!game.cosmetics) game.cosmetics = { unlocked: [], active: null };
            game.cosmetics.active = active ? null : c.id;
            renderCosmetics();
            renderTower();
          };
        }
        card.appendChild(btn);
        cosmeticPanel.appendChild(card);
      });
    }

    function renderRuneEtching() {
      if (!runeEtchingPanel) return;
      ensureRunePattern();
      const state = game.runeEtching || { selected: [], attempts: 0 };
      runeEtchingPanel.innerHTML = '';
      const info = document.createElement('div');
      info.className = 'stat';
      const buffLeft = Math.max(0, (game.runeEtchingBuffEnd || 0) - Date.now());
      const maxAttempts = runeEtchingMaxAttempts();
      info.innerHTML = 'Attempts today: ' + (state.attempts || 0) + '/' + maxAttempts +
        '<br>Selected: ' + (state.selected && state.selected.length ? state.selected.join(', ') : '') +
        (buffLeft > 0 ? '<br>Buff active: ' + Math.ceil(buffLeft / 1000) + 's' : '');
      runeEtchingPanel.appendChild(info);
      const grid = document.createElement('div');
      grid.className = 'rune-grid';
      RUNE_SYMBOLS.forEach(r => {
        const btn = document.createElement('button');
        btn.className = 'rune-btn';
        btn.textContent = r;
        btn.disabled = (state.selected && state.selected.length >= 3) || (state.attempts || 0) >= maxAttempts;
        btn.onclick = () => {
          if (!state.selected) state.selected = [];
          if (state.selected.length >= 3) return;
          state.selected.push(r);
          game.runeEtching = state;
          renderRuneEtching();
        };
        grid.appendChild(btn);
      });
      runeEtchingPanel.appendChild(grid);
      if (state.selected && state.selected.length >= 3) {
        const btn = document.createElement('button');
        btn.textContent = 'Etch the rune';
        btn.onclick = () => { attemptRuneEtching(); renderRuneEtching(); };
        runeEtchingPanel.appendChild(btn);
      }
    }

    function renderCrafting() {
      if (!craftingPanel) return;
      craftingPanel.innerHTML = '';
      CRAFTING_RECIPES.forEach(r => {
        if (typeof r.unlockCheck === 'function' && !r.unlockCheck()) return;
        const card = document.createElement('div');
        card.className = 'panel-card';
        card.innerHTML = '<div class="title">' + r.name + '</div><div class="muted">' + r.desc + '</div>' +
          '<div class="muted">Cost: ' + formatCost(r.cost) + '</div>';
        const btn = document.createElement('button');
        btn.textContent = 'Craft';
        const disabled = typeof r.disabled === 'function' ? r.disabled() : false;
        btn.disabled = !canAffordCost(r.cost) || disabled;
        btn.onclick = () => {
          if (!payCost(r.cost)) return;
          r.effect();
          renderLibrary();
        };
        card.appendChild(btn);
        craftingPanel.appendChild(card);
      });
    }

    function renderStoryPanel() {
      if (!storyPanel) return;
      storyPanel.innerHTML = '';
      STORY_ENTRIES.forEach(entry => {
        const unlocked = entry.unlock(game);
        const row = document.createElement('div');
        row.className = 'story-entry' + (unlocked ? '' : ' locked');
        row.innerHTML = '<strong>' + entry.title + '</strong>' + (unlocked ? '<div class="muted">' + entry.text + '</div>' : '<div class="muted">Locked</div>');
        storyPanel.appendChild(row);
      });
      const artifactHeader = document.createElement('div');
      artifactHeader.className = 'section-title';
      artifactHeader.textContent = 'Milestone Artifacts';
      storyPanel.appendChild(artifactHeader);
      ARTIFACTS.forEach(art => {
        const unlocked = art.unlock(game);
        const claimed = Array.isArray(game.milestonesClaimed) && game.milestonesClaimed.includes(art.id);
        const row = document.createElement('div');
        row.className = 'story-entry' + (unlocked ? '' : ' locked');
        row.innerHTML = '<strong>' + art.name + '</strong><div class="muted">' + art.desc + '</div>';
        const btn = document.createElement('button');
        if (!unlocked) {
          btn.textContent = 'Locked';
          btn.disabled = true;
        } else if (claimed) {
          btn.textContent = 'Claimed';
          btn.disabled = true;
        } else {
          btn.textContent = 'Claim';
          btn.onclick = () => { claimArtifact(art.id); renderStoryPanel(); renderUI(); };
        }
        row.appendChild(btn);
        storyPanel.appendChild(row);
      });
    }

    function renderTimeDilationStatus() {
      const active = game.active && game.active.timer > 0;
      const harvestActive = game.active && game.active.harvestTimer > 0;
      timeDilationStatus.style.display = active || harvestActive ? 'block' : 'none';
      if (!active && !harvestActive) return;
      const boost = (game.active.boostTD || 1) * (game.active.boostHarvest || 1);
      if (active) {
        const dur = (game.active.duration && game.active.duration > 0) ? game.active.duration : game.active.timer;
        const frac = Math.max(0, Math.min(1, game.active.timer / dur));
        timeDilationFill.style.width = (frac * 100).toFixed(2) + '%';
        timeDilationTime.textContent = Math.max(0, game.active.timer).toFixed(1) + 's left';
        timeDilationBoost.textContent = 'Boost: x' + boost.toFixed(2);
      } else {
        const dur = game.active.harvestDuration || 5;
        const frac = Math.max(0, Math.min(1, game.active.harvestTimer / dur));
        timeDilationFill.style.width = (frac * 100).toFixed(2) + '%';
        timeDilationTime.textContent = 'Arcane Harvest: ' + game.active.harvestTimer.toFixed(1) + 's';
        timeDilationBoost.textContent = 'Boost: x' + boost.toFixed(2);
      }
    }

    function formatSwapCooldown() {
      const cost = spellSwapFocusCost();
      if (cost <= 0) return 'Swap requires focus';
      const ritualTag = game.ritualOfBindingNextSwapHalved ? ' (Ritual of Binding)' : '';
      return 'Swap cost: ' + formatNum(cost) + ' focus' + ritualTag;
    }

    function updateGrimoireHeader() {
      if (!grimoireSpellSlotsEl || !grimoireSwapTimerEl) return;
      updateGrimoireHeader();
      const usedSlots = (game.memorizedSpells || []).length;
      const totalSlots = maxSpellSlots();
    }

    function renderSpells() {
      const usedSlots = (game.memorizedSpells || []).length;
      const totalSlots = maxSpellSlots();
      grimoireSpellSlotsEl.textContent = 'Spell slots: ' + usedSlots + ' / ' + totalSlots;
      grimoireSwapTimerEl.textContent = formatSwapCooldown();

      activeSpellsDiv.innerHTML = '';
      passiveSpellsDiv.innerHTML = '';

      const tdActive = !!(game.active && game.active.timer > 0);
      const harvestActive = !!(game.active && game.active.harvestTimer > 0);
      const floors = totalFloors();
      const swapReady = canSwapSpell();

      const floorLockedActive = ACTIVE_SPELLS.filter(s => !isSpellUnlocked(s, true) && !s.unlockCheck && typeof s.unlock === 'number');
      floorLockedActive.sort((a, b) => (a.unlock || 0) - (b.unlock || 0));
      const nextLockedActive = floorLockedActive[0];
      const activeToShow = ACTIVE_SPELLS.filter(s => isSpellUnlocked(s, true) || s === nextLockedActive);
      const activeSort = (s) => {
        if (typeof s.sortKey === 'number') return s.sortKey;
        if (s.unlockCheck && !isSpellUnlocked(s, true)) return 900;
        return typeof s.unlock === 'number' ? s.unlock : 999;
      };
      activeToShow.sort((a, b) => activeSort(a) - activeSort(b));

      const leylineSurgeActive = !!(game.active && game.active.leylineTapTimer > 0);
      activeToShow.forEach(s => {
        const spellId = getSpellId(s, true);
        const memorized = isMemorized(spellId);
        const hideWhenActive = s.hideWhenActive && ((s.name === 'Time Dilation' && tdActive) || (s.harvestKey && harvestActive) || (s.leylineTapKey && leylineSurgeActive));
        if (hideWhenActive) return;
        const onSpellCooldown = s.name === 'Time Dilation' && game.active && game.active.cooldown > 0;
        const cooldownKey = s.cooldownKey;
        const cooldownMs = s.cooldownMs || 0;
        const cooldownEnd = cooldownKey ? (game[cooldownKey] || 0) : 0;
        const cooldownRem = Math.max(0, (cooldownEnd - Date.now()) / 1000);
        const onCooldown = cooldownRem > 0;
        if (onSpellCooldown) return;

        const wrap = document.createElement('div');
        wrap.className = 'spell-row';
        const btn = document.createElement('button');
        btn.textContent = s.name;
        const unlocked = isSpellUnlocked(s, true);
        if (!unlocked) {
          btn.disabled = true;
          const hint = document.createElement('span');
          hint.className = 'unlock-hint';
          hint.textContent = spellUnlockHint(s);
          hint.style.display = 'block';
          btn.appendChild(hint);
          wrap.appendChild(btn);
        } else if (memorized) {
          const desc = document.createElement('span');
          desc.className = 'desc';
          const cooldownText = onCooldown ? ('Cooldown ' + cooldownRem.toFixed(1) + 's') : '';
          const detail = [s.costText ? s.costText() : '', cooldownText].filter(Boolean).join('  ');
          desc.innerHTML = s.desc + '<br><span class="detail">' + detail + '</span>';
          btn.appendChild(desc);
          btn.onclick = () => s.effect();
          const lowFocus = (s.focusCost != null && (game.focus || 0) < s.focusCost);
          btn.disabled = lowFocus || onCooldown;
          if (cooldownMs > 0) {
            const overlay = document.createElement('div');
            overlay.className = 'cooldown-overlay';
            const frac = onCooldown ? (1 - Math.min(1, (cooldownRem * 1000) / cooldownMs)) : 1;
            overlay.style.width = (frac * 100).toFixed(2) + '%';
            btn.appendChild(overlay);
          }
          const forgetBtn = document.createElement('button');
          forgetBtn.textContent = 'Forget';
          forgetBtn.className = 'spell-slot-btn';
          forgetBtn.disabled = !swapReady;
          forgetBtn.onclick = (e) => { e.stopPropagation(); forgetSpell(spellId); };
          wrap.appendChild(btn);
          wrap.appendChild(forgetBtn);
        } else {
          const desc = document.createElement('span');
          desc.className = 'desc';
          desc.innerHTML = s.desc + '<br><span class="detail">Not memorized</span>';
          btn.appendChild(desc);
          btn.disabled = true;
          const memBtn = document.createElement('button');
          memBtn.textContent = 'Memorize';
          memBtn.className = 'spell-slot-btn';
          memBtn.disabled = !swapReady || usedSlots >= totalSlots;
          memBtn.onclick = (e) => { e.stopPropagation(); memorizeSpell(spellId); };
          wrap.appendChild(btn);
          wrap.appendChild(memBtn);
        }
        activeSpellsDiv.appendChild(wrap);
      });

      const floorLockedPassive = PASSIVE_SPELLS.filter(s => !isSpellUnlocked(s, false) && !s.unlockCheck && typeof s.unlock === 'number');
      floorLockedPassive.sort((a, b) => (a.unlock || 0) - (b.unlock || 0));
      const nextLockedPassive = floorLockedPassive[0];
      const passiveToShow = PASSIVE_SPELLS.filter(s => isSpellUnlocked(s, false) || s === nextLockedPassive);
      const passiveSort = (s) => {
        if (s.unlockCheck && !isSpellUnlocked(s, false)) return 900;
        return typeof s.unlock === 'number' ? s.unlock : 999;
      };
      passiveToShow.sort((a, b) => passiveSort(a) - passiveSort(b));

      passiveToShow.forEach(s => {
        const spellId = getSpellId(s, false);
        const memorized = isMemorized(spellId);
        const wrap = document.createElement('div');
        wrap.className = 'spell-row';
        const btn = document.createElement('button');
        btn.textContent = s.name;
        const unlocked = isSpellUnlocked(s, false);
        if (!unlocked) {
          btn.disabled = true;
          const hint = document.createElement('span');
          hint.className = 'unlock-hint';
          hint.textContent = spellUnlockHint(s);
          hint.style.display = 'block';
          btn.appendChild(hint);
          wrap.appendChild(btn);
        } else if (memorized) {
          const level = s.key ? (game.passive[s.key] ?? 0) : 0;
          const cost = s.cost ? s.cost() * SCALE : 0;
          const desc = document.createElement('span');
          desc.className = 'desc';
          desc.innerHTML = s.desc + '<br><span class="detail">Level ' + level + '  Cost ' + formatNum(cost) + ' mana</span>';
          btn.appendChild(desc);
          btn.onclick = () => {
            const c = s.cost() * SCALE;
            if (game.mana >= c) {
              game.mana -= c;
              s.effect();
              renderAll();
            }
          };
          const forgetBtn = document.createElement('button');
          forgetBtn.textContent = 'Forget';
          forgetBtn.className = 'spell-slot-btn';
          forgetBtn.disabled = !swapReady;
          forgetBtn.onclick = (e) => { e.stopPropagation(); forgetSpell(spellId); };
          wrap.appendChild(btn);
          wrap.appendChild(forgetBtn);
        } else {
          const level = s.key ? (game.passive[s.key] ?? 0) : 0;
          const desc = document.createElement('span');
          desc.className = 'desc';
          desc.innerHTML = s.desc + '<br><span class="detail">Level ' + level + '  Not memorized</span>';
          btn.appendChild(desc);
          btn.disabled = true;
          const memBtn = document.createElement('button');
          memBtn.textContent = 'Memorize';
          memBtn.className = 'spell-slot-btn';
          memBtn.disabled = !swapReady || (game.memorizedSpells || []).length >= maxSpellSlots();
          memBtn.onclick = (e) => { e.stopPropagation(); memorizeSpell(spellId); };
          wrap.appendChild(btn);
          wrap.appendChild(memBtn);
        }
        passiveSpellsDiv.appendChild(wrap);
      });
    }

    function anyActiveSpellCooldown() {
      return activeCooldownCount() > 0;
    }

    function towerTier(f) { if (f >= 40) return 4; if (f >= 30) return 3; if (f >= 10) return 2; return 1; }
    function renderTower() {
      towerContainer.innerHTML = '';
      const sr = game.specialRooms || {};
      const blocks = [{ type: 'Foundation' }];
      const turrets = [];
      for (let i = 0; i < (game.stairs || 0); i++) {
        const side = i % 3 === 1 ? 'side-left' : (i % 3 === 2 ? 'side-right' : '');
        blocks.push({ type: 'Stairs', side });
      }
      SPECIAL_ROOM_NAMES.forEach(name => {
        if (!sr[name] || !sr[name].built) return;
        if (name === 'Turret') {
          turrets.push({ type: name, level: sr[name].level || 1 });
          return;
        }
        blocks.push({ type: name, level: sr[name].level || 1, side: blocks.length % 2 ? 'side-right' : 'side-left' });
      });
      blocks.forEach((b, i) => {
        const el = document.createElement('div');
        const height = i + 1;
        const isTop = i === blocks.length - 1;
        const addCrenel = isTop && height >= 6;
        const addTurrets = isTop && height >= 14;
        const tier = towerTier(height);
        const foundationClass = b.type === 'Foundation' ? ' foundation' : '';
        el.className = 'tower-block tier-' + tier + foundationClass + (b.side ? ' ' + b.side : '');
        const cosmetic = COSMETIC_UPGRADES.find(c => game.cosmetics && game.cosmetics.active === c.id);
        if (cosmetic && cosmetic.className) el.classList.add(cosmetic.className);
        const label = (b.type === 'Foundation') ? 'Foundation' : (b.level ? b.type + ' Lv.' + b.level : b.type);
        const topper = (addCrenel || addTurrets)
          ? '<div class="tower-topper">' +
              (addCrenel ? '<div class="tower-crenel"></div>' : '') +
              (addTurrets ? '<div class="tower-turrets"><div class="turret left"></div><div class="turret right"></div></div>' : '') +
            '</div>'
          : '';
        // windows: show more as the tower grows (keeps silhouette clean, adds detail)
        const windowCount = Math.min(6, Math.max(0, Math.floor(height / 6)));
        let windowsHtml = '';
        if (windowCount > 0) {
          const win = [];
          for (let w = 0; w < windowCount; w++) win.push('<div class="tower-window"></div>');
          windowsHtml = '<div class="tower-windows">' + win.join('') + '</div>';
        }
        el.innerHTML = topper + windowsHtml + '<div class="room">' + label + '</div>';
        if (b.type === 'Foundation') {
          el.style.cursor = 'pointer';
          el.title = 'Foundation: the base of your tower.';
          el.onclick = openFoundationDetail;
        } else if (b.type !== 'Stairs' && ROOMS[b.type]) {
          el.style.cursor = 'pointer';
          el.dataset.room = b.type;
          el.title = ROOMS[b.type].desc || '';
          el.onclick = () => openRoomDetail(b.type);
        } else if (b.type === 'Stairs' && ROOMS.Stairs) el.title = ROOMS.Stairs.desc || '';
        towerContainer.appendChild(el);
      });
      if (turrets.length > 0) {
        const step = 46;
        const baseHeight = Math.max(3, Math.floor(blocks.length * 0.55));
        turrets.forEach((t, i) => {
          const turret = document.createElement('div');
          turret.className = 'tower-turret ' + (i % 2 ? 'side-left' : 'side-right');
          turret.style.bottom = (baseHeight * step) + 'px';
          turret.title = ROOMS.Turret ? ROOMS.Turret.desc : 'Turret';
          turret.onclick = () => openRoomDetail('Turret');
          const cosmetic = COSMETIC_UPGRADES.find(c => game.cosmetics && game.cosmetics.active === c.id);
          if (cosmetic && cosmetic.className) turret.classList.add(cosmetic.className);
          towerContainer.appendChild(turret);
        });
      }
    }

    function renderRoomSummary() {
      const sr = game.specialRooms || {};
      let html = '<strong>Rooms</strong><br>';
      html += 'Foundation<br><span class="cost">The base of your tower. No bonuses.</span><br>';
      if ((game.stairs || 0) > 0) html += 'Stairs x' + game.stairs + '<br><span class="cost">' + (ROOMS.Stairs && ROOMS.Stairs.desc) + '</span><br>';
      SPECIAL_ROOM_NAMES.forEach(name => {
        const r = sr[name];
        if (r && r.built) {
          const level = r.level || 1;
          html += name + ' (Lv.' + level + ')<br><span class="cost">' + (ROOMS[name] && ROOMS[name].desc) + '</span><br>';
        }
      });
      roomSummary.innerHTML = html || 'No rooms yet.';
    }

    function doPrestige(soft) {
      const savedMana = game.wardOfPreservationUsed ? game.mana * 0.05 : 0;
      const hallLvl = countRooms('Hall of Preservation');
      const savedFloorsKept = hallLvl >= 1 ? Math.floor(totalFloors() * PRESTIGE_KEEP_FLOORS_PCT) : 0;
      const keptFollowers = Math.floor(totalFollowers() * 0.25);
      game.stats.totalFloorsEver = (game.stats.totalFloorsEver || 0) + totalFloors();
      const fullPrestige = !soft;
      if (fullPrestige) game.prestigeTokens = (game.prestigeTokens || 0) + 1;
      const choice = game.prestigeTokenChoice;
      const keepManaFont = fullPrestige && choice === 'font' && game.prestigeTokens >= 1;
      const keepStudyPct = fullPrestige && choice === 'study' && game.prestigeTokens >= 1;
      const keepRelic = fullPrestige && choice === 'relic' && game.prestigeTokens >= 1 && (game.relics || []).length > 0;
      if (keepManaFont) game.prestigeTokens--;
      if (keepStudyPct) game.prestigeTokens--;
      if (keepRelic) game.prestigeTokens--;
      const keptReservoir = keepStudyPct ? Math.floor(manaReservoirLevel() * 0.05) : 0;
      const keptEtching = keepStudyPct ? Math.floor(spellEtchingLevel() * 0.05) : 0;
      const relicKept = keepRelic ? [game.relics[0]] : [];
      game.prestige = soft ? game.prestige : game.prestige + 1;
      game.softPrestige = soft ? game.softPrestige + 1 : game.softPrestige;
      game.mana = savedMana;
      game.manaFonts = keepManaFont ? 1 : 0;
      game.followers = { novice: keptFollowers, acolyte: 0, sage: 0 };
      game.reputation = Math.max(0, (game.reputation || 0) - 10);
      game.followerAssignments = initialFollowerAssignments();
      game.followerProgress = 0;
      game.promotionProgress = { novice: 0, acolyte: 0 };
      game.scoutingProgress = 0;
      game.gold = 0;
      game.essence = initialEssence();
      game.wards = maxWards();
      game.specialRooms = initialSpecialRooms();
      game.memorizedSpells = (game.memorizedSpells || []).slice(0, maxSpellSlots());
      game.stairs = 0;
      game.floorsKept = savedFloorsKept;
      game.passive = { arcane: 0, astral: 0, conduit: 0, towerBond: 0, staminaWell: 0, spellEcho: 0, focusFlow: 0, manaReservoir: 0, ritualMastery: 0, aetherFlux: 0, anchoredRituals: 0, luckyClick: 0 };
      game.active = {
        boost: 1,
        boostTD: 1,
        boostHarvest: 1,
        timer: 0,
        duration: 0,
        cooldown: 0,
        harvestTimer: 0,
        harvestDuration: 0,
        leylineTapTimer: 0,
        leylineTapPct: 0,
        runeTimer: 0,
        runeStacks: 0,
        focusCondenserTimer: 0,
        spellCostDiscountTimer: 0,
        spellCostDiscountPct: 0,
        overclockTimer: 0,
        overclockMult: 1,
        worldweaveTimer: 0,
        convergenceTimer: 0,
        paradoxTimer: 0,
        overchargeTimer: 0,
        overchargeMult: 1,
        concessionTimer: 0,
        comboTimer: 0,
        comboMult: 1,
        overchargeCharge: 0,
        flameSurgeTimer: 0,
        frostSlowTimer: 0,
      };
      game.studyCount = keptReservoir;
      game.transcribeBonusPct = keptEtching;
      if (game.research && game.research.levels) {
        game.research.levels.manaReservoir = keptReservoir;
        game.research.levels.spellEtching = keptEtching;
      }
      game.stamina = maxStamina();
      game.wardOfPreservationUsed = false;
      game.prestigeTokenChoice = null;
      game.meditateStacks = 0;
      game.scryLockedRoom = null;
      game.ritualBuffEnd = 0;
      game.ritualWindowBonusPct = 0;
      game.ritualWindowBonusEnd = 0;
      game.attuneDiscount = 0;
      game.relics = relicKept;
      game.relicDraft = [];
      game.relicDraftSeen = false;
      game.sigilStacks = 0;
      game.relicHuntCooldownEnd = 0;
      game.transmutateCooldownEnd = 0;
      game.nextFloorDuplicate = null;
      game.nextFloorCursed = false;
      game.nextFloorBonus = false;
      game.nextFloorDiscountPct = 0;
      game.nextFloorOffers = null;
      game.nextFloorRolled = false;
      game.stats.timeDilationCasts = 0;
      game.stats.arcaneHarvestCasts = 0;
      game.stats.transmutateCasts = 0;
      game.stats.focusSurgeCasts = 0;
      game.stats.vigorInfusionCasts = 0;
      game.runeEtchingBuffEnd = 0;
      game.encounter = initialEncounterState();
      game.contracts = [];
      game.followerEvent = null;
      game.nextFollowerEventAt = 0;
      game.spellSynergy = { lastElement: null, lastCastAt: 0, chain: [] };
      renderAll();
      playSound('milestone');
    }

    // -------------------- ROOM MODAL --------------------
    function openRoomSelect() {
      roomModal.style.display = 'flex';
      roomChoices.innerHTML = '';
      const sr = game.specialRooms || {};
      if (!game.nextFloorRolled && totalFloors() >= 1) {
        if (Math.random() < 0.12) game.nextFloorCursed = true;
        else if (Math.random() < 0.12) game.nextFloorBonus = true;
        game.nextFloorRolled = true;
      }
      const cost = effectiveFloorCost();
      const floorStaminaCost = effectiveFloorStaminaCost();
      const suffix = game.nextFloorCursed ? ' (Cursed: 1.5 cost, 2 effect)' : (game.nextFloorBonus ? ' (Bonus: free)' : '');
      const levelGain = game.nextFloorCursed ? 2 : 1;
      const addCard = (name) => {
        const info = ROOMS[name];
        if (!info) return;
        const card = document.createElement('div');
        card.className = 'room-card';
        const built = sr[name] && sr[name].built;
        let label = built ? ('Duplicate: +' + levelGain + ' lvl to ' + name) : name;
        if (suffix) label += suffix;
        card.textContent = label;
        const tooltip = document.createElement('span');
        tooltip.className = 'tooltip';
        tooltip.textContent = info.desc;
        card.appendChild(tooltip);
        if (!info.unlock()) {
          card.classList.add('disabled');
          const hint = document.createElement('span');
          hint.className = 'unlock-hint';
          hint.textContent = 'Unlocks at ' + info.unlockFloors + ' floors';
          card.appendChild(hint);
        } else {
          card.onclick = () => {
            if (game.mana < cost || game.stamina < floorStaminaCost) {
              showToast('Need more resources', 'This floor costs ' + formatNum(cost) + ' mana and ' + formatNum(Math.floor(floorStaminaCost)) + ' stamina.');
              return;
            }
            game.mana -= cost;
            game.stamina -= floorStaminaCost;
            if (!sr[name]) game.specialRooms[name] = { built: false, level: 0 };
            if (built) {
              sr[name].level = (sr[name].level || 1) + levelGain;
              game.stairs++;
            } else {
              game.specialRooms[name].built = true;
              game.specialRooms[name].level = levelGain;
            }
            game.nextFloorCursed = false;
            game.nextFloorBonus = false;
            game.nextFloorDiscountPct = 0;
            game.nextFloorOffers = null;
            game.nextFloorRolled = false;
            game.scryLockedRoom = null;
            roomModal.style.display = 'none';
            renderAll();
          };
        }
        roomChoices.appendChild(card);
      };
      const unlocked = unlockedRoomNames();
      if (unlocked.length === 0) {
        roomChoices.innerHTML = '<div class="stat">No rooms available yet.</div>';
        return;
      }
      if (!Array.isArray(game.nextFloorOffers) || game.nextFloorOffers.length === 0) {
        const offered = [];
        if (game.scryLockedRoom && unlocked.includes(game.scryLockedRoom)) {
          offered.push(game.scryLockedRoom);
        }
        const pool = unlocked.filter(name => !offered.includes(name));
        while (offered.length < 3 && pool.length > 0) {
          const idx = Math.floor(Math.random() * pool.length);
          offered.push(pool.splice(idx, 1)[0]);
        }
        game.nextFloorOffers = offered;
      }
      (game.nextFloorOffers || []).forEach(name => addCard(name));
    }

    let currentRoomDetailName = null;
    function openFoundationDetail() {
      currentRoomDetailName = 'Foundation';
      roomDetailTitle.textContent = 'Foundation';
      roomDetailDesc.textContent = 'The bedrock of your mage tower. It provides stability but no bonuses.';
      roomDetailLevel.textContent = '0';
      roomDetailUpgradeBtn.style.display = 'none';
      roomDetailUpgradeBtn.disabled = true;
      roomDetailModal.style.display = 'flex';
    }
    function openRoomDetail(roomName) {
      const info = ROOMS[roomName];
      const r = (game.specialRooms || {})[roomName];
      if (!info || !r || !r.built) return;
      roomDetailUpgradeBtn.style.display = '';
      roomDetailUpgradeBtn.disabled = false;
      currentRoomDetailName = roomName;
      roomDetailTitle.textContent = roomName;
      roomDetailDesc.textContent = info.desc || '';
      const lvl = r.level || 1;
      roomDetailLevel.textContent = lvl;
      const refreshUpgradeBtn = () => {
        const cost = upgradeCost(roomName);
        roomDetailUpgradeBtn.innerHTML = 'Upgrade<span class="cost">Cost: ' + formatNum(cost) + ' mana (Shift: x10, Ctrl: max)</span>';
        roomDetailUpgradeBtn.disabled = (game.mana || 0) < cost;
      };
      refreshUpgradeBtn();
      roomDetailUpgradeBtn.onclick = (e) => {
        const isMax = e && (e.ctrlKey || e.metaKey);
        const want = isMax ? 100000 : (e && e.shiftKey) ? 10 : 1;
        let done = 0;
        for (let i = 0; i < want; i++) {
          const c = upgradeCost(roomName);
          if ((game.mana || 0) < c) break;
          game.mana -= c;
          r.level = (r.level || 1) + 1;
          done++;
        }
        if (done > 0) {
          playSound('click');
          roomDetailLevel.textContent = r.level;
          renderAll();
        }
        refreshUpgradeBtn();
      };
      roomDetailModal.style.display = 'flex';
    }
    function closeRoomDetail() {
      roomDetailModal.style.display = 'none';
      roomDetailUpgradeBtn.style.display = '';
      currentRoomDetailName = null;
    }
    roomDetailClose.onclick = closeRoomDetail;
    roomDetailModal.addEventListener('click', (e) => { if (e.target === roomDetailModal) closeRoomDetail(); });
    roomDetailModal.querySelector('.modal-content').addEventListener('click', (e) => e.stopPropagation());
    if (relicModal) {
      relicModal.addEventListener('click', (e) => { if (e.target === relicModal) relicModal.style.display = 'none'; });
      const relicContent = relicModal.querySelector('.modal-content');
      if (relicContent) relicContent.addEventListener('click', (e) => e.stopPropagation());
    }

    // -------------------- BUTTONS --------------------
    manaFontBtn.onclick = (e) => {
      const maxN = maxAffordableManaFonts();
      const wantN = (e && (e.ctrlKey || e.metaKey)) ? maxN : (e && e.shiftKey) ? Math.min(10, maxN) : Math.min(1, maxN);
      if (wantN <= 0) return;
      const bought = buyManaFonts(wantN);
      if (bought > 0) {
        playSound('click');
        renderAll();
      }
    };
    towerBtn.onclick = openRoomSelect;

    function closeSettings() { settingsModal.style.display = 'none'; }
    settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) closeSettings(); });
    settingsModal.querySelector('.modal-content').addEventListener('click', (e) => e.stopPropagation());

    function setSettingsTab(tab) {
      const onPrefs = tab === 'prefs';
      const onGlossary = tab === 'glossary';
      const onKeys = tab === 'keys';
      if (settingsTabPrefs) {
        settingsTabPrefs.classList.toggle('active', onPrefs);
        settingsTabPrefs.setAttribute('aria-selected', String(onPrefs));
      }
      if (settingsTabGlossary) {
        settingsTabGlossary.classList.toggle('active', onGlossary);
        settingsTabGlossary.setAttribute('aria-selected', String(onGlossary));
      }
      if (settingsTabKeys) {
        settingsTabKeys.classList.toggle('active', onKeys);
        settingsTabKeys.setAttribute('aria-selected', String(onKeys));
      }
      if (settingsPagePrefs) settingsPagePrefs.classList.toggle('hidden', !onPrefs);
      if (settingsPageGlossary) settingsPageGlossary.classList.toggle('hidden', !onGlossary);
      if (settingsPageKeys) settingsPageKeys.classList.toggle('hidden', !onKeys);
      if (!game.tutorial || typeof game.tutorial !== 'object') game.tutorial = { clicked: false, done: false, completedToast: false };
      if (onKeys) game.tutorial.keysSeen = true;
      if (onGlossary) game.tutorial.glossarySeen = true;
      if (onKeys) renderKeybinds();
      renderTutorialHints();
    }

    function openPanel(id) {
      document.querySelectorAll('.panel-modal').forEach(m => m.classList.remove('show'));
      document.querySelectorAll('#bottomNav .tab').forEach(t => t.classList.remove('active'));
      const modal = document.getElementById(id);
      const tab = document.querySelector('#bottomNav .tab[data-panel="' + id + '"]');
      if (modal) modal.classList.add('show');
      if (tab) tab.classList.add('active');
      if (!game.tutorial || typeof game.tutorial !== 'object') game.tutorial = { clicked: false, done: false, completedToast: false };
      if (id === 'towerModal') game.tutorial.towerOpened = true;
      if (id === 'libraryModal') game.tutorial.libraryOpened = true;
      if (id === 'observatoryModal') game.tutorial.observatoryOpened = true;
      if (id === 'activitiesModal') game.tutorial.activitiesOpened = true;
      renderTutorialHints();
    }
    function closePanel(id) {
      const modal = document.getElementById(id);
      const tab = document.querySelector('#bottomNav .tab[data-panel="' + id + '"]');
      if (modal) modal.classList.remove('show');
      if (tab) tab.classList.remove('active');
    }
    document.querySelectorAll('#bottomNav .tab').forEach(tab => {
      tab.addEventListener('click', () => {
        if (tab.classList.contains('tab-locked')) {
          const panelId = tab.getAttribute('data-panel');
          if (panelId === 'ascensionModal') showToast('Ascension', 'Unlocks at ' + ASCENSION_TAB_UNLOCK + ' floors.');
          else if (panelId === 'relicsModal') showToast('Relics', 'Claim your first relic to unlock this tab.');
          else if (panelId === 'academyModal') showToast('Academy', 'Unlocks at ' + FOLLOWER_THRESHOLDS.academy + ' followers.');
          else if (panelId === 'libraryModal') showToast('Library', 'Unlocks at ' + FOLLOWER_THRESHOLDS.library + ' followers.');
          else if (panelId === 'observatoryModal') showToast('Observatory', 'Unlocks at ' + FOLLOWER_THRESHOLDS.observatory + ' followers.');
          else showToast('Locked', 'This tab is currently locked.');
          return;
        }
        const panelId = tab.getAttribute('data-panel');
        const modal = document.getElementById(panelId);
        if (modal && modal.classList.contains('show')) closePanel(panelId);
        else openPanel(panelId);
      });
    });

    function closeAllOverlays() {
      document.querySelectorAll('.panel-modal').forEach(m => m.classList.remove('show'));
      document.querySelectorAll('#bottomNav .tab').forEach(t => t.classList.remove('active'));
      if (roomModal) roomModal.style.display = 'none';
      if (relicModal) relicModal.style.display = 'none';
      if (settingsModal) settingsModal.style.display = 'none';
      if (statsModal) statsModal.style.display = 'none';
      if (introModal) introModal.style.display = 'none';
      if (roomDetailModal) roomDetailModal.style.display = 'none';
      if (loreTip) loreTip.style.display = 'none';
    }
    function togglePanelById(id) {
      const modal = document.getElementById(id);
      if (!modal) return;
      if (modal.classList.contains('show')) closePanel(id);
      else openPanel(id);
    }
    function normalizeKeyEvent(e) {
      if (e.key === 'Escape') return 'esc';
      if (e.key === '?' || (e.key === '/' && e.shiftKey)) return '?';
      if (e.key && e.key.length === 1) return e.key.toLowerCase();
      return null;
    }
    document.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      const tag = (e.target && e.target.tagName) ? String(e.target.tagName).toLowerCase() : '';
      if (tag === 'input' || tag === 'textarea') return;

      if (awaitingRebind) {
        const nextKey = normalizeKeyEvent(e);
        if (!nextKey) return;
        e.preventDefault();
        e.stopPropagation();
        const binds = ensureKeybinds();
        binds[awaitingRebind] = nextKey;
        awaitingRebind = null;
        renderKeybinds();
        renderTutorialHints();
        return;
      }

      const k = normalizeKeyEvent(e);
      if (!k) return;
      const binds = ensureKeybinds();
      if (k === binds.close) { closeAllOverlays(); return; }
      if (k === binds.activities) togglePanelById('activitiesModal');
      else if (k === binds.grimoire) togglePanelById('grimoireModal');
      else if (k === binds.tower) togglePanelById('towerModal');
      else if (k === binds.ascension) {
        if (ascensionTab && ascensionTab.classList.contains('tab-locked')) {
          showToast('Ascension', 'Unlocks at ' + ASCENSION_TAB_UNLOCK + ' floors.');
          return;
        }
        togglePanelById('ascensionModal');
      }
      else if (k === binds.relics) {
        if (relicTab && relicTab.classList.contains('tab-locked')) {
          showToast('Relics', 'Claim your first relic to unlock this tab.');
          return;
        }
        togglePanelById('relicsModal');
      }
      else if (k === binds.settings) {
        if (settingsModal) {
          const open = settingsModal.style.display !== 'flex';
          settingsModal.style.display = open ? 'flex' : 'none';
          if (open) {
            setSettingsTab('prefs');
            if (!game.tutorial || typeof game.tutorial !== 'object') game.tutorial = { clicked: false, done: false, completedToast: false };
            game.tutorial.settingsOpened = true;
            renderTutorialHints();
          }
        }
      }
      else if (k === binds.help) { if (introModal) introModal.style.display = 'flex'; }
      else if (k === binds.manaFont) { manaFontBtn && manaFontBtn.click(); }
    });
    document.querySelectorAll('.panel-modal').forEach(modal => {
      modal.addEventListener('click', (e) => { if (e.target === modal) closePanel(modal.id); });
    });
    document.querySelectorAll('.panel-content').forEach(content => {
      content.addEventListener('click', (e) => e.stopPropagation());
    });
    window.addEventListener('resize', () => { renderTutorialHints(); });

    soundCheckbox.checked = game.soundEnabled;
    soundCheckbox.onchange = () => { game.soundEnabled = soundCheckbox.checked; };
    renderKeybinds();

    if (tutorialCheckbox) {
      tutorialCheckbox.checked = !!game.settings.showTutorial;
      tutorialCheckbox.onchange = () => {
        game.settings.showTutorial = tutorialCheckbox.checked;
        renderTutorialHints();
      };
    }
    if (tutorialResetBtn) {
      tutorialResetBtn.onclick = () => {
        game.tutorial = { clicked: false, done: false, completedToast: false, settingsOpened: false, keysSeen: false, glossarySeen: false, libraryOpened: false, observatoryOpened: false, towerOpened: false, activitiesOpened: false };
        renderTutorialHints();
      };
    }
    if (loreCloseBtn) loreCloseBtn.onclick = (e) => { e.stopPropagation(); hideLoreTip(); };
    if (loreTip) loreTip.onclick = () => hideLoreTip();
    if (settingsTabPrefs) settingsTabPrefs.onclick = () => setSettingsTab('prefs');
    if (settingsTabGlossary) settingsTabGlossary.onclick = () => setSettingsTab('glossary');
    if (settingsTabKeys) settingsTabKeys.onclick = () => setSettingsTab('keys');
    if (settingsBtn) {
      settingsBtn.onclick = () => {
        settingsModal.style.display = 'flex';
        setSettingsTab('prefs');
        if (!game.tutorial || typeof game.tutorial !== 'object') game.tutorial = { clicked: false, done: false, completedToast: false };
        game.tutorial.settingsOpened = true;
        renderTutorialHints();
      };
    }

    document.getElementById('statsBtn').onclick = () => {
      statsModal.style.display = 'flex';
      const played = (game.stats.timePlayedMs || 0) / 1000;
      const mins = Math.floor(played / 60);
      const hours = Math.floor(mins / 60);
      const timeStr = hours ? hours + 'h ' + (mins % 60) + 'm' : mins + 'm';
      const maxFloors = game.stats.maxFloorsReached || 0;
      const maxMps = game.stats.maxManaPerSecReached || 0;
      const goalReached = game.stats.goalManaReached ? ' (Goal reached!)' : '';
      statsGrid.innerHTML =
        '<span>Total mana earned</span><span class="value">' + formatNum(game.stats.totalManaEarned || 0) + '</span>' +
        '<span>Total spells cast</span><span class="value">' + (game.stats.totalSpellsCast || 0) + '</span>' +
        '<span>Time played</span><span class="value">' + timeStr + '</span>' +
        '<span>High score: max floors</span><span class="value">' + maxFloors + '</span>' +
        '<span>High score: max mana/sec</span><span class="value">' + formatRate(maxMps) + '/s' + goalReached + '</span>' +
        '<span>Relics (current run)</span><span class="value">' + ((game.relics || []).length) + '</span>' +
        '<span>Sigil stacks</span><span class="value">' + (game.sigilStacks || 0) + '</span>' +
        '<span>Goal: ' + formatNum(GOAL_MANA_PER_SEC) + ' mana/sec</span><span class="value">' + (game.stats.goalManaReached ? 'Done' : '') + '</span>' +
        '<span>Ascension resets</span><span class="value">' + (game.ascension + (game.ascensionTier2 || 0)) + '</span>';
      achievementsList.innerHTML = '';
      ACHIEVEMENTS.forEach(a => {
        const got = (game.stats.achievements || []).includes(a.id);
        const line = document.createElement('div');
        line.style.marginBottom = '6px';
        line.innerHTML = (got ? '&#10003; ' : '&#9726; ') + '<strong>' + a.name + '</strong>: ' + a.desc + (a.reward ? ' (' + a.reward + ')' : '');
        line.style.opacity = got ? '1' : '0.6';
        achievementsList.appendChild(line);
      });
    };
    function closeStats() { statsModal.style.display = 'none'; }

    document.getElementById('exportBtn').onclick = () => {
      const json = JSON.stringify(game);
      navigator.clipboard.writeText(json).then(() => showToast('Export', 'Save copied to clipboard.')).catch(() => showToast('Export', 'Copy failed.'));
    };
    document.getElementById('importBtn').onclick = () => {
      const raw = prompt('Paste your save data:');
      if (!raw) return;
      try {
        const data = JSON.parse(raw);
        Object.assign(game, data);
        if (!game.stats) game.stats = { timeDilationCasts: 0, arcaneHarvestCasts: 0, leylineSurgeCasts: 0, focusSurgeCasts: 0, vigorInfusionCasts: 0, transmutateCasts: 0, manaCapHits: 0, zeroManaCasts: 0, totalManaEarned: 0, totalSpellsCast: 0, timePlayedMs: 0, achievements: [] };
        if (!game.passive || typeof game.passive !== 'object') game.passive = {};
        const passiveDefaults = { arcane: 0, astral: 0, conduit: 0, towerBond: 0, staminaWell: 0, spellEcho: 0, focusFlow: 0, manaReservoir: 0, ritualMastery: 0, aetherFlux: 0, anchoredRituals: 0, luckyClick: 0 };
        Object.keys(passiveDefaults).forEach(k => { if (typeof game.passive[k] !== 'number') game.passive[k] = passiveDefaults[k]; });
        if (!game.active) game.active = { boost: 1, boostTD: 1, boostHarvest: 1, timer: 0, duration: 0, cooldown: 0, harvestTimer: 0, harvestDuration: 0, leylineTapTimer: 0, leylineTapPct: 0, runeTimer: 0, runeStacks: 0, focusCondenserTimer: 0, spellCostDiscountTimer: 0, spellCostDiscountPct: 0, overclockTimer: 0, overclockMult: 1, worldweaveTimer: 0, convergenceTimer: 0, paradoxTimer: 0 };
        if (typeof game.active.boostTD !== 'number') game.active.boostTD = 1;
        if (typeof game.active.boostHarvest !== 'number') game.active.boostHarvest = 1;
        if (typeof game.active.leylineTapTimer !== 'number') game.active.leylineTapTimer = 0;
        if (typeof game.active.leylineTapPct !== 'number') game.active.leylineTapPct = 0;
        if (typeof game.active.runeTimer !== 'number') game.active.runeTimer = 0;
        if (typeof game.active.runeStacks !== 'number') game.active.runeStacks = 0;
        if (typeof game.active.focusCondenserTimer !== 'number') game.active.focusCondenserTimer = 0;
        if (typeof game.active.spellCostDiscountTimer !== 'number') game.active.spellCostDiscountTimer = 0;
        if (typeof game.active.spellCostDiscountPct !== 'number') game.active.spellCostDiscountPct = 0;
        if (typeof game.active.overclockTimer !== 'number') game.active.overclockTimer = 0;
        if (typeof game.active.overclockMult !== 'number') game.active.overclockMult = 1;
        if (typeof game.active.worldweaveTimer !== 'number') game.active.worldweaveTimer = 0;
        if (typeof game.active.convergenceTimer !== 'number') game.active.convergenceTimer = 0;
        if (typeof game.active.paradoxTimer !== 'number') game.active.paradoxTimer = 0;
        if (typeof game.studyCount !== 'number') game.studyCount = 0;
        if (typeof game.stamina !== 'number') game.stamina = 0;
        if (typeof game.focus !== 'number') game.focus = 0;
        if (!Array.isArray(game.relics)) game.relics = [];
        if (!Array.isArray(game.relicDraft)) game.relicDraft = [];
        if (typeof game.relicDraftSeen !== 'boolean') game.relicDraftSeen = false;
        if (typeof game.sigilStacks !== 'number') game.sigilStacks = 0;
        if (typeof game.relicHuntCooldownEnd !== 'number') game.relicHuntCooldownEnd = 0;
        game.relics = (game.relics || []).filter(id => RELIC_BY_ID[id]);
        game.relicDraft = (game.relicDraft || []).filter(id => RELIC_BY_ID[id]);
        if (typeof game.transmutateCooldownEnd !== 'number') game.transmutateCooldownEnd = 0;
        if (typeof game.manaSiphonCooldownEnd !== 'number') game.manaSiphonCooldownEnd = 0;
        if (typeof game.runeAccretionCooldownEnd !== 'number') game.runeAccretionCooldownEnd = 0;
        if (typeof game.staminaTransmuteCooldownEnd !== 'number') game.staminaTransmuteCooldownEnd = 0;
        if (typeof game.focusCondenserCooldownEnd !== 'number') game.focusCondenserCooldownEnd = 0;
        if (typeof game.leylineResonanceCooldownEnd !== 'number') game.leylineResonanceCooldownEnd = 0;
        if (typeof game.towerPulseCooldownEnd !== 'number') game.towerPulseCooldownEnd = 0;
        if (typeof game.chronoLoopCooldownEnd !== 'number') game.chronoLoopCooldownEnd = 0;
        if (typeof game.nexusOverclockCooldownEnd !== 'number') game.nexusOverclockCooldownEnd = 0;
        if (typeof game.worldweaveCooldownEnd !== 'number') game.worldweaveCooldownEnd = 0;
        if (typeof game.convergenceCooldownEnd !== 'number') game.convergenceCooldownEnd = 0;
        if (typeof game.paradoxCastCooldownEnd !== 'number') game.paradoxCastCooldownEnd = 0;
        if (typeof game.nextFloorDiscountPct !== 'number') game.nextFloorDiscountPct = 0;
        if (typeof game.transmutateCooldownEnd !== 'number') game.transmutateCooldownEnd = 0;
        if (!game.paragonSpent || typeof game.paragonSpent.manaPct !== 'number') game.paragonSpent = { manaPct: 0, spellEffect: 0, stamina: 0, focus: 0 };
        if (!game.settings || typeof game.settings !== 'object') game.settings = { showTutorial: true, keybinds: {} };
        if (typeof game.settings.showTutorial !== 'boolean') game.settings.showTutorial = true;
        ensureKeybinds();
        if (!game.tutorial || typeof game.tutorial !== 'object') game.tutorial = { clicked: false, done: false, completedToast: false, settingsOpened: false, keysSeen: false, glossarySeen: false, libraryOpened: false, observatoryOpened: false, towerOpened: false, activitiesOpened: false };
        if (typeof game.tutorial.clicked !== 'boolean') game.tutorial.clicked = false;
        if (typeof game.tutorial.done !== 'boolean') game.tutorial.done = false;
        if (typeof game.tutorial.completedToast !== 'boolean') game.tutorial.completedToast = false;
        if (typeof game.tutorial.settingsOpened !== 'boolean') game.tutorial.settingsOpened = false;
        if (typeof game.tutorial.keysSeen !== 'boolean') game.tutorial.keysSeen = false;
        if (typeof game.tutorial.glossarySeen !== 'boolean') game.tutorial.glossarySeen = false;
        if (typeof game.wasManaCapped !== 'boolean') game.wasManaCapped = false;
        if (typeof game.paragonSpent.focus !== 'number') game.paragonSpent.focus = 0;
        if (game.prestigeTokenChoice !== 'font' && game.prestigeTokenChoice !== 'study' && game.prestigeTokenChoice !== 'relic') game.prestigeTokenChoice = null;
        ensureExpandedDefaults();
        capMana();
        capStamina();
        capFocus();
        capWards();
        ensureDailyBlessing();
        ensureRunePattern();
        renderAll();
        showToast('Import', 'Save loaded.');
      } catch (e) {
        showToast('Import failed', String(e.message));
      }
    };

    function resetGame() {
      if (!confirm('Reset all progress? This cannot be undone.')) return;
      window._resettingSave = true;
      try {
        localStorage.removeItem('mageTowerSave');
        localStorage.removeItem('mageTowerIntroSeen');
        localStorage.removeItem('mageTowerLoreSeen');
        for (let i = localStorage.length - 1; i >= 0; i--) {
          const k = localStorage.key(i);
          if (k && k.toLowerCase().includes('magetower')) localStorage.removeItem(k);
        }
      } catch (e) {}
      location.reload();
    }

    // -------------------- SAVE / LOAD / OFFLINE --------------------
    function saveGame() {
      if (window._resettingSave) return;
      game.lastSave = Date.now();
      localStorage.setItem('mageTowerSave', JSON.stringify(game));
    }

    function loadGame() {
      try {
      const s = localStorage.getItem('mageTowerSave');
      if (!s) return;
      const data = JSON.parse(s);
      Object.assign(game, data);
      if (!game.specialRooms) game.specialRooms = initialSpecialRooms();
      SPECIAL_ROOM_NAMES.forEach(name => {
        if (!game.specialRooms[name]) game.specialRooms[name] = { built: false, level: 0 };
      });
      if (typeof game.stairs !== 'number') game.stairs = 0;
      if (Array.isArray(game.rooms) && game.rooms.length > 0) {
        const count = (name) => game.rooms.filter(r => r === name).length;
        if (count('Vault') >= 1) { game.specialRooms.Vault = { built: true, level: Math.max(1, count('Vault')) }; }
        if (count('Library') >= 1) { game.specialRooms.Library = { built: true, level: Math.max(1, count('Library')) }; }
        if (count('Observatory') >= 1) { game.specialRooms.Observatory = { built: true, level: Math.max(1, count('Observatory')) }; }
        game.stairs = game.rooms.filter(r => r === 'Stairs').length;
        delete game.rooms;
        delete game.floors;
      }
      const statDefaults = { timeDilationCasts: 0, arcaneHarvestCasts: 0, leylineSurgeCasts: 0, focusSurgeCasts: 0, vigorInfusionCasts: 0, transmutateCasts: 0, manaCapHits: 0, zeroManaCasts: 0, totalManaEarned: 0, totalSpellsCast: 0, timePlayedMs: 0, totalFloorsEver: 0, totalStaminaSpent: 0, maxFloorsReached: 0, maxManaPerSecReached: 0 };
      if (!game.stats) game.stats = { ...statDefaults, achievements: [] };
      Object.keys(statDefaults).forEach(k => { if (typeof game.stats[k] !== 'number') game.stats[k] = statDefaults[k]; });
      if (!Array.isArray(game.stats.achievements)) game.stats.achievements = [];
      if (!game.passive || typeof game.passive !== 'object') game.passive = {};
      const passiveDefaults = { arcane: 0, astral: 0, conduit: 0, towerBond: 0, staminaWell: 0, spellEcho: 0, focusFlow: 0, manaReservoir: 0, ritualMastery: 0, aetherFlux: 0, anchoredRituals: 0, luckyClick: 0 };
      Object.keys(passiveDefaults).forEach(k => { if (typeof game.passive[k] !== 'number') game.passive[k] = passiveDefaults[k]; });
      if (!game.active) game.active = { boost: 1, boostTD: 1, boostHarvest: 1, timer: 0, duration: 0, cooldown: 0, harvestTimer: 0, harvestDuration: 0, leylineTapTimer: 0, leylineTapPct: 0, runeTimer: 0, runeStacks: 0, focusCondenserTimer: 0, spellCostDiscountTimer: 0, spellCostDiscountPct: 0, overclockTimer: 0, overclockMult: 1, worldweaveTimer: 0, convergenceTimer: 0, paradoxTimer: 0 };
      if (typeof game.active.boostTD !== 'number') game.active.boostTD = 1;
      if (typeof game.active.boostHarvest !== 'number') game.active.boostHarvest = 1;
      if (typeof game.active.harvestTimer !== 'number') game.active.harvestTimer = 0;
      if (typeof game.active.harvestDuration !== 'number') game.active.harvestDuration = 0;
      if (typeof game.active.leylineTapTimer !== 'number') game.active.leylineTapTimer = 0;
      if (typeof game.active.leylineTapPct !== 'number') game.active.leylineTapPct = 0;
      if (typeof game.active.runeTimer !== 'number') game.active.runeTimer = 0;
      if (typeof game.active.runeStacks !== 'number') game.active.runeStacks = 0;
      if (typeof game.active.focusCondenserTimer !== 'number') game.active.focusCondenserTimer = 0;
      if (typeof game.active.spellCostDiscountTimer !== 'number') game.active.spellCostDiscountTimer = 0;
      if (typeof game.active.spellCostDiscountPct !== 'number') game.active.spellCostDiscountPct = 0;
      if (typeof game.active.overclockTimer !== 'number') game.active.overclockTimer = 0;
      if (typeof game.active.overclockMult !== 'number') game.active.overclockMult = 1;
      if (typeof game.active.worldweaveTimer !== 'number') game.active.worldweaveTimer = 0;
      if (typeof game.active.convergenceTimer !== 'number') game.active.convergenceTimer = 0;
      if (typeof game.active.paradoxTimer !== 'number') game.active.paradoxTimer = 0;
      if (typeof game.softPrestige !== 'number') game.softPrestige = 0;
      if (typeof game.ascension !== 'number') game.ascension = 0;
      if (typeof game.studyCount !== 'number') game.studyCount = 0;
      if (typeof game.stamina !== 'number') game.stamina = 0;
      if (typeof game.focus !== 'number') game.focus = 0;
      if (!Array.isArray(game.relics)) game.relics = [];
      if (!Array.isArray(game.relicDraft)) game.relicDraft = [];
      if (typeof game.relicDraftSeen !== 'boolean') game.relicDraftSeen = false;
      if (typeof game.sigilStacks !== 'number') game.sigilStacks = 0;
      if (typeof game.relicHuntCooldownEnd !== 'number') game.relicHuntCooldownEnd = 0;
      game.relics = (game.relics || []).filter(id => RELIC_BY_ID[id]);
      game.relicDraft = (game.relicDraft || []).filter(id => RELIC_BY_ID[id]);
      if (typeof game.transmutateCooldownEnd !== 'number') game.transmutateCooldownEnd = 0;
      if (typeof game.manaSiphonCooldownEnd !== 'number') game.manaSiphonCooldownEnd = 0;
      if (typeof game.runeAccretionCooldownEnd !== 'number') game.runeAccretionCooldownEnd = 0;
      if (typeof game.staminaTransmuteCooldownEnd !== 'number') game.staminaTransmuteCooldownEnd = 0;
      if (typeof game.focusCondenserCooldownEnd !== 'number') game.focusCondenserCooldownEnd = 0;
      if (typeof game.leylineResonanceCooldownEnd !== 'number') game.leylineResonanceCooldownEnd = 0;
      if (typeof game.towerPulseCooldownEnd !== 'number') game.towerPulseCooldownEnd = 0;
      if (typeof game.chronoLoopCooldownEnd !== 'number') game.chronoLoopCooldownEnd = 0;
      if (typeof game.nexusOverclockCooldownEnd !== 'number') game.nexusOverclockCooldownEnd = 0;
      if (typeof game.worldweaveCooldownEnd !== 'number') game.worldweaveCooldownEnd = 0;
      if (typeof game.convergenceCooldownEnd !== 'number') game.convergenceCooldownEnd = 0;
      if (typeof game.paradoxCastCooldownEnd !== 'number') game.paradoxCastCooldownEnd = 0;
      if (typeof game.nextFloorDiscountPct !== 'number') game.nextFloorDiscountPct = 0;
      if (!game.settings || typeof game.settings !== 'object') game.settings = { showTutorial: true, keybinds: {} };
      if (typeof game.settings.showTutorial !== 'boolean') game.settings.showTutorial = true;
      ensureKeybinds();
      if (!game.tutorial || typeof game.tutorial !== 'object') game.tutorial = { clicked: false, done: false, completedToast: false, settingsOpened: false, keysSeen: false, glossarySeen: false, libraryOpened: false, observatoryOpened: false, towerOpened: false, activitiesOpened: false };
      if (typeof game.tutorial.clicked !== 'boolean') game.tutorial.clicked = false;
      if (typeof game.tutorial.done !== 'boolean') game.tutorial.done = false;
      if (typeof game.tutorial.completedToast !== 'boolean') game.tutorial.completedToast = false;
      if (typeof game.tutorial.settingsOpened !== 'boolean') game.tutorial.settingsOpened = false;
      if (typeof game.tutorial.keysSeen !== 'boolean') game.tutorial.keysSeen = false;
      if (typeof game.tutorial.glossarySeen !== 'boolean') game.tutorial.glossarySeen = false;
      if (!Array.isArray(game.memorizedSpells)) game.memorizedSpells = [];
      if (typeof game.spellSwapCooldownEnd !== 'number') game.spellSwapCooldownEnd = 0;
      if (!game.paragonSpent || typeof game.paragonSpent.manaPct !== 'number') game.paragonSpent = { manaPct: 0, spellEffect: 0, stamina: 0, focus: 0 };
      if (typeof game.paragonSpent.focus !== 'number') game.paragonSpent.focus = 0;
      if (game.prestigeTokenChoice !== 'font' && game.prestigeTokenChoice !== 'study' && game.prestigeTokenChoice !== 'relic') game.prestigeTokenChoice = null;
      ensureExpandedDefaults();
      capMana();
      capStamina();
      capFocus();
      capWards();

      const now = Date.now();
      const last = game.lastSave || now;
      const dtMs = Math.min(now - last, OFFLINE_CAP_HOURS * 3600 * 1000);
      if (dtMs > 60000) {
        const dtSec = dtMs / 1000;
        const gained = manaPerSecond() * dtSec * 0.5;
        game.mana = Math.min(game.mana + gained, maxMana());
        game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + gained;
        const staminaGain = staminaPerSecond() * dtSec * 0.25;
        game.stamina = Math.min(game.stamina + staminaGain, maxStamina());
        const focusWarmupSec = (FOCUS_IDLE_SEC * focusIdleMultiplier()) / FOCUS_OFFLINE_DIVISOR;
        const focusRegenSec = Math.max(0, dtSec - focusWarmupSec);
        const focusGain = focusRegenSec * FOCUS_REGEN_BASE * OFFLINE_FOCUS_RATE * focusRegenMultiplier();
        game.focus = Math.min((game.focus || 0) + focusGain, maxFocus());
        const cooldownTick = dtMs * 0.5;
        if (game.spellSwapCooldownEnd > 0) game.spellSwapCooldownEnd = Math.max(now, (game.spellSwapCooldownEnd || now) - cooldownTick);
        if (game.ritualOfBindingCooldownEnd > 0) game.ritualOfBindingCooldownEnd = Math.max(now, (game.ritualOfBindingCooldownEnd || now) - cooldownTick);
        if (game.ritualActivityCooldownEnd > 0) game.ritualActivityCooldownEnd = Math.max(now, (game.ritualActivityCooldownEnd || now) - cooldownTick);
        if (game.relicHuntCooldownEnd > 0) game.relicHuntCooldownEnd = Math.max(now, (game.relicHuntCooldownEnd || now) - cooldownTick);
        if (game.transmutateCooldownEnd > 0) game.transmutateCooldownEnd = Math.max(now, (game.transmutateCooldownEnd || now) - cooldownTick);
        if (game.manaSiphonCooldownEnd > 0) game.manaSiphonCooldownEnd = Math.max(now, (game.manaSiphonCooldownEnd || now) - cooldownTick);
        if (game.runeAccretionCooldownEnd > 0) game.runeAccretionCooldownEnd = Math.max(now, (game.runeAccretionCooldownEnd || now) - cooldownTick);
        if (game.staminaTransmuteCooldownEnd > 0) game.staminaTransmuteCooldownEnd = Math.max(now, (game.staminaTransmuteCooldownEnd || now) - cooldownTick);
        if (game.focusCondenserCooldownEnd > 0) game.focusCondenserCooldownEnd = Math.max(now, (game.focusCondenserCooldownEnd || now) - cooldownTick);
        if (game.leylineResonanceCooldownEnd > 0) game.leylineResonanceCooldownEnd = Math.max(now, (game.leylineResonanceCooldownEnd || now) - cooldownTick);
        if (game.towerPulseCooldownEnd > 0) game.towerPulseCooldownEnd = Math.max(now, (game.towerPulseCooldownEnd || now) - cooldownTick);
        if (game.chronoLoopCooldownEnd > 0) game.chronoLoopCooldownEnd = Math.max(now, (game.chronoLoopCooldownEnd || now) - cooldownTick);
        if (game.nexusOverclockCooldownEnd > 0) game.nexusOverclockCooldownEnd = Math.max(now, (game.nexusOverclockCooldownEnd || now) - cooldownTick);
        if (game.worldweaveCooldownEnd > 0) game.worldweaveCooldownEnd = Math.max(now, (game.worldweaveCooldownEnd || now) - cooldownTick);
        if (game.convergenceCooldownEnd > 0) game.convergenceCooldownEnd = Math.max(now, (game.convergenceCooldownEnd || now) - cooldownTick);
        if (game.paradoxCastCooldownEnd > 0) game.paradoxCastCooldownEnd = Math.max(now, (game.paradoxCastCooldownEnd || now) - cooldownTick);
        if (dtMs >= 5 * 60 * 1000) {
          showOfflineProgress(gained, staminaGain, focusGain, dtMs);
        } else {
          showToast('Offline progress', 'Earned ' + formatNum(gained) + ' mana, ' + formatNum(staminaGain) + ' stamina' + (focusGain > 0 ? ', ' + formatNum(focusGain) + ' focus' : '') + ' while away.');
        }
      }
      } catch (loadErr) {
        localStorage.removeItem('mageTowerSave');
      }
    }

    if (typeof location !== 'undefined' && location.search && location.search.includes('clearSave=1')) {
      try { localStorage.removeItem('mageTowerSave'); } catch (e) {}
    }
    loadGame();
    ensureDailyBlessing();
    ensureRunePattern();
    renderAll();
    checkAchievements();
    openPanel('towerModal');

    if (!localStorage.getItem('mageTowerLoreSeen')) {
      showLoreTip();
    }
    introCloseBtn.onclick = () => {
      try { localStorage.setItem('mageTowerIntroSeen', '1'); } catch (e) {}
      introModal.style.display = 'none';
    };
    introModal.addEventListener('click', (e) => {
      if (e.target === introModal) {
        try { localStorage.setItem('mageTowerIntroSeen', '1'); } catch (e2) {}
        introModal.style.display = 'none';
      }
    });
    introModal.querySelector('.modal-content').addEventListener('click', (e) => e.stopPropagation());

    // -------------------- GAME LOOP --------------------
    let lastTickTime = Date.now();
    let towerPulseIndex = 0;
    let lastActivitiesRender = 0;
    let lastSpellRender = 0;
    let lastPanelRender = 0;
    setInterval(() => {
      const now = Date.now();
      const realDt = (now - lastTickTime) / 1000;
      lastTickTime = now;
      const speed = (typeof game.speed === 'number') ? game.speed : 1;
      const dt = realDt * speed;
      if (!game.dailyBlessing || now >= (game.dailyBlessing.nextAt || 0)) {
        ensureDailyBlessing();
      }
      if (!game.runeEtching || game.runeEtching.date !== currentDayKey()) {
        ensureRunePattern();
      }
      game.stats.timePlayedMs = (game.stats.timePlayedMs || 0) + Math.round(realDt * 1000 * speed);
      const tf = totalFloors();
      if (tf > (game.stats.maxFloorsReached || 0)) game.stats.maxFloorsReached = tf;
      const mps = manaPerSecond();
      if (mps > (game.stats.maxManaPerSecReached || 0)) game.stats.maxManaPerSecReached = mps;
      if (game.challenge && game.challenge.active) {
        const cid = game.challenge.active;
        const done = Array.isArray(game.challenge.completed) && game.challenge.completed.includes(cid);
        if (!done && tf >= 40) {
          game.challenge.completed = [...(game.challenge.completed || []), cid];
          game.challenge.tokens = (game.challenge.tokens || 0) + 1;
          game.challenge.active = null;
          showToast('Challenge complete', 'You earned a challenge token.');
        }
      }
      if (mps >= GOAL_MANA_PER_SEC && !(game.stats.goalManaReached)) {
        game.stats.goalManaReached = true;
        showToast('Goal reached!', 'You reached ' + formatNum(GOAL_MANA_PER_SEC) + ' mana/sec!');
        playSound('milestone');
      }
      if (tf >= PARAGON_FLOOR_MIN && (game.ascension || game.ascensionTier2) >= 1) {
        game.paragonXp = (game.paragonXp || 0) + PARAGON_XP_PER_TICK;
      }

      const gained = mps * Math.min(dt, TICK / 1000 * 2);
      game.mana = Math.min(game.mana + gained, maxMana());
      game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + gained;
      const manaCap = maxMana();
      const atCap = game.mana >= manaCap * 0.999;
      if (atCap && !game.wasManaCapped) {
        game.stats.manaCapHits = (game.stats.manaCapHits || 0) + 1;
        game.wasManaCapped = true;
      } else if (!atCap) {
        game.wasManaCapped = false;
      }
      if (game.active) {
        if (atCap) game.active.overchargeCharge = (game.active.overchargeCharge || 0) + dt;
        else game.active.overchargeCharge = 0;
        const shouldOvercharge = (game.active.overchargeCharge || 0) >= OVERCHARGE_GRACE_SEC;
        if (shouldOvercharge) {
          game.active.overchargeTimer = (game.active.overchargeTimer || 0) + dt;
          game.active.overchargeMult = 1.2 + schoolBonus('overcharge');
          const drainPct = OVERCHARGE_DRAIN_PCT * (1 + glyphBonus('overchargeDrain'));
          const drain = maxWards() * drainPct * dt;
          game.wards = Math.max(0, (game.wards || 0) - drain);
          if (game.encounter) game.encounter.threat = (game.encounter.threat || 0) + dt * 0.05;
        } else {
          game.active.overchargeTimer = 0;
          game.active.overchargeMult = 1;
        }
      }

      const sps = staminaPerSecond();
      const staminaGain = sps * Math.min(dt, TICK / 1000 * 2);
      game.stamina = Math.min(game.stamina + staminaGain, maxStamina());

      if (isRestingForFocus()) {
        const fps = focusPerSecond();
        const focusGain = fps * Math.min(dt, TICK / 1000 * 2);
        game.focus = Math.min((game.focus || 0) + focusGain, maxFocus());
      }
      capFocus();

      const wardsGain = wardsRegenPerSecond() * Math.min(dt, TICK / 1000 * 2);
      game.wards = Math.min((game.wards || 0) + wardsGain, maxWards());

      const goldGain = goldPerSecond() * Math.min(dt, TICK / 1000 * 2);
      if (goldGain > 0) gainGold(goldGain);
      const upkeep = (staffUpkeepPerMin() / 60) * Math.min(dt, TICK / 1000 * 2);
      if (upkeep > 0) {
        if ((game.gold || 0) >= upkeep) {
          spendGold(upkeep);
          STAFF.forEach(s => {
            const st = getStaffState(s.id);
            if (!st.hired) return;
            st.happiness = Math.min(100, (st.happiness || 60) + dt * 0.5);
          });
        } else {
          STAFF.forEach(s => {
            const st = getStaffState(s.id);
            if (!st.hired) return;
            st.happiness = Math.max(20, (st.happiness || 60) - dt * 2);
          });
        }
      }

      if (game.research) {
        const rpGain = researchPointsPerSecond() * Math.min(dt, TICK / 1000 * 2);
        game.research.points = (game.research.points || 0) + rpGain;
      }
      const followerGain = followerGrowthPerSecond() * Math.min(dt, TICK / 1000 * 2);
      game.followerProgress = (game.followerProgress || 0) + followerGain;
      const newFollowers = Math.floor(game.followerProgress || 0);
      if (newFollowers > 0) {
        game.followerProgress -= newFollowers;
        gainFollowers(newFollowers);
      }
      const scouting = assignmentCount('scouting');
      if (scouting > 0) {
        game.scoutingProgress = (game.scoutingProgress || 0) + scouting * dt * 0.015;
        const found = Math.floor(game.scoutingProgress || 0);
        if (found > 0) {
          game.scoutingProgress -= found;
          for (let i = 0; i < found; i++) {
            const type = ESSENCE_TYPES[Math.floor(Math.random() * ESSENCE_TYPES.length)];
            gainEssence(type, 1);
          }
        }
      }
      promoteFollowers(dt);
      updateEncounter(dt);
      updateContracts(dt);
      maybeTriggerFollowerEvent();
      if (game.encounter) game.encounter.threat = Math.max(0, (game.encounter.threat || 0) - dt * 0.01);

      const hadActiveSpell = game.active.timer > 0 || game.active.harvestTimer > 0 || game.active.leylineTapTimer > 0;
      if (game.active.timer > 0) {
        game.active.timer -= dt;
        if (game.active.timer <= 0) {
          game.active.boostTD = 1;
          game.active.duration = 0;
        }
      }
      if (game.active.harvestTimer > 0) {
        game.active.harvestTimer -= dt;
        if (game.active.harvestTimer <= 0) game.active.boostHarvest = 1;
      }
      if (game.active.leylineTapTimer > 0) {
        game.active.leylineTapTimer -= dt;
        if (game.active.leylineTapTimer <= 0) game.active.leylineTapPct = 0;
      }
      if (game.active.runeTimer > 0) {
        game.active.runeTimer -= dt;
        if (game.active.runeTimer <= 0) game.active.runeStacks = 0;
      }
      if (game.active.focusCondenserTimer > 0) {
        game.active.focusCondenserTimer -= dt;
        if (game.active.focusCondenserTimer < 0) game.active.focusCondenserTimer = 0;
      }
      if (game.active.flameSurgeTimer > 0) {
        game.active.flameSurgeTimer -= dt;
        if (game.active.flameSurgeTimer < 0) game.active.flameSurgeTimer = 0;
      }
      if (game.active.frostSlowTimer > 0) {
        game.active.frostSlowTimer -= dt;
        if (game.active.frostSlowTimer < 0) game.active.frostSlowTimer = 0;
      }
      if (game.active.spellCostDiscountTimer > 0) {
        game.active.spellCostDiscountTimer -= dt;
        if (game.active.spellCostDiscountTimer <= 0) game.active.spellCostDiscountPct = 0;
      }
      if (game.active.comboTimer > 0) {
        game.active.comboTimer -= dt;
        if (game.active.comboTimer <= 0) game.active.comboMult = 1;
      }
      if (game.active.concessionTimer > 0) {
        game.active.concessionTimer -= dt;
        if (game.active.concessionTimer < 0) game.active.concessionTimer = 0;
      }
      const hadOverclock = game.active.overclockTimer > 0;
      if (game.active.overclockTimer > 0) {
        game.active.overclockTimer -= dt;
        if (game.active.overclockTimer <= 0) {
          game.active.overclockMult = 1;
        }
      }
      if (hadOverclock && game.active.overclockTimer <= 0) {
        game.exhaustedUntil = Math.max(game.exhaustedUntil || 0, Date.now() + 180 * 1000);
      }
      if (game.active.worldweaveTimer > 0) {
        game.active.worldweaveTimer -= dt;
        if (game.active.worldweaveTimer < 0) game.active.worldweaveTimer = 0;
      }
      if (game.active.convergenceTimer > 0) {
        game.active.convergenceTimer -= dt;
        if (game.active.convergenceTimer < 0) game.active.convergenceTimer = 0;
      }
      if (game.active.paradoxTimer > 0) {
        game.active.paradoxTimer -= dt;
        if (game.active.paradoxTimer < 0) game.active.paradoxTimer = 0;
      }
      if (hadActiveSpell && game.active.timer <= 0 && game.active.harvestTimer <= 0 && game.active.leylineTapTimer <= 0) renderSpells();

      const hadCooldown = game.active.cooldown > 0;
      if (game.active.cooldown > 0) {
        game.active.cooldown -= dt;
        if (game.active.cooldown < 0) game.active.cooldown = 0;
      }
      if (hadCooldown && game.active.cooldown <= 0) renderSpells();

      renderUI();
      if (now - lastActivitiesRender > 250) {
        renderActivities();
        lastActivitiesRender = now;
      }
      if (now - lastSpellRender > 250) {
        const hover = grimoireModal && grimoireModal.classList.contains('show') && grimoireModal.matches(':hover');
        if (hover) updateGrimoireHeader();
        else renderSpells();
        lastSpellRender = now;
      }
      if (now - lastPanelRender > 500) {
        renderAcademy();
        renderLibrary();
        renderObservatory();
        lastPanelRender = now;
      }
      checkAchievements();

      towerPulseIndex++;
      if (towerContainer.children.length && towerPulseIndex % 50 === 0) {
        const block = towerContainer.children[towerContainer.children.length - 1];
        if (block && block.classList) {
          block.classList.add('tick-pulse');
          setTimeout(() => block.classList.remove('tick-pulse'), 300);
        }
      }

      saveGame();
    }, TICK);
  </script>
</body>
</html>
