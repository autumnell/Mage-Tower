<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mage Tower Idle</title>
  <style>
    :root {
      --bg-deep: #0c0e14;
      --bg-panel: #12161e;
      --bg-card: #181c28;
      --bg-elevated: #1e2432;
      --border: #2a3040;
      --border-focus: #3d4558;
      --text: #e2e4ec;
      --text-muted: #7c8498;
      --accent: #7c9cf4;
      --accent-dim: rgba(124, 156, 244, 0.12);
      --accent-glow: rgba(124, 156, 244, 0.28);
      --stamina: #d4a574;
      --focus-color: #a5b8e8;
      --shadow: 0 4px 24px rgba(0, 0, 0, 0.45);
      --shadow-glow: 0 0 18px rgba(124, 156, 244, 0.12);
      --radius: 10px;
      --radius-sm: 6px;
      --font: 'Segoe UI', system-ui, -apple-system, sans-serif;
      --toast-bg: var(--bg-card);
      --toast-border: var(--accent);
    }
    * { box-sizing: border-box; }
    body {
      font-family: var(--font);
      font-size: 15px;
      line-height: 1.45;
      letter-spacing: 0.01em;
      background: var(--bg-deep);
      color: var(--text);
      margin: 0;
      display: flex;
      min-height: 100vh;
      flex-direction: column;
      -webkit-font-smoothing: antialiased;
    }
    button {
      width: 100%;
      margin: 8px 0;
      padding: 12px 16px;
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      color: var(--text);
      cursor: pointer;
      border-radius: var(--radius-sm);
      transition: background 0.2s, border-color 0.2s, transform 0.1s;
      position: relative;
      font-family: inherit;
      font-size: 0.95em;
      font-weight: 600;
    }
    button:hover:not(:disabled) {
      background: var(--border-focus);
      border-color: var(--border-focus);
    }
    button:active:not(:disabled) { transform: scale(0.99); }
    button:disabled { background: #1a1520; border-color: transparent; opacity: 0.6; cursor: not-allowed; }

    .tooltip {
      visibility: hidden;
      opacity: 0;
      width: 280px;
      max-width: calc(100% - 8px);
      background: var(--bg-elevated);
      color: var(--text);
      text-align: left;
      border-radius: var(--radius-sm);
      padding: 10px 12px;
      position: absolute;
      z-index: 20;
      top: calc(100% + 8px);
      left: 4px;
      transition: opacity 0.2s;
      font-size: 0.88em;
      line-height: 1.4;
      pointer-events: none;
      white-space: pre-line;
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
    }
    button .desc { display: block; font-size: 0.82em; opacity: 0.8; margin-top: 4px; font-weight: 500; }
    button .desc .detail { display: block; margin-top: 6px; opacity: 0.9; }
    .unlock-hint { font-size: 0.78em; opacity: 0.75; margin-top: 4px; color: var(--text-muted); }
    #tutorialLayer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 14;
    }
    .tutorial-tip {
      position: fixed;
      max-width: 240px;
      background: var(--bg-card);
      color: var(--text);
      border: 1px solid var(--accent);
      border-radius: var(--radius-sm);
      padding: 10px 12px;
      font-size: 0.86em;
      line-height: 1.4;
      box-shadow: var(--shadow);
    }
    .tutorial-tip strong { color: var(--accent); }
    .tutorial-tip::before,
    .tutorial-tip::after {
      content: "";
      position: absolute;
      width: 0;
      height: 0;
      border-style: solid;
    }
    .tutorial-tip.pos-top::before {
      bottom: -10px;
      left: 24px;
      border-width: 10px 10px 0 10px;
      border-color: var(--accent) transparent transparent transparent;
    }
    .tutorial-tip.pos-top::after {
      bottom: -8px;
      left: 24px;
      border-width: 8px 8px 0 8px;
      border-color: var(--bg-card) transparent transparent transparent;
    }
    .tutorial-tip.pos-bottom::before {
      top: -10px;
      left: 24px;
      border-width: 0 10px 10px 10px;
      border-color: transparent transparent var(--accent) transparent;
    }
    .tutorial-tip.pos-bottom::after {
      top: -8px;
      left: 24px;
      border-width: 0 8px 8px 8px;
      border-color: transparent transparent var(--bg-card) transparent;
    }
    .tutorial-tip.pos-left::before {
      right: -10px;
      top: 18px;
      border-width: 10px 0 10px 10px;
      border-color: transparent transparent transparent var(--accent);
    }
    .tutorial-tip.pos-left::after {
      right: -8px;
      top: 18px;
      border-width: 8px 0 8px 8px;
      border-color: transparent transparent transparent var(--bg-card);
    }
    .tutorial-tip.pos-right::before {
      left: -10px;
      top: 18px;
      border-width: 10px 10px 10px 0;
      border-color: transparent var(--accent) transparent transparent;
    }
    .tutorial-tip.pos-right::after {
      left: -8px;
      top: 18px;
      border-width: 8px 8px 8px 0;
      border-color: transparent var(--bg-card) transparent transparent;
    }
    #loreTip {
      position: fixed;
      top: 92px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 14;
      max-width: 420px;
      display: none;
      pointer-events: auto;
    }
    #loreTip .lore-close {
      width: auto;
      margin-top: 8px;
      padding: 6px 10px;
      font-size: 0.85em;
    }
    .stat { margin: 8px 0; font-size: 0.95em; }
    .cost { font-size: 0.88em; opacity: 0.8; display: block; color: var(--text-muted); margin-top: 2px; }
    .section-divider { margin: 20px 0; height: 1px; background: var(--border); }

    .spell-status {
      margin: 10px 0 6px;
      padding: 12px 14px;
      background: var(--bg-panel);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
    }
    .spell-status .row { display: flex; justify-content: space-between; gap: 12px; align-items: baseline; }
    .spell-status .label { font-weight: 600; }
    .spell-status .sub { font-size: 0.88em; opacity: 0.85; }
    .progress {
      height: 8px;
      background: var(--bg-deep);
      border-radius: 999px;
      overflow: hidden;
      margin-top: 8px;
      border: 1px solid var(--border);
    }
    .progress > .fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), #8ba3f0);
      transition: width 0.1s linear;
    }

    #towerContainer { display: flex; flex-direction: column-reverse; align-items: center; position: relative; }
    .tower-block {
      width: 104px;
      height: 48px;
      margin-top: 4px;
      border-radius: var(--radius-sm);
      position: relative;
      opacity: 1;
      transition: transform 0.15s;
      border: 1px solid rgba(255, 255, 255, 0.10);
      box-shadow: 0 10px 26px rgba(0, 0, 0, 0.25);
      overflow: hidden;
    }
    .tower-block.foundation {
      background: linear-gradient(180deg, #2a3040 0%, #161b26 100%);
      border-color: rgba(255, 255, 255, 0.16);
    }
    .tower-block.foundation .room { opacity: 0.9; }
    /* tier tapering (keeps blocky silhouette but feels “designed”) */
    .tower-block.tier-1 { width: 112px; }
    .tower-block.tier-2 { width: 106px; }
    .tower-block.tier-3 { width: 100px; }
    .tower-block.tier-4 { width: 94px; }
    .tower-block::before {
      content: "";
      position: absolute;
      inset: 0;
      background:
        linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.02) 26%, rgba(0,0,0,0.08)),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.06) 0 2px, rgba(0,0,0,0.00) 2px 8px),
        repeating-linear-gradient(0deg, rgba(0,0,0,0.14) 0 1px, rgba(0,0,0,0.00) 1px 10px);
      opacity: 0.9;
      pointer-events: none;
      mix-blend-mode: overlay;
    }
    .tower-block::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, rgba(0,0,0,0.14), rgba(0,0,0,0.00) 30%, rgba(255,255,255,0.05) 55%, rgba(0,0,0,0.18));
      opacity: 0.55;
      pointer-events: none;
    }
    .tower-windows {
      position: absolute;
      inset: 10px 10px 14px 10px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      opacity: 0.7;
      pointer-events: none;
      filter: drop-shadow(0 0 8px rgba(124, 156, 244, 0.08));
    }
    .tower-window {
      border-radius: 3px;
      border: 1px solid rgba(255,255,255,0.08);
      background: radial-gradient(circle at 40% 30%, rgba(124,156,244,0.20), rgba(0,0,0,0.35));
    }
    .tower-block.tier-1 .tower-window { opacity: 0.55; }
    .tower-block.tier-2 .tower-window { opacity: 0.65; }
    .tower-block.tier-3 .tower-window { opacity: 0.75; }
    .tower-block.tier-4 .tower-window { opacity: 0.85; }

    .tower-topper {
      position: absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      width: calc(100% - 10px);
      height: 14px;
      pointer-events: none;
    }
    .tower-crenel {
      position: absolute;
      inset: 0;
      border-radius: 6px 6px 0 0;
      background:
        repeating-linear-gradient(90deg,
          rgba(0,0,0,0.00) 0 6px,
          rgba(0,0,0,0.28) 6px 10px),
        linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.22));
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 8px 14px rgba(0,0,0,0.25);
    }
    .tower-turrets {
      position: absolute;
      inset: -2px 0 0 0;
      pointer-events: none;
    }
    .tower-turrets .turret {
      position: absolute;
      top: 0;
      width: 18px;
      height: 18px;
      border-radius: 6px 6px 4px 4px;
      background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.20));
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 8px 14px rgba(0,0,0,0.25);
    }
    .tower-turrets .turret.left { left: -8px; }
    .tower-turrets .turret.right { right: -8px; }
    .tower-turrets .turret::after {
      content: "";
      position: absolute;
      top: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 16px;
      height: 10px;
      border-radius: 6px 6px 0 0;
      background:
        repeating-linear-gradient(90deg,
          rgba(0,0,0,0.00) 0 5px,
          rgba(0,0,0,0.30) 5px 8px),
        linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.22));
      border: 1px solid rgba(255,255,255,0.10);
    }
    .tower-block.tick-pulse { animation: tickPulse 0.3s ease-out; }
    .tower-block.side-left { transform: translateX(-30px); margin-right: -30px; }
    .tower-block.side-right { transform: translateX(30px); margin-left: -30px; }
    @keyframes tickPulse { 0% { filter: brightness(1); } 50% { filter: brightness(1.2); } 100% { filter: brightness(1); } }
    .room {
      position: absolute;
      bottom: 6px;
      width: 100%;
      text-align: center;
      font-size: 0.66em;
      font-weight: 600;
      text-shadow: none;
      letter-spacing: 0.02em;
      color: rgba(226, 228, 236, 0.78);
      opacity: 0;
      transform: translateY(2px);
      transition: opacity 0.18s ease, transform 0.18s ease;
      pointer-events: none;
    }
    .tower-block:hover .room { opacity: 0.95; transform: translateY(0); }
    .boost-number { position: absolute; color: var(--accent); font-size: 0.9em; font-weight: bold; animation: floatUp 1.2s forwards; pointer-events: none; text-shadow: 0 0 12px var(--accent-glow); }
    .boost-number.crit { color: #e9d5a0; text-shadow: 0 0 10px rgba(233, 213, 160, 0.4); }
    .click-ripple {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 2px solid var(--accent-glow);
      box-shadow: 0 0 18px var(--accent-glow);
      pointer-events: none;
      animation: ripple 520ms ease-out forwards;
      transform: translate(-50%, -50%);
    }
    @keyframes ripple {
      from { opacity: 0.9; transform: translate(-50%, -50%) scale(0.7); }
      to { opacity: 0; transform: translate(-50%, -50%) scale(3.2); }
    }
    @keyframes floatUp { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-40px); opacity: 0; } }
    .tier-1 { background: linear-gradient(180deg, #5a6a9e 0%, #2d3550 100%); }
    .tier-2 { background: linear-gradient(180deg, #4a7a9e 0%, #2d4050 100%); }
    .tier-3 { background: linear-gradient(180deg, #8e7a5a 0%, #50402d 100%); }
    .tier-4 { background: linear-gradient(180deg, #6a5a8e 0%, #403550 100%); }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(10, 6, 18, 0.88);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
      backdrop-filter: blur(4px);
    }
    .modal-content {
      background: var(--bg-panel);
      padding: 24px;
      border-radius: var(--radius);
      max-width: 600px;
      width: 90%;
      max-height: 85%;
      overflow-y: auto;
      border: 1px solid var(--border);
      box-shadow: var(--shadow), 0 0 0 1px rgba(255, 255, 255, 0.03);
    }
    #roomModal .modal-content { max-height: 92%; padding-bottom: 140px; display: flex; flex-wrap: wrap; gap: 14px; justify-content: center; }
    .intro-content { max-width: 520px; }
    .intro-content h3 { margin-top: 0; color: var(--accent); }
    .intro-lore, .intro-how { margin: 14px 0; font-size: 0.95em; line-height: 1.5; color: var(--text-muted); }
    .intro-how ul { margin: 8px 0 0 16px; padding-left: 8px; }
    .intro-how li { margin: 6px 0; }
    #introCloseBtn { margin-top: 12px; }
    .room-detail-content { max-width: 380px; position: relative; }
    .room-detail-header { display: flex; align-items: flex-start; justify-content: space-between; gap: 12px; margin-bottom: 12px; }
    .room-detail-header h3 { margin: 0; font-size: 1.2em; color: var(--accent); flex: 1; }
    .room-detail-close {
      flex-shrink: 0; width: 32px; height: 32px; padding: 0; margin: -4px -4px 0 0;
      background: var(--bg-elevated); border: 1px solid var(--border); color: var(--text);
      border-radius: var(--radius-sm); cursor: pointer; font-size: 1.4em; line-height: 1; display: flex; align-items: center; justify-content: center;
    }
    .room-detail-close:hover { background: var(--border-focus); border-color: var(--border-focus); }
    .room-detail-desc { margin: 0 0 12px; font-size: 0.92em; color: var(--text-muted); line-height: 1.45; }
    .room-detail-level { margin: 0 0 14px; font-size: 0.9em; }
    .room-detail-upgrade { margin-top: 4px; }

    .room-card {
      background: var(--bg-card);
      padding: 14px;
      border-radius: var(--radius-sm);
      width: 148px;
      text-align: center;
      cursor: pointer;
      position: relative;
      border: 1px solid var(--border);
      transition: border-color 0.2s, background 0.2s, transform 0.15s;
      font-weight: 600;
      font-size: 0.92em;
    }
    .room-card:hover:not(.disabled) { border-color: var(--accent); background: var(--bg-elevated); transform: translateY(-2px); }
    .room-card.disabled { opacity: 0.5; cursor: not-allowed; }
    .room-card:hover .tooltip { visibility: visible; opacity: 1; }
    .room-card .unlock-hint { display: block; margin-top: 6px; }

    .relic-card {
      background: var(--bg-card);
      padding: 14px;
      border-radius: var(--radius-sm);
      width: 200px;
      text-align: left;
      cursor: pointer;
      position: relative;
      border: 1px solid var(--border);
      transition: border-color 0.2s, background 0.2s, transform 0.15s;
    }
    .relic-card:hover:not(.disabled) { border-color: var(--accent); background: var(--bg-elevated); transform: translateY(-2px); }
    .relic-card.disabled { opacity: 0.5; cursor: not-allowed; }
    .relic-card .relic-tier {
      font-size: 0.7em;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      opacity: 0.7;
      margin-bottom: 6px;
    }
    .relic-card .relic-title { font-weight: 700; margin-bottom: 6px; }
    .relic-card .relic-desc { font-size: 0.86em; color: var(--text-muted); line-height: 1.4; }
    .relic-card.tier-uncommon { border-color: rgba(124, 156, 244, 0.55); }
    .relic-card.tier-rare { border-color: rgba(214, 188, 255, 0.7); box-shadow: 0 0 18px rgba(214, 188, 255, 0.12); }

    #relicModal .modal-content { max-height: 92%; padding-bottom: 140px; display: flex; flex-wrap: wrap; gap: 14px; justify-content: center; }
    .relic-list { display: flex; flex-direction: column; gap: 10px; }
    .relic-item {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 10px 12px;
    }
    .relic-item .relic-name { font-weight: 700; color: var(--accent); }
    .relic-item .relic-note { font-size: 0.86em; color: var(--text-muted); margin-top: 4px; }

    #toastContainer {
      position: fixed;
      bottom: 72px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 30;
      display: flex;
      flex-direction: column;
      gap: 10px;
      pointer-events: none;
    }
    .toast {
      background: var(--toast-bg);
      border: 1px solid var(--toast-border);
      color: var(--text);
      padding: 14px 22px;
      border-radius: var(--radius-sm);
      font-size: 0.92em;
      animation: toastIn 0.35s ease-out;
      white-space: nowrap;
      max-width: 92vw;
      box-shadow: var(--shadow);
    }
    @keyframes toastIn { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }
    .toast-title { font-weight: 700; margin-bottom: 4px; }
    .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px 28px; margin: 14px 0; font-size: 0.92em; }
    .stats-grid span { opacity: 0.95; }
    .stats-grid .value { font-weight: 600; color: var(--accent); }

    body { flex-direction: column; min-height: 100vh; }
    #topBar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 16px;
      padding: 14px 24px;
      background: var(--bg-panel);
      border-bottom: 1px solid var(--border);
      min-height: 58px;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.25);
    }
    #topCenter {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      gap: 12px;
      min-width: 240px;
    }
    #topActions {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    #topBar .resources { display: flex; align-items: flex-start; gap: 28px; font-size: 1.05em; flex-wrap: wrap; }
    #topBar .resource-block {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 6px 12px;
      background: var(--bg-card);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
    }
    #topBar .resource-block .main { font-weight: 700; font-size: 1.02em; }
    #topBar .resource-block .main.mana { color: var(--accent); }
    #topBar .resource-block .main.stamina { color: var(--stamina); }
    #topBar .resource-block .main.focus { color: var(--focus-color); }
    .exhausted-hint {
      font-size: 0.85em;
      color: var(--text);
      background: rgba(212, 165, 116, 0.18);
      border: 1px solid rgba(212, 165, 116, 0.45);
      border-radius: 999px;
      padding: 6px 10px;
      white-space: nowrap;
      position: absolute;
      left: 100%;
      top: 50%;
      transform: translate(12px, -50%);
      box-shadow: 0 0 12px rgba(212, 165, 116, 0.18);
    }
    #topBar .resource-block .sub { font-size: 0.88em; opacity: 0.88; color: var(--text-muted); }
    #topBar .spell-status-inline { display: flex; align-items: center; gap: 10px; font-size: 0.9em; opacity: 0.95; }
    .mini-progress {
      height: 6px;
      background: rgba(0, 0, 0, 0.35);
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.08);
      margin-top: 4px;
    }
    .mini-progress > .mini-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent), #8ba3f0);
      transition: width 0.12s linear;
    }
    .mini-progress.stamina > .mini-fill { background: linear-gradient(90deg, var(--stamina), #e9c89a); }
    .mini-progress.focus > .mini-fill { background: linear-gradient(90deg, var(--focus-color), var(--accent)); }
    #main {
      flex: 1;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      background: radial-gradient(ellipse 120% 100% at 50% 100%, #151020 0%, var(--bg-deep) 55%);
      position: relative;
      overflow: hidden;
      min-height: 0;
    }
    /* subtle animated “stars” */
    #main::before, #main::after {
      content: "";
      position: absolute;
      inset: -40% -20%;
      pointer-events: none;
      opacity: 0.3;
      background:
        radial-gradient(circle at 20% 30%, rgba(124,156,244,0.12) 0 1px, transparent 2px),
        radial-gradient(circle at 70% 20%, rgba(100,140,220,0.1) 0 1px, transparent 2px),
        radial-gradient(circle at 55% 75%, rgba(160,180,230,0.08) 0 1px, transparent 2px),
        radial-gradient(circle at 35% 60%, rgba(124,156,244,0.06) 0 1px, transparent 2px),
        radial-gradient(circle at 85% 65%, rgba(100,140,220,0.05) 0 1px, transparent 2px);
      filter: blur(0.2px);
      transform: translateZ(0);
      animation: drift 18s linear infinite;
    }
    #main::after { opacity: 0.18; animation-duration: 28s; animation-direction: reverse; }
    @keyframes drift { from { transform: translate3d(0,0,0); } to { transform: translate3d(8%, 6%, 0); } }
    #main #towerContainer { margin-bottom: 80px; }
    #bottomNav {
      display: flex;
      justify-content: center;
      gap: 0;
      background: var(--bg-panel);
      border-top: 1px solid var(--border);
      padding: 0;
      box-shadow: 0 -4px 24px rgba(0, 0, 0, 0.45);
    }
    #bottomNav .tab {
      flex: 1;
      max-width: 200px;
      padding: 14px 18px;
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-size: 0.95em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      border-bottom: 3px solid transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      font-family: inherit;
    }
    #bottomNav .tab .tab-icon { width: 26px; height: 26px; flex-shrink: 0; opacity: 0.9; }
    #bottomNav .tab .tab-badge {
      display: none;
      width: 12px;
      height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(255, 214, 140, 0.9);
      background: radial-gradient(circle at 30% 30%, #fff4da, #f5b94c);
      box-shadow: 0 0 8px rgba(245, 185, 76, 0.6);
      position: absolute;
      top: 6px;
      right: 10px;
    }
    #bottomNav .tab.has-badge .tab-badge { display: inline-flex; }
    #bottomNav .tab:hover { color: var(--text); background: var(--accent-dim); }
    #bottomNav .tab:hover .tab-icon { opacity: 1; }
    #bottomNav .tab.active { color: var(--accent); background: var(--accent-dim); border-bottom-color: var(--accent); }
    #bottomNav .tab.active .tab-icon { opacity: 1; filter: drop-shadow(0 0 8px var(--accent-glow)); }
    #bottomNav .tab { position: relative; }
    #bottomNav .tab.tab-locked { opacity: 0.5; cursor: not-allowed; pointer-events: auto; }
    #bottomNav .tab.tab-locked:hover { color: var(--text-muted); background: transparent; }
    #bottomNav .tab.tab-locked:hover .tab-icon { opacity: 0.9; filter: none; }
    .panel-modal {
      position: fixed;
      inset: 0;
      background: transparent;
      display: none;
      align-items: stretch;
      justify-content: flex-end;
      z-index: 15;
      pointer-events: none;
    }
    .panel-modal.show { display: flex; }
    .panel-modal .panel-content {
      background: var(--bg-panel);
      border-left: 1px solid var(--border);
      border-radius: 0;
      padding: 22px 20px;
      width: min(380px, 92vw);
      height: 100%;
      max-height: none;
      overflow-y: auto;
      box-shadow: -10px 0 28px rgba(0, 0, 0, 0.45);
      transform: translateX(100%);
      transition: transform 0.2s ease, opacity 0.2s ease;
      opacity: 0.98;
      pointer-events: auto;
    }
    .panel-modal.show .panel-content { transform: translateX(0); opacity: 1; }
    .panel-modal .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 22px;
      padding-bottom: 14px;
      border-bottom: 1px solid var(--border);
    }
    .panel-modal .panel-header h2 { margin: 0; font-size: 1.4em; font-weight: 700; color: var(--accent); letter-spacing: 0.02em; }
    .panel-modal .panel-close {
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      color: var(--text);
      width: 38px;
      height: 38px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      font-size: 1.3em;
      line-height: 1;
      transition: background 0.2s, border-color 0.2s;
    }
    .panel-modal .panel-close:hover { background: var(--border-focus); border-color: var(--border-focus); }
    .panel-modal .section-title { font-size: 0.9em; color: var(--text-muted); margin: 18px 0 10px; font-weight: 600; }
    .grimoire-slots-stat { font-weight: 600; margin-bottom: 6px; font-size: 0.95em; }
    .grimoire-swap-timer { font-size: 0.88em; color: var(--text-muted); margin-bottom: 14px; }
    .spell-row { display: flex; gap: 10px; align-items: stretch; margin-bottom: 8px; }
    .spell-row > button:first-child { flex: 1; }
    .spell-row .spell-slot-btn { flex: 0 0 auto; width: auto; min-width: 80px; }
    .panel-modal .section-title:first-of-type { margin-top: 0; }
    .floors-stat .value { color: var(--accent); font-weight: 700; }
    .panel-modal .stat { padding: 6px 0; }

    #settingsBtn {
      background: var(--bg-elevated);
      border: 1px solid var(--border);
      width: 42px;
      height: 42px;
      border-radius: var(--radius-sm);
      font-size: 1.2em;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    #settingsBtn:hover { background: var(--border-focus); border-color: var(--border-focus); }

    .settings-content { max-width: 420px; }
    .settings-header {
      display: flex; align-items: center; justify-content: space-between; gap: 12px;
      margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--border);
    }
    .settings-header h2 { margin: 0; font-size: 1.35em; font-weight: 700; color: var(--accent); letter-spacing: 0.02em; }
    .settings-close {
      width: 36px; height: 36px; padding: 0; margin: 0;
      background: var(--bg-elevated); border: 1px solid var(--border); color: var(--text);
      border-radius: var(--radius-sm); cursor: pointer; font-size: 1.35em; line-height: 1;
      display: flex; align-items: center; justify-content: center;
      transition: background 0.2s, border-color 0.2s;
    }
    .settings-close:hover { background: var(--border-focus); border-color: var(--border-focus); }
    .settings-section { margin-bottom: 16px; }
    .settings-section:last-child { margin-bottom: 0; }
    .settings-section-title {
      font-size: 0.8em; font-weight: 600; text-transform: uppercase; letter-spacing: 0.06em;
      color: var(--text-muted); margin: 0 0 10px 0;
    }
    .settings-row { margin: 0; }
    .settings-toggle { margin-top: 4px; }
    .settings-label {
      display: flex; align-items: center; gap: 12px; cursor: pointer;
      padding: 12px 14px; background: var(--bg-card); border: 1px solid var(--border);
      border-radius: var(--radius-sm); transition: border-color 0.2s, background 0.2s;
    }
    .settings-label:hover { border-color: var(--border-focus); background: var(--bg-elevated); }
    .settings-checkbox {
      width: 20px; height: 20px; margin: 0; accent-color: var(--accent);
      cursor: pointer; flex-shrink: 0;
    }
    .settings-toggle-text { font-weight: 500; font-size: 0.95em; }
    .settings-content .settings-btn {
      width: 100%; margin: 6px 0 0 0; padding: 12px 16px;
      font-size: 0.95em; text-align: left;
    }
    .settings-content .settings-btn:first-of-type { margin-top: 0; }
    .settings-section .settings-btn + .settings-btn { margin-top: 8px; }
    .settings-tabs {
      display: flex;
      gap: 8px;
      margin: -8px 0 14px;
    }
    .settings-tab {
      width: auto;
      margin: 0;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-muted);
      font-weight: 700;
      letter-spacing: 0.02em;
    }
    .settings-tab:hover { background: var(--bg-elevated); color: var(--text); }
    .settings-tab.active {
      color: var(--text);
      border-color: rgba(124, 156, 244, 0.35);
      box-shadow: 0 0 0 3px rgba(124, 156, 244, 0.10);
    }
    .settings-page { display: block; }
    .settings-page.hidden { display: none; }
    .keybinds-list {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 12px;
    }
    .kb-row {
      display: grid;
      grid-template-columns: 56px 1fr auto;
      gap: 12px;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
    .kb-row:last-child { border-bottom: none; }
    .kb-key {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: 28px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.10);
      background: var(--bg-elevated);
      color: var(--text);
      font-weight: 800;
      font-size: 0.9em;
      letter-spacing: 0.02em;
    }
    .kb-rebind {
      width: auto;
      margin: 0;
      padding: 6px 10px;
      font-size: 0.8em;
      border-radius: 999px;
    }
    .kb-desc { color: var(--text-muted); font-size: 0.95em; }
    .settings-section-danger .settings-section-title { color: #b08080; }
    .settings-btn-danger {
      border-color: rgba(180, 100, 100, 0.4); color: #e0b0b0;
    }
    .settings-btn-danger:hover:not(:disabled) {
      background: rgba(140, 70, 70, 0.2); border-color: #a05050;
    }
    .glossary-list { display: grid; gap: 10px; }
    .glossary-item {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 10px 12px;
    }
    .glossary-item .term { font-weight: 700; color: var(--accent); }
    .glossary-item .desc { color: var(--text-muted); font-size: 0.9em; margin-top: 4px; }
    .game-title {
      margin: 0;
      font-size: 1.15em;
      font-weight: 700;
      color: var(--text-muted);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    @media (max-width: 520px) {
      .game-title { font-size: 1em; }
      #topBar { padding: 10px 14px; gap: 10px; }
      #topBar .resource-block { padding: 4px 8px; font-size: 0.95em; }
      #topCenter { min-width: 0; flex-wrap: wrap; }
      .exhausted-hint { position: static; transform: none; margin-left: 0; }
      .panel-modal .panel-content { padding: 20px; }
    }

    /* ===== POLISH: Resource full glow effect ===== */
    .resource-block.resource-full {
      animation: resourceFullPulse 2s ease-in-out infinite;
      border-color: var(--accent);
    }
    .resource-block.resource-full.mana-block { border-color: var(--accent); }
    .resource-block.resource-full.stamina-block { border-color: var(--stamina); }
    .resource-block.resource-full.focus-block { border-color: var(--focus-color); }
    @keyframes resourceFullPulse {
      0%, 100% { box-shadow: 0 0 8px rgba(124, 156, 244, 0.15); }
      50% { box-shadow: 0 0 16px rgba(124, 156, 244, 0.35); }
    }
    .resource-block.resource-full.stamina-block {
      animation-name: staminaFullPulse;
    }
    @keyframes staminaFullPulse {
      0%, 100% { box-shadow: 0 0 8px rgba(212, 165, 116, 0.15); }
      50% { box-shadow: 0 0 16px rgba(212, 165, 116, 0.35); }
    }
    .resource-block.resource-full.focus-block {
      animation-name: focusFullPulse;
    }
    @keyframes focusFullPulse {
      0%, 100% { box-shadow: 0 0 8px rgba(165, 184, 232, 0.15); }
      50% { box-shadow: 0 0 16px rgba(165, 184, 232, 0.35); }
    }

    /* ===== POLISH: Better button feedback ===== */
    button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    button:not(:disabled):active {
      transform: translateY(0) scale(0.98);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    /* ===== POLISH: Cooldown overlay on buttons ===== */
    button .cooldown-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), var(--focus-color));
      border-radius: 0 0 var(--radius-sm) var(--radius-sm);
      transition: width 0.1s linear;
      pointer-events: none;
    }

    /* ===== POLISH: Upgrade preview tooltip ===== */
    .upgrade-preview {
      font-size: 0.82em;
      color: #8fcf8f;
      margin-top: 4px;
      opacity: 0;
      transition: opacity 0.2s;
    }
    button:hover .upgrade-preview {
      opacity: 1;
    }

    /* ===== POLISH: Offline progress modal ===== */
    .offline-modal {
      text-align: center;
    }
    .offline-modal h3 {
      color: var(--accent);
      margin-bottom: 16px;
    }
    .offline-gains {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 16px;
      margin: 16px 0;
    }
    .offline-gains .gain-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid var(--border);
    }
    .offline-gains .gain-row:last-child {
      border-bottom: none;
    }
    .offline-gains .gain-value {
      color: var(--accent);
      font-weight: 700;
    }
    .offline-gains .gain-value.stamina {
      color: var(--stamina);
    }
    .offline-gains .gain-value.focus {
      color: var(--focus-color);
    }
  </style>
</head>
<body>
  <header id="topBar">
    <h1 class="game-title" aria-hidden="true">Mage Tower</h1>
    <div id="topCenter">
      <div class="resources">
        <div id="manaBlock" class="resource-block mana-block">
          <span class="main mana">Mana: <span id="mana">0</span> / <span id="manaMax">1000</span></span>
          <span class="sub">Mana/sec: <span id="manaPerSec">0</span></span>
          <div class="mini-progress" aria-hidden="true"><div id="manaFill" class="mini-fill"></div></div>
        </div>
        <div id="staminaBlock" class="resource-block stamina-block">
          <span class="main stamina">Stamina: <span id="stamina">0</span> / <span id="staminaMax">100</span></span>
          <span class="sub">Stamina/sec: <span id="staminaPerSec">0.20</span></span>
          <div class="mini-progress stamina" aria-hidden="true"><div id="staminaFill" class="mini-fill"></div></div>
        </div>
        <div id="focusBlock" class="resource-block focus-block">
          <span class="main focus">Focus: <span id="focus">0</span> / <span id="focusMax">100</span></span>
          <span class="sub">Focus/sec: <span id="focusPerSec">0</span> <span id="focusIdleHint">(after 60s idle)</span></span>
          <div class="mini-progress focus" aria-hidden="true"><div id="focusFill" class="mini-fill"></div></div>
        </div>
      </div>
      <div id="exhaustedHint" class="exhausted-hint" style="display:none"></div>
    </div>
    <div id="topActions">
      <div id="timeDilationStatus" class="spell-status-inline" style="display:none">
        <span class="label">Time Dilation</span>
        <span id="timeDilationTime" class="sub">0.0s left</span>
        <span id="timeDilationBoost" class="sub">Boost: x1.00</span>
        <div class="progress" style="width:80px;margin:0;"><div id="timeDilationFill" class="fill"></div></div>
      </div>
      <button id="settingsBtn" aria-label="Settings" type="button">&#9881;</button>
    </div>
  </header>

  <main id="main">
    <div id="towerContainer"></div>
  </main>

  <nav id="bottomNav">
    <button class="tab" data-panel="activitiesModal">
      <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v18M16 3v18M8 3h8a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/><path d="M10 8h4M10 12h4M10 16h2"/></svg>
      <span>Activities</span>
      <span class="tab-badge" aria-hidden="true"></span>
    </button>
    <button class="tab" data-panel="grimoireModal">
      <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/><path d="M8 7h8M8 11h8M8 15h4"/></svg>
      <span>Grimoire</span>
      <span class="tab-badge" aria-hidden="true"></span>
    </button>
    <button class="tab" data-panel="towerModal">
      <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="18" width="16" height="4" rx="1"/><rect x="9" y="12" width="6" height="6"/><rect x="7" y="6" width="10" height="6"/><rect x="10" y="2" width="4" height="4"/></svg>
      <span>Tower</span>
      <span class="tab-badge" aria-hidden="true"></span>
    </button>
    <button class="tab" data-panel="relicsModal">
      <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7-9 13-9-13z"/><path d="M3 9h18"/></svg>
      <span>Relics</span>
      <span class="tab-badge" aria-hidden="true"></span>
    </button>
    <button id="ascensionTab" class="tab tab-locked" data-panel="ascensionModal" title="Unlocks at 50 floors">
      <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l3 7 7 3-7 3-3 7-3-7-7-3 7-3 3-7z"/><path d="M12 8v8"/><path d="M8 12h8"/></svg>
      <span>Ascension</span>
      <span class="tab-badge" aria-hidden="true"></span>
    </button>
  </nav>

  <div id="activitiesModal" class="panel-modal">
    <div class="panel-content">
      <div class="panel-header">
        <h2>Activities</h2>
        <button class="panel-close" aria-label="Close" onclick="closePanel('activitiesModal')">&times;</button>
      </div>
      <p class="section-title">Spend stamina and focus to perform actions that will improve your tower and your magic.</p>
      <div id="activities"></div>
    </div>
  </div>

  <div id="grimoireModal" class="panel-modal">
    <div class="panel-content">
      <div class="panel-header">
        <h2>Grimoire</h2>
        <button class="panel-close" aria-label="Close" onclick="closePanel('grimoireModal')">&times;</button>
      </div>
      <div id="grimoireSpellSlots" class="grimoire-slots-stat"></div>
      <div id="grimoireSwapTimer" class="grimoire-swap-timer"></div>
      <p class="section-title">Active Spells</p>
      <div id="activeSpells"></div>
      <p class="section-title">Passive Spells</p>
      <div id="passiveSpells"></div>
    </div>
  </div>

  <div id="towerModal" class="panel-modal">
    <div class="panel-content">
      <div class="panel-header">
        <h2>Tower</h2>
        <button class="panel-close" aria-label="Close" onclick="closePanel('towerModal')">&times;</button>
      </div>
      <div class="stat floors-stat">Floors: <span id="floors" class="value">0</span></div>
      <div id="roomSummary" class="stat"></div>
      <div id="towerUpgradeButtons"></div>
      <div class="section-divider"></div>
      <p class="section-title">Tower Upgrades</p>
      <button id="manaFontBtn">Mana Font<span class="cost" id="manaFontCost"></span><span class="upgrade-preview" id="manaFontPreview"></span></button>
      <button id="towerBtn">Raise Tower Floor<span class="cost" id="towerCost"></span><span class="upgrade-preview" id="towerPreview"></span></button>
      <div class="section-divider"></div>
      <div id="prestigeSection" style="display:none">
        <p class="section-title">Prestige</p>
        <p class="cost" id="prestigeDesc"></p>
        <p class="cost" id="prestigeTokensEl">Prestige Tokens: 0</p>
        <div id="prestigeTokenChoices"></div>
        <button id="prestigeBtn">Prestige</button>
      </div>
    </div>
  </div>

  <div id="relicsModal" class="panel-modal">
    <div class="panel-content">
      <div class="panel-header">
        <h2>Relics</h2>
        <button class="panel-close" aria-label="Close" onclick="closePanel('relicsModal')">&times;</button>
      </div>
      <p class="section-title">Run relics (reset on prestige)</p>
      <div id="relicSummary" class="stat"></div>
      <div id="relicDraftSection" class="section-divider" style="margin-top:16px; display:none;">
        <p class="section-title">Relic draft available</p>
        <button id="relicDraftBtn">Choose a relic</button>
      </div>
    </div>
  </div>

  <div id="ascensionModal" class="panel-modal">
    <div class="panel-content">
      <div class="panel-header">
        <h2>Ascension</h2>
        <button class="panel-close" aria-label="Close" onclick="closePanel('ascensionModal')">&times;</button>
      </div>
      <p class="section-title">Restart your tower for permanent bonuses</p>
      <p class="cost" id="ascensionDesc"></p>
      <button id="ascendBtn">Ascend</button>
      <div id="paragonSection" class="section-divider" style="margin-top:16px; display:none;">
        <p class="section-title">Paragon (post-ascension)</p>
        <p class="cost" id="paragonXpEl">Paragon XP: 0</p>
        <div id="paragonNodes"></div>
      </div>
    </div>
  </div>

  <div id="roomModal" class="modal">
    <div class="modal-content" id="roomChoices"></div>
  </div>

  <div id="relicModal" class="modal">
    <div class="modal-content" id="relicChoices"></div>
  </div>

  <div id="settingsModal" class="modal">
    <div class="modal-content settings-content">
      <div class="settings-header">
        <h2>Settings</h2>
        <button type="button" class="settings-close" aria-label="Close" onclick="closeSettings()">&times;</button>
      </div>
      <div class="settings-tabs" role="tablist" aria-label="Settings tabs">
        <button type="button" id="settingsTabPrefs" class="settings-tab active" role="tab" aria-selected="true">General</button>
        <button type="button" id="settingsTabGlossary" class="settings-tab" role="tab" aria-selected="false">Glossary</button>
        <button type="button" id="settingsTabKeys" class="settings-tab" role="tab" aria-selected="false">Keybinds</button>
      </div>

      <div id="settingsPagePrefs" class="settings-page">
        <div class="settings-section">
          <p class="settings-section-title">Preferences</p>
          <div class="settings-row settings-toggle">
            <label for="soundCheckbox" class="settings-label">
              <input type="checkbox" id="soundCheckbox" class="settings-checkbox">
              <span class="settings-toggle-text">Sound effects</span>
            </label>
          </div>
          <div class="settings-row settings-toggle" style="margin-top:10px;">
            <label for="tutorialCheckbox" class="settings-label">
              <input type="checkbox" id="tutorialCheckbox" class="settings-checkbox">
              <span class="settings-toggle-text">Show “Quick start” helper</span>
            </label>
          </div>
          <button type="button" id="tutorialResetBtn" class="settings-btn" style="margin-top:10px;">Restart quick tutorial</button>
        </div>

        <div class="settings-section">
          <p class="settings-section-title">Progress</p>
          <button type="button" id="statsBtn" class="settings-btn">View statistics & achievements</button>
        </div>

        <div class="settings-section">
          <p class="settings-section-title">Save data</p>
          <button type="button" id="exportBtn" class="settings-btn">Export save to clipboard</button>
          <button type="button" id="importBtn" class="settings-btn">Import save from clipboard</button>
        </div>

        <div class="settings-section settings-section-danger">
          <p class="settings-section-title">Reset</p>
          <button type="button" onclick="resetGame()" class="settings-btn settings-btn-danger">Reset save (clear all progress)</button>
        </div>
      </div>

      <div id="settingsPageGlossary" class="settings-page hidden">
        <div class="settings-section">
          <p class="settings-section-title">Glossary</p>
          <div class="glossary-list">
            <div class="glossary-item">
              <div class="term">Mana</div>
              <div class="desc">Your main resource. Generated over time and by clicking the tower. Spend it on spells, rooms, and upgrades.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Stamina</div>
              <div class="desc">Recovers over time. Spend it in Activities to gain permanent or run-long bonuses.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Focus</div>
              <div class="desc">Regenerates after resting (idle). Used to cast powerful spells and perform focused activities.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Mana Fonts</div>
              <div class="desc">Passive generators that increase mana/sec. Boosted by floors, sigils, and certain rooms.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Floors & Rooms</div>
              <div class="desc">Each new floor adds a room. Rooms provide bonuses to mana, stamina, or spell effects.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Activities</div>
              <div class="desc">Actions that consume stamina and focus to provide upgrades, buffs, or resources.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Spells</div>
              <div class="desc">Active spells give short bursts; passive spells give permanent boosts when memorized.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Prestige & Ascension</div>
              <div class="desc">Reset progress for permanent bonuses. Ascension is a higher reset tier than Prestige.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Relics</div>
              <div class="desc">Run-based modifiers earned from milestones or Relic Hunts. They reshape your build.</div>
            </div>
            <div class="glossary-item">
              <div class="term">Sigils</div>
              <div class="desc">Stacks that boost Mana Font output. Forged via Activities and reset on Prestige.</div>
            </div>
          </div>
        </div>
      </div>

      <div id="settingsPageKeys" class="settings-page hidden">
        <div class="settings-section">
          <p class="settings-section-title">Keybinds</p>
          <div id="keybindsList" class="keybinds-list"></div>
          <p class="cost" style="margin-top:10px;">
            Tips: Shift-click = x10 and Ctrl-click = max for Mana Fonts + room upgrades.
          </p>
        </div>
      </div>
    </div>
  </div>

  <div id="statsModal" class="modal">
    <div class="modal-content">
      <h3>Statistics</h3>
      <div id="statsGrid" class="stats-grid"></div>
      <h4 style="margin-top:16px;">Achievements</h4>
      <div id="achievementsList"></div>
      <button onclick="closeStats()">Close</button>
    </div>
  </div>

  <div id="introModal" class="modal">
    <div class="modal-content intro-content">
      <h3>Welcome to Mage Tower</h3>
      <div class="intro-lore">
        <p><strong>Why you're here:</strong> You are a mage who has claimed a leyline nexus. To channel its power and grow in influence, you must raise a tower—room by room—so your connection to the mana flow deepens. Each floor and every chamber you build strengthens your hold on the nexus and unlocks new spells and abilities.</p>
      </div>
      <div class="intro-how">
        <p><strong>How to play:</strong></p>
        <ul>
          <li><strong>Mana</strong> is earned over time; buy Mana Fonts and build tower floors to increase the rate.</li>
          <li><strong>Stamina</strong> recovers over time; spend it in <strong>Activities</strong> (Study, Harvest, etc.) to raise max mana, gain passive bonuses, and more.</li>
          <li>Open the <strong>Tower</strong> tab to add new floors (each floor lets you build one room). Rooms boost mana, stamina, or spell power.</li>
          <li>Unlock and cast spells from the <strong>Grimoire</strong> (Time Dilation, Leyline Manipulation, etc.) to multiply gains.</li>
          <li>Click a built room in the tower view to see its description and upgrade it.</li>
          <li>Reach relic milestones (and Relic Hunts) to draft run-based relics that reshape your build.</li>
        </ul>
      </div>
      <button id="introCloseBtn">Got it</button>
    </div>
  </div>

  <div id="roomDetailModal" class="modal">
    <div class="modal-content room-detail-content">
      <div class="room-detail-header">
        <h3 id="roomDetailTitle">Room</h3>
        <button type="button" class="room-detail-close" id="roomDetailClose" aria-label="Close">&times;</button>
      </div>
      <p id="roomDetailDesc" class="room-detail-desc"></p>
      <p class="room-detail-level">Level: <span id="roomDetailLevel">1</span></p>
      <button id="roomDetailUpgradeBtn" class="room-detail-upgrade">Upgrade</button>
    </div>
  </div>

  <div id="tutorialLayer" aria-hidden="true"></div>
  <div id="loreTip" class="tutorial-tip pos-bottom">
    <strong>Why you're here</strong><br>
    You are a mage who has claimed a leyline nexus. To channel its power and grow in influence, you must raise a tower—room by room—so your connection to the mana flow deepens.
    <button type="button" id="loreCloseBtn" class="lore-close">Got it</button>
  </div>
  <div id="toastContainer"></div>

  <div id="offlineModal" class="modal">
    <div class="modal-content offline-modal">
      <h3>Welcome Back!</h3>
      <p>You were away for <span id="offlineTime">0</span></p>
      <div class="offline-gains">
        <div class="gain-row">
          <span>Mana earned:</span>
          <span id="offlineMana" class="gain-value">+0</span>
        </div>
        <div class="gain-row">
          <span>Stamina recovered:</span>
          <span id="offlineStamina" class="gain-value stamina">+0</span>
        </div>
        <div class="gain-row">
          <span>Focus gained:</span>
          <span id="offlineFocus" class="gain-value focus">+0</span>
        </div>
      </div>
      <button id="offlineCloseBtn">Continue</button>
    </div>
  </div>

  <script>
    // -------------------- CONSTANTS --------------------
    const TICK = 100;
    const SCALE = 1;
    const FLOOR_BONUS = 0.01;
    const UNLOCKS = { TIME: 5, ARCANE: 10, ASTRAL: 20 };
    const MANA_FONT_RATE = 0.1;
    const PRESTIGE_FLOOR = 50;
    const PRESTIGE_SOFT_FLOOR = 25;
    const PRESTIGE_BONUS = 0.10;
    const PRESTIGE_SOFT_BONUS = 0.05;
    const ASCENSION_FLOOR = 100;
    const ASCENSION_FLOOR_2 = 150;
    const ASCENSION_TAB_UNLOCK = 50;
    const ASCENSION_BONUS_PER = 0.02;
    const ASCENSION_2_BONUS_PER = 0.03;
    const PRESTIGE_KEEP_FLOORS_PCT = 0.03;
    const OFFLINE_CAP_HOURS = 24;
    const LEYLINE_TAP_DURATION = 22;
    const LEYLINE_TAP_PCT = 0.25;
    const RITUAL_OF_BINDING_COOLDOWN_MS = 60 * 60 * 1000;
    const RITUAL_ACTIVITY_COOLDOWN_MS = 30 * 60 * 1000;
    const SPELL_ECHO_FREE_COOLDOWN_MS = 15 * 60 * 1000;
    const MEDITATE_CAP = 5;
    const MEDITATE_PCT_PER_STACK = 0.05;
    const PARAGON_FLOOR_MIN = 100;
    const PARAGON_NODE_COST = 10;
    const PARAGON_XP_PER_TICK = 0.003;
    const GOAL_MANA_PER_SEC = 1e6;
    const VAULT_CAP = 0.50;
    const LIBRARY_LEYLINE_PCT = 0.01;
    const BASE_MANA_MAX = 1000;
    const BASE_STAMINA_MAX = 100;
    const STAMINA_REGEN_BASE = 0.12;
    const STAMINA_REGEN_CAP = 1.0;
    const STAMINA_ROOM_BONUS_CAP = 0.50;
    const TOWER_STRAIN_FLOOR = 40;
    const TOWER_STRAIN_PCT_PER_10 = 0.10;
    const EXHAUSTED_DURATION_MS = 2 * 60 * 1000;
    const FLOOR_STAMINA_COST_PCT = 0.08;
    const BASE_FOCUS_MAX = 100;
    const FOCUS_REGEN_BASE = 0.1;
    const FOCUS_IDLE_SEC = 60;
    const FOCUS_OFFLINE_DIVISOR = 8;
    const OFFLINE_FOCUS_RATE = 0.25;
    const SIGIL_STACK_PCT = 0.02;
    const SIGIL_STACK_CAP = 12;
    const RELIC_MILESTONES = [6, 16, 30, 50, 75, 100, 140, 180];
    const RELIC_HUNT_COOLDOWN_MS = 25 * 60 * 1000;

    let game;
    let awaitingRebind = null;

    // -------------------- NUMBER FORMATTING --------------------
    function formatNum(n) {
      if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B';
      if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M';
      if (n >= 1e3) return (n / 1e3).toFixed(2) + 'K';
      return n.toFixed(1);
    }
    function formatRate(n) {
      if (n >= 1e3) return formatNum(n);
      if (n >= 10) return n.toFixed(1);
      if (n >= 1) return n.toFixed(2);
      if (n >= 0.01) return n.toFixed(3);
      return n.toFixed(2);
    }

    function clamp01(x) { return Math.max(0, Math.min(1, x)); }
    function setMiniBar(fillEl, value, max) {
      if (!fillEl) return;
      const pct = max > 0 ? clamp01(value / max) * 100 : 0;
      fillEl.style.width = pct.toFixed(1) + '%';
    }
    function setTabBadge(panelId, on) {
      const tab = document.querySelector('#bottomNav .tab[data-panel="' + panelId + '"]');
      if (!tab) return;
      if (on) tab.classList.add('has-badge');
      else tab.classList.remove('has-badge');
    }

    // -------------------- POLISH HELPER FUNCTIONS --------------------
    function updateResourceFullState(el, value, max) {
      if (!el) return;
      const isFull = value >= max * 0.99;
      if (isFull) el.classList.add('resource-full');
      else el.classList.remove('resource-full');
    }

    function showSaveIndicator(saving) {
      return;
    }

    function formatDuration(ms) {
      const sec = Math.floor(ms / 1000);
      if (sec < 60) return sec + ' seconds';
      const min = Math.floor(sec / 60);
      if (min < 60) return min + ' minute' + (min !== 1 ? 's' : '');
      const hr = Math.floor(min / 60);
      const remainMin = min % 60;
      if (hr < 24) return hr + ' hour' + (hr !== 1 ? 's' : '') + (remainMin > 0 ? ' ' + remainMin + ' min' : '');
      const days = Math.floor(hr / 24);
      const remainHr = hr % 24;
      return days + ' day' + (days !== 1 ? 's' : '') + (remainHr > 0 ? ' ' + remainHr + ' hr' : '');
    }

    function showOfflineProgress(manaGained, staminaGained, focusGained, duration) {
      const modal = document.getElementById('offlineModal');
      if (!modal) return;
      if (manaGained < 1 && staminaGained < 1 && focusGained < 1) return;
      if (duration < 60000) return;
      const closeBtn = document.getElementById('offlineCloseBtn');
      if (closeBtn) {
        closeBtn.onclick = () => { modal.style.display = 'none'; };
      }
      document.getElementById('offlineTime').textContent = formatDuration(duration);
      document.getElementById('offlineMana').textContent = '+' + formatNum(manaGained);
      document.getElementById('offlineStamina').textContent = '+' + formatNum(staminaGained);
      document.getElementById('offlineFocus').textContent = '+' + formatNum(focusGained);
      modal.style.display = 'flex';
    }

    // -------------------- ROOMS --------------------
    const ROOMS = {
      Stairs: { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec per Stairs', buildableOnce: false },
      Vault: { unlock: () => true, unlockFloors: 0, desc: '+5% mana/sec per level (capped 50%). Build once, then upgrade.', buildableOnce: true, manaPct: 0.05, capMana: true },
      Library: { unlock: () => totalFloors() >= UNLOCKS.ARCANE, unlockFloors: UNLOCKS.ARCANE, desc: '+20% Leyline effect per level. Build once, then upgrade.', buildableOnce: true, spellPct: 0.20 },
      Observatory: { unlock: () => totalFloors() >= UNLOCKS.ASTRAL, unlockFloors: UNLOCKS.ASTRAL, desc: 'Boosts Astral Insight +10% per level. Build once, then upgrade.', buildableOnce: true, astralPct: 0.10 },
      Arcanum: { unlock: () => totalFloors() >= 20, unlockFloors: 20, desc: '+1 spell slot. Unlocks at 20 floors.', buildableOnce: true, extraSpellSlots: 1 },
      'Hall of Preservation': { unlock: () => totalFloors() >= 30, unlockFloors: 30, desc: 'Prestige keeps 3% of current floors (as Stairs).', buildableOnce: true, prestigeKeepFloorsPct: 0.03 },
      'Chronurgy Chamber': { unlock: () => totalFloors() >= 40, unlockFloors: 40, desc: '-10% spell-swap cooldown time per level.', buildableOnce: true, swapCooldownReduction: 0.10 },
      'Leyline Nexus': { unlock: () => totalFloors() >= 50, unlockFloors: 50, desc: '+1% mana/sec per Leyline Manipulation level.', buildableOnce: true, leylineNexusPct: 0.01 },
      'Alchemy Lab': { unlock: () => true, unlockFloors: 0, desc: '+0.5% mana/sec per level.', buildableOnce: true, manaPct: 0.005 },
      Scriptorium: { unlock: () => true, unlockFloors: 0, desc: '+0.4% spell effect per level.', buildableOnce: true, spellPct: 0.004 },
      'Meditation Chamber': { unlock: () => true, unlockFloors: 0, desc: '+1% stamina regen per level.', buildableOnce: true, staminaPct: 0.01 },
      'Crystal Storage': { unlock: () => true, unlockFloors: 0, desc: '+0.3% mana/sec per level.', buildableOnce: true, manaPct: 0.003 },
      'Herb Garden': { unlock: () => true, unlockFloors: 0, desc: '+0.25% mana/sec per level.', buildableOnce: true, manaPct: 0.0025 },
      'Summoning Circle': { unlock: () => true, unlockFloors: 0, desc: '+0.35% mana/sec per level.', buildableOnce: true, manaPct: 0.0035 },
      'Enchantment Table': { unlock: () => true, unlockFloors: 0, desc: '+0.3% spell effect per level.', buildableOnce: true, spellPct: 0.003 },
      Wardstone: { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec per level.', buildableOnce: true, manaPct: 0.002 },
      'Leyline Tap': { unlock: () => true, unlockFloors: 0, desc: '+0.25% mana/sec per level.', buildableOnce: true, manaPct: 0.0025 },
      'Scrying Pool': { unlock: () => true, unlockFloors: 0, desc: '+0.5% stamina regen per level.', buildableOnce: true, staminaPct: 0.005 },
      'Bell Tower': { unlock: () => true, unlockFloors: 0, desc: '+0.15% mana/sec per level.', buildableOnce: true, manaPct: 0.0015 },
      Brewery: { unlock: () => true, unlockFloors: 0, desc: '+0.3% mana/sec per level.', buildableOnce: true, manaPct: 0.003 },
      Archive: { unlock: () => true, unlockFloors: 0, desc: '+0.35% spell effect per level.', buildableOnce: true, spellPct: 0.0035 },
      Greenhouse: { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec per level.', buildableOnce: true, manaPct: 0.002 },
      Workshop: { unlock: () => true, unlockFloors: 0, desc: '+0.4% spell effect per level.', buildableOnce: true, spellPct: 0.004 },
      Sanctum: { unlock: () => true, unlockFloors: 0, desc: '+0.15% mana/sec and +1.5% stamina per level.', buildableOnce: true, manaPct: 0.0015, staminaPct: 0.015 },
      Atrium: { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec per level.', buildableOnce: true, manaPct: 0.001 },
      'Ritual Chamber': { unlock: () => true, unlockFloors: 0, desc: '+0.4% mana/sec per level.', buildableOnce: true, manaPct: 0.004 },
      Reliquary: { unlock: () => true, unlockFloors: 0, desc: '+0.2% spell effect per level.', buildableOnce: true, spellPct: 0.002 },
      Conservatory: { unlock: () => true, unlockFloors: 0, desc: '+0.25% stamina regen per level.', buildableOnce: true, staminaPct: 0.0025 },
      'Lantern Room': { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec per level.', buildableOnce: true, manaPct: 0.001 },
      Dispensary: { unlock: () => true, unlockFloors: 0, desc: '+0.2% stamina regen per level.', buildableOnce: true, staminaPct: 0.002 },
      Lectern: { unlock: () => true, unlockFloors: 0, desc: '+0.3% spell effect per level.', buildableOnce: true, spellPct: 0.003 },
      Spire: { unlock: () => true, unlockFloors: 0, desc: '+0.15% mana/sec per level.', buildableOnce: true, manaPct: 0.0015 },
      Antechamber: { unlock: () => true, unlockFloors: 0, desc: '+0.1% stamina regen per level.', buildableOnce: true, staminaPct: 0.001 },
      'Conduit Room': { unlock: () => true, unlockFloors: 0, desc: '+0.35% mana/sec per level.', buildableOnce: true, manaPct: 0.0035 },
      'Offering Shrine': { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec and +0.1% spell per level.', buildableOnce: true, manaPct: 0.002, spellPct: 0.001 },
      Vestibule: { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec per level.', buildableOnce: true, manaPct: 0.001 },
      Turret: { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec per level.', buildableOnce: true, manaPct: 0.002 },
      // More immersive mage tower rooms (all available from floor 0)
      Cloister: { unlock: () => true, unlockFloors: 0, desc: '+0.15% stamina regen per level.', buildableOnce: true, staminaPct: 0.0015 },
      Refinery: { unlock: () => true, unlockFloors: 0, desc: '+0.25% mana/sec per level.', buildableOnce: true, manaPct: 0.0025 },
      'Mana Well': { unlock: () => true, unlockFloors: 0, desc: '+0.3% mana/sec per level.', buildableOnce: true, manaPct: 0.003 },
      'Star Chart Room': { unlock: () => true, unlockFloors: 0, desc: '+0.2% spell effect per level.', buildableOnce: true, spellPct: 0.002 },
      'Echo Chamber': { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec per level.', buildableOnce: true, manaPct: 0.001 },
      'Dust Vault': { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec per level.', buildableOnce: true, manaPct: 0.002 },
      'Ritual Altar': { unlock: () => true, unlockFloors: 0, desc: '+0.35% mana/sec per level.', buildableOnce: true, manaPct: 0.0035 },
      'Candle Hall': { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec per level.', buildableOnce: true, manaPct: 0.001 },
      'Ink Room': { unlock: () => true, unlockFloors: 0, desc: '+0.25% spell effect per level.', buildableOnce: true, spellPct: 0.0025 },
      'Quill Desk': { unlock: () => true, unlockFloors: 0, desc: '+0.2% spell effect per level.', buildableOnce: true, spellPct: 0.002 },
      'Astrolabe Room': { unlock: () => true, unlockFloors: 0, desc: '+0.15% mana/sec per level.', buildableOnce: true, manaPct: 0.0015 },
      'Gargoyle Perch': { unlock: () => true, unlockFloors: 0, desc: '+0.15% mana/sec per level.', buildableOnce: true, manaPct: 0.0015 },
      'Sigil Wall': { unlock: () => true, unlockFloors: 0, desc: '+0.3% spell effect per level.', buildableOnce: true, spellPct: 0.003 },
      'Rune Stone': { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec and +0.1% spell per level.', buildableOnce: true, manaPct: 0.002, spellPct: 0.001 },
      'Potion Cellar': { unlock: () => true, unlockFloors: 0, desc: '+0.3% mana/sec per level.', buildableOnce: true, manaPct: 0.003 },
      'Mortar Room': { unlock: () => true, unlockFloors: 0, desc: '+0.25% mana/sec per level.', buildableOnce: true, manaPct: 0.0025 },
      'Divination Den': { unlock: () => true, unlockFloors: 0, desc: '+0.4% spell effect per level.', buildableOnce: true, spellPct: 0.004 },
      'Oracle Nook': { unlock: () => true, unlockFloors: 0, desc: '+0.2% stamina regen per level.', buildableOnce: true, staminaPct: 0.002 },
      'Sanctified Hall': { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec and +1% stamina per level.', buildableOnce: true, manaPct: 0.001, staminaPct: 0.01 },
      'Chime Room': { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec per level.', buildableOnce: true, manaPct: 0.001 },
      'Brazier Room': { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec per level.', buildableOnce: true, manaPct: 0.002 },
      'Crystal Ball Room': { unlock: () => true, unlockFloors: 0, desc: '+0.35% spell effect per level.', buildableOnce: true, spellPct: 0.0035 },
      'Mirror Hall': { unlock: () => true, unlockFloors: 0, desc: '+0.15% mana/sec per level.', buildableOnce: true, manaPct: 0.0015 },
      'Shadow Alcove': { unlock: () => true, unlockFloors: 0, desc: '+0.25% spell effect per level.', buildableOnce: true, spellPct: 0.0025 },
      'Fountain Court': { unlock: () => true, unlockFloors: 0, desc: '+0.2% stamina regen per level.', buildableOnce: true, staminaPct: 0.002 },
      'Well of Whispers': { unlock: () => true, unlockFloors: 0, desc: '+0.3% mana/sec per level.', buildableOnce: true, manaPct: 0.003 },
      'Binding Circle': { unlock: () => true, unlockFloors: 0, desc: '+0.3% spell effect per level.', buildableOnce: true, spellPct: 0.003 },
      'Focus Chamber': { unlock: () => true, unlockFloors: 0, desc: '+0.4% stamina regen per level.', buildableOnce: true, staminaPct: 0.004 },
      'Resonance Hall': { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec per level.', buildableOnce: true, manaPct: 0.002 },
      'Aether Pool': { unlock: () => true, unlockFloors: 0, desc: '+0.4% mana/sec per level.', buildableOnce: true, manaPct: 0.004 },
      'Weather Vane': { unlock: () => true, unlockFloors: 0, desc: '+0.1% mana/sec per level.', buildableOnce: true, manaPct: 0.001 },
      'Lectern Hall': { unlock: () => true, unlockFloors: 0, desc: '+0.25% spell effect per level.', buildableOnce: true, spellPct: 0.0025 },
      'Grimoire Shelf': { unlock: () => true, unlockFloors: 0, desc: '+0.2% spell effect per level.', buildableOnce: true, spellPct: 0.002 },
      'Essence Still': { unlock: () => true, unlockFloors: 0, desc: '+0.35% mana/sec per level.', buildableOnce: true, manaPct: 0.0035 },
      'Ward Chamber': { unlock: () => true, unlockFloors: 0, desc: '+0.15% stamina regen per level.', buildableOnce: true, staminaPct: 0.0015 },
      'Beacon Tower': { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec per level.', buildableOnce: true, manaPct: 0.002 },
      Solarium: { unlock: () => true, unlockFloors: 0, desc: '+0.15% mana/sec and +1% stamina per level.', buildableOnce: true, manaPct: 0.0015, staminaPct: 0.01 },
      Crypt: { unlock: () => true, unlockFloors: 0, desc: '+0.25% mana/sec per level.', buildableOnce: true, manaPct: 0.0025 },
      'Offering Table': { unlock: () => true, unlockFloors: 0, desc: '+0.2% mana/sec and +0.1% spell per level.', buildableOnce: true, manaPct: 0.002, spellPct: 0.001 },
      'Prism Room': { unlock: () => true, unlockFloors: 0, desc: '+0.3% spell effect per level.', buildableOnce: true, spellPct: 0.003 },
      'Smoke Alcove': { unlock: () => true, unlockFloors: 0, desc: '+0.2% stamina regen per level.', buildableOnce: true, staminaPct: 0.002 },
      'Tome Vault': { unlock: () => true, unlockFloors: 0, desc: '+0.35% spell effect per level.', buildableOnce: true, spellPct: 0.0035 },
      'Cauldron Nook': { unlock: () => true, unlockFloors: 0, desc: '+0.3% mana/sec per level.', buildableOnce: true, manaPct: 0.003 },
      'Pilgrim Rest': { unlock: () => true, unlockFloors: 0, desc: '+0.25% stamina regen per level.', buildableOnce: true, staminaPct: 0.0025 },
      'Apprentice Quarters': { unlock: () => totalFloors() >= 5, unlockFloors: 5, desc: '+5% max mana per level.', buildableOnce: true, manaCapPct: 0.05 },
      'Focus Alcove': { unlock: () => totalFloors() >= 12, unlockFloors: 12, desc: 'Focus regen starts 5% sooner and +2% focus regen per level.', buildableOnce: true, focusIdlePct: -0.05, focusPct: 0.02 },
      'Aether Loom': { unlock: () => totalFloors() >= 30, unlockFloors: 30, desc: '+4% Mana Font output per level.', buildableOnce: true, fontPct: 0.04 },
      'Sigil Vault': { unlock: () => totalFloors() >= 45, unlockFloors: 45, desc: 'Room upgrades cost 5% less per level.', buildableOnce: true, upgradeCostPct: -0.05 },
      'Curio Gallery': { unlock: () => totalFloors() >= 70, unlockFloors: 70, desc: '+1% mana/sec per relic per level.', buildableOnce: true, relicManaPct: 0.01 },
      'Planar Gate': { unlock: () => totalFloors() >= 90, unlockFloors: 90, desc: '+4% active spell and ritual duration per level.', buildableOnce: true, activeDurationPct: 0.04 },
    };
    const RELICS = [
      { id: 'glimmerstone', name: 'Glimmerstone', tier: 'common', desc: '+8% mana/sec.', mods: { manaMult: 0.08 } },
      { id: 'scribeCharm', name: 'Scribe Charm', tier: 'common', desc: '+30% click mana.', mods: { clickMult: 0.30 } },
      { id: 'glyphThread', name: 'Glyph Thread', tier: 'common', desc: '+10% Mana Font output.', mods: { fontRateMult: 0.10 } },
      { id: 'fadedTalisman', name: 'Faded Talisman', tier: 'common', desc: '+12% stamina regen.', mods: { staminaRegenMult: 0.12 } },
      { id: 'quietHourglass', name: 'Quiet Hourglass', tier: 'common', desc: 'Focus regen starts 15% sooner.', mods: { focusIdleMult: -0.15 } },
      { id: 'sapphirePrism', name: 'Sapphire Prism', tier: 'uncommon', desc: '+12% spell effect.', mods: { spellEffectMult: 0.12 } },
      { id: 'ironSigil', name: 'Iron Sigil', tier: 'uncommon', desc: '+25 max stamina.', mods: { maxStaminaBonus: 25 } },
      { id: 'lucentCandle', name: 'Lucent Candle', tier: 'uncommon', desc: '+15% focus regen.', mods: { focusRegenMult: 0.15 } },
      { id: 'mindstone', name: 'Mindstone', tier: 'uncommon', desc: '+20 max focus.', mods: { maxFocusBonus: 20 } },
      { id: 'glassEngine', name: 'Glass Engine', tier: 'uncommon', desc: '+15% mana/sec, -8% stamina regen.', mods: { manaMult: 0.15, staminaRegenMult: -0.08 } },
      { id: 'etchingTools', name: 'Etching Tools', tier: 'uncommon', desc: 'Room upgrades cost 8% less.', mods: { upgradeCostMult: -0.08 } },
      { id: 'eclipseSeal', name: 'Eclipse Seal', tier: 'rare', desc: '+25% mana/sec, floor costs +12%.', mods: { manaMult: 0.25, floorCostMult: 0.12 } },
      { id: 'goldenLoop', name: 'Golden Loop', tier: 'rare', desc: '+15% active spell duration and +10% max mana.', mods: { activeDurationMult: 0.15, maxManaMult: 0.10 } },
      { id: 'voidCompass', name: 'Void Compass', tier: 'rare', desc: '+20% spell effect, -10% mana/sec.', mods: { spellEffectMult: 0.20, manaMult: -0.10 } },
    ];
    const RELIC_BY_ID = RELICS.reduce((acc, relic) => {
      acc[relic.id] = relic;
      return acc;
    }, {});
    const SPECIAL_ROOM_NAMES = Object.keys(ROOMS).filter(n => ROOMS[n].buildableOnce);
    function initialSpecialRooms() {
      const o = {};
      SPECIAL_ROOM_NAMES.forEach(n => { o[n] = { built: false, level: 0 }; });
      return o;
    }
    const KEYBIND_DEFAULTS = {
      activities: '1',
      grimoire: '2',
      tower: '3',
      ascension: '4',
      relics: '5',
      manaFont: 'm',
      settings: 's',
      help: '?',
      close: 'esc',
    };
    const KEYBIND_ACTIONS = [
      { id: 'activities', label: 'Toggle Activities' },
      { id: 'grimoire', label: 'Toggle Grimoire' },
      { id: 'tower', label: 'Toggle Tower' },
      { id: 'ascension', label: 'Toggle Ascension (when unlocked)' },
      { id: 'relics', label: 'Toggle Relics' },
      { id: 'manaFont', label: 'Buy Mana Font (Tower)' },
      { id: 'settings', label: 'Open/close Settings' },
      { id: 'help', label: 'Open “How to play”' },
      { id: 'close', label: 'Close overlays' },
    ];
    game = {
      mana: 0,
      stamina: 0,
      focus: 0,
      manaFonts: 0,
      specialRooms: initialSpecialRooms(),
      stairs: 0,
      passive: { arcane: 0, astral: 0, conduit: 0, towerBond: 0, staminaWell: 0, spellEcho: 0, focusFlow: 0, manaReservoir: 0, ritualMastery: 0, aetherFlux: 0, anchoredRituals: 0 },
      active: {
        boost: 1,
        timer: 0,
        duration: 0,
        cooldown: 0,
        harvestTimer: 0,
        harvestDuration: 0,
        boostTD: 1,
        boostHarvest: 1,
        leylineTapTimer: 0,
        leylineTapPct: 0,
        runeTimer: 0,
        runeStacks: 0,
        focusCondenserTimer: 0,
        spellCostDiscountTimer: 0,
        spellCostDiscountPct: 0,
        overclockTimer: 0,
        overclockMult: 1,
        worldweaveTimer: 0,
        convergenceTimer: 0,
        paradoxTimer: 0,
      },
      studyCount: 0,
      stats: {
        timeDilationCasts: 0,
        arcaneHarvestCasts: 0,
        leylineSurgeCasts: 0,
        focusSurgeCasts: 0,
        vigorInfusionCasts: 0,
        transmutateCasts: 0,
        manaCapHits: 0,
        zeroManaCasts: 0,
        totalManaEarned: 0,
        totalSpellsCast: 0,
        timePlayedMs: 0,
        achievements: [],
        totalFloorsEver: 0,
        totalStaminaSpent: 0,
        maxFloorsReached: 0,
        maxManaPerSecReached: 0,
      },
      prestige: 0,
      softPrestige: 0,
      ascension: 0,
      ascensionTier2: 0,
      prestigeTokens: 0,
      prestigeTokenChoice: null,
      soundEnabled: false,
      settings: { showTutorial: true, keybinds: { ...KEYBIND_DEFAULTS } },
      lastSave: Date.now(),
      memorizedSpells: [],
      spellSwapCooldownEnd: 0,
      wardOfPreservationUsed: false,
      ritualOfBindingCooldownEnd: 0,
      ritualOfBindingNextSwapHalved: false,
      meditateStacks: 0,
      scryLockedRoom: null,
      transcribeBonusPct: 0,
      ritualBuffEnd: 0,
      attuneDiscount: 0,
      ritualActivityCooldownEnd: 0,
      spellEchoNextFreeAt: 0,
      transmutateCooldownEnd: 0,
      manaSiphonCooldownEnd: 0,
      runeAccretionCooldownEnd: 0,
      staminaTransmuteCooldownEnd: 0,
      focusCondenserCooldownEnd: 0,
      leylineResonanceCooldownEnd: 0,
      towerPulseCooldownEnd: 0,
      chronoLoopCooldownEnd: 0,
      nexusOverclockCooldownEnd: 0,
      worldweaveCooldownEnd: 0,
      convergenceCooldownEnd: 0,
      paradoxCastCooldownEnd: 0,
      relics: [],
      relicDraft: [],
      relicDraftSeen: false,
      sigilStacks: 0,
      relicHuntCooldownEnd: 0,
      floorsKept: 0,
      nextFloorDuplicate: null,
      nextFloorCursed: false,
      nextFloorBonus: false,
      nextFloorDiscountPct: 0,
      paragonXp: 0,
      paragonSpent: { manaPct: 0, spellEffect: 0, stamina: 0, focus: 0 },
      lastActivityOrSpellAt: 0,
      exhaustedUntil: 0,
      wasManaCapped: false,
      tutorial: { clicked: false, done: false, completedToast: false, settingsOpened: false, keysSeen: false, glossarySeen: false },
    };
    const STAIRS_MANA_PCT = 0.001;
    const UPGRADE_COST_BASE = 80;

    // -------------------- UI ELEMENTS --------------------
    const mana = document.getElementById('mana');
    const manaPerSec = document.getElementById('manaPerSec');
    const staminaEl = document.getElementById('stamina');
    const staminaMaxEl = document.getElementById('staminaMax');
    const staminaPerSecEl = document.getElementById('staminaPerSec');
    const focusEl = document.getElementById('focus');
    const focusMaxEl = document.getElementById('focusMax');
    const focusPerSecEl = document.getElementById('focusPerSec');
    const focusIdleHint = document.getElementById('focusIdleHint');
    const exhaustedHint = document.getElementById('exhaustedHint');
    const floors = document.getElementById('floors');
    const roomSummary = document.getElementById('roomSummary');
    const towerUpgradeButtons = document.getElementById('towerUpgradeButtons');
    const grimoireSpellSlotsEl = document.getElementById('grimoireSpellSlots');
    const grimoireSwapTimerEl = document.getElementById('grimoireSwapTimer');
    const activeSpellsDiv = document.getElementById('activeSpells');
    const passiveSpellsDiv = document.getElementById('passiveSpells');
    const manaFontBtn = document.getElementById('manaFontBtn');
    const manaFontCostEl = document.getElementById('manaFontCost');
    const manaFontPreview = document.getElementById('manaFontPreview');
    const towerBtn = document.getElementById('towerBtn');
    const towerCostEl = document.getElementById('towerCost');
    const towerPreview = document.getElementById('towerPreview');
    const towerContainer = document.getElementById('towerContainer');
    const roomModal = document.getElementById('roomModal');
    const roomChoices = document.getElementById('roomChoices');
    const relicModal = document.getElementById('relicModal');
    const relicChoices = document.getElementById('relicChoices');
    const relicSummary = document.getElementById('relicSummary');
    const relicDraftSection = document.getElementById('relicDraftSection');
    const relicDraftBtn = document.getElementById('relicDraftBtn');
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const prestigeBtn = document.getElementById('prestigeBtn');
    const prestigeDesc = document.getElementById('prestigeDesc');
    const prestigeSection = document.getElementById('prestigeSection');
    const ascensionTab = document.getElementById('ascensionTab');
    const relicTab = document.querySelector('#bottomNav .tab[data-panel="relicsModal"]');
    const ascensionDesc = document.getElementById('ascensionDesc');
    const ascendBtn = document.getElementById('ascendBtn');
    const timeDilationStatus = document.getElementById('timeDilationStatus');
    const timeDilationTime = document.getElementById('timeDilationTime');
    const timeDilationFill = document.getElementById('timeDilationFill');
    const timeDilationBoost = document.getElementById('timeDilationBoost');
    const manaMaxEl = document.getElementById('manaMax');
    const manaFillEl = document.getElementById('manaFill');
    const staminaFillEl = document.getElementById('staminaFill');
    const focusFillEl = document.getElementById('focusFill');
    const tutorialLayer = document.getElementById('tutorialLayer');
    const towerTab = document.querySelector('#bottomNav .tab[data-panel="towerModal"]');
    const activitiesTab = document.querySelector('#bottomNav .tab[data-panel="activitiesModal"]');
    const activitiesDiv = document.getElementById('activities');
    const soundCheckbox = document.getElementById('soundCheckbox');
    const tutorialCheckbox = document.getElementById('tutorialCheckbox');
    const tutorialResetBtn = document.getElementById('tutorialResetBtn');
    const settingsTabPrefs = document.getElementById('settingsTabPrefs');
    const settingsTabKeys = document.getElementById('settingsTabKeys');
    const settingsTabGlossary = document.getElementById('settingsTabGlossary');
    const settingsPagePrefs = document.getElementById('settingsPagePrefs');
    const settingsPageKeys = document.getElementById('settingsPageKeys');
    const settingsPageGlossary = document.getElementById('settingsPageGlossary');
    const statsModal = document.getElementById('statsModal');
    const introModal = document.getElementById('introModal');
    const introCloseBtn = document.getElementById('introCloseBtn');
    const roomDetailModal = document.getElementById('roomDetailModal');
    const roomDetailClose = document.getElementById('roomDetailClose');
    const roomDetailTitle = document.getElementById('roomDetailTitle');
    const roomDetailDesc = document.getElementById('roomDetailDesc');
    const roomDetailLevel = document.getElementById('roomDetailLevel');
    const roomDetailUpgradeBtn = document.getElementById('roomDetailUpgradeBtn');
    const statsGrid = document.getElementById('statsGrid');
    const achievementsList = document.getElementById('achievementsList');
    const paragonSection = document.getElementById('paragonSection');
    const paragonXpEl = document.getElementById('paragonXpEl');
    const paragonNodes = document.getElementById('paragonNodes');
    const loreTip = document.getElementById('loreTip');
    const loreCloseBtn = document.getElementById('loreCloseBtn');
    const keybindsList = document.getElementById('keybindsList');
    const toastContainer = document.getElementById('toastContainer');
    const manaBlock = document.getElementById('manaBlock');
    const staminaBlock = document.getElementById('staminaBlock');
    const focusBlock = document.getElementById('focusBlock');

    // -------------------- COSTS --------------------
    const manaFontCost = () => 10 + game.manaFonts * 9;

    function totalManaFontCostFor(n) {
      // linear cost: (10 + 9*fonts) + ... + (10 + 9*(fonts+n-1))
      const nSafe = Math.max(0, Math.floor(n));
      if (nSafe <= 0) return 0;
      const first = manaFontCost();
      return (nSafe / 2) * (2 * first + 9 * (nSafe - 1));
    }
    function maxAffordableManaFonts() {
      const budget = game.mana || 0;
      const first = manaFontCost();
      // Solve: 9n^2 + (2*first - 9)n - 2*budget <= 0
      const A = 9;
      const B = 2 * first - 9;
      const disc = B * B + 72 * budget;
      const n = Math.floor((-B + Math.sqrt(Math.max(0, disc))) / (2 * A));
      // safety
      let nSafe = Math.max(0, n);
      while (nSafe > 0 && totalManaFontCostFor(nSafe) > budget + 1e-9) nSafe--;
      return nSafe;
    }
    function buyManaFonts(nWanted) {
      const n = Math.min(Math.max(0, Math.floor(nWanted)), 100000);
      if (n <= 0) return 0;
      const cost = totalManaFontCostFor(n);
      if (game.mana < cost) return 0;
      game.mana -= cost;
      game.manaFonts += n;
      return n;
    }

    function totalFloors() {
      const sr = game.specialRooms || {};
      let special = 0;
      SPECIAL_ROOM_NAMES.forEach(name => { if (sr[name] && sr[name].built) special++; });
      return (game.stairs || 0) + special + (game.floorsKept || 0);
    }
    function totalFloorsFromGame(g) {
      const sr = g.specialRooms || {};
      let special = 0;
      SPECIAL_ROOM_NAMES.forEach(name => { if (sr[name] && sr[name].built) special++; });
      return (g.stairs || 0) + special + (g.floorsKept || 0);
    }
    function conduitMasteryMultiplier() {
      const lvl = game.passive.conduit || 0;
      if (lvl <= 0) return 1;
      return 1 + (game.manaFonts || 0) * 0.01 * lvl;
    }
    function towerBondMultiplier() {
      const lvl = game.passive.towerBond || 0;
      if (lvl <= 0) return 1;
      return 1 + totalFloors() * 0.001 * lvl;
    }
    function leylineNexusMultiplier() {
      const lvl = countRooms('Leyline Nexus');
      if (lvl <= 0) return 1;
      return 1 + (game.passive.arcane || 0) * 0.01 * lvl;
    }
    function chronurgySwapReduction() {
      const lvl = countRooms('Chronurgy Chamber');
      return lvl * 0.10;
    }

    const floorCost = () => {
      const relicMult = 1 + (relicModifiers().floorCostMult || 0);
      return 50 * (totalFloors() + 1) * Math.max(0.2, relicMult);
    };
    function effectiveFloorCost() {
      let c = floorCost();
      if (game.nextFloorBonus) c = 0;
      else if (game.nextFloorCursed) c *= 1.5;
      const discount = game.nextFloorDiscountPct || 0;
      if (discount > 0) c *= (1 - discount);
      return c;
    }
    function effectiveFloorStaminaCost() {
      const base = maxStamina() * FLOOR_STAMINA_COST_PCT;
      const discount = game.nextFloorDiscountPct || 0;
      return base * (discount > 0 ? (1 - discount) : 1);
    }

    function countRooms(name) {
      if (name === 'Stairs') return game.stairs || 0;
      const sr = game.specialRooms || {};
      const r = sr[name];
      if (!r || !r.built) return 0;
      return r.level || 1;
    }
    function roomEffectSum(key) {
      let total = 0;
      SPECIAL_ROOM_NAMES.forEach(name => {
        const info = ROOMS[name];
        if (!info || !info[key]) return;
        const lvl = countRooms(name);
        if (lvl > 0) total += lvl * info[key];
      });
      return total;
    }
    function unlockedRoomNames() {
      return SPECIAL_ROOM_NAMES.filter(name => ROOMS[name] && ROOMS[name].unlock());
    }
    function ensureKeybinds() {
      if (!game.settings || typeof game.settings !== 'object') game.settings = { showTutorial: true, keybinds: {} };
      if (!game.settings.keybinds || typeof game.settings.keybinds !== 'object') game.settings.keybinds = {};
      Object.keys(KEYBIND_DEFAULTS).forEach(key => {
        if (!game.settings.keybinds[key]) game.settings.keybinds[key] = KEYBIND_DEFAULTS[key];
      });
      return game.settings.keybinds;
    }
    function formatKeyLabel(key) {
      if (!key) return '—';
      if (key === 'esc') return 'Esc';
      return key.length === 1 ? key.toUpperCase() : key;
    }
    function renderKeybinds() {
      if (!keybindsList) return;
      const binds = ensureKeybinds();
      keybindsList.innerHTML = '';
      KEYBIND_ACTIONS.forEach(action => {
        const row = document.createElement('div');
        row.className = 'kb-row';
        const keyEl = document.createElement('span');
        keyEl.className = 'kb-key';
        keyEl.textContent = formatKeyLabel(binds[action.id]);
        const desc = document.createElement('span');
        desc.className = 'kb-desc';
        desc.textContent = action.label;
        const btn = document.createElement('button');
        btn.className = 'kb-rebind';
        btn.textContent = (awaitingRebind === action.id) ? 'Press key...' : 'Rebind';
        btn.disabled = awaitingRebind && awaitingRebind !== action.id;
        btn.onclick = () => {
          awaitingRebind = action.id;
          renderKeybinds();
        };
        row.appendChild(keyEl);
        row.appendChild(desc);
        row.appendChild(btn);
        keybindsList.appendChild(row);
      });
    }
    function relicModifiers() {
      const mods = {
        manaMult: 0,
        staminaRegenMult: 0,
        focusRegenMult: 0,
        focusIdleMult: 0,
        clickMult: 0,
        maxManaMult: 0,
        maxStaminaBonus: 0,
        maxFocusBonus: 0,
        fontRateMult: 0,
        spellEffectMult: 0,
        activeDurationMult: 0,
        floorCostMult: 0,
        upgradeCostMult: 0,
      };
      const list = game.relics || [];
      list.forEach(id => {
        const relic = RELIC_BY_ID[id];
        if (!relic || !relic.mods) return;
        Object.keys(relic.mods).forEach(key => {
          mods[key] = (mods[key] || 0) + relic.mods[key];
        });
      });
      return mods;
    }
    function relicMilestonesReached() {
      const floors = totalFloors();
      return RELIC_MILESTONES.filter(m => floors >= m).length;
    }
    function nextRelicMilestone() {
      const floors = totalFloors();
      return RELIC_MILESTONES.find(m => floors < m) || null;
    }
    function activeDurationMultiplier() {
      const roomBonus = roomEffectSum('activeDurationPct');
      const ritualBonus = (game.passive.ritualMastery || 0) * 0.05;
      const relicBonus = relicModifiers().activeDurationMult || 0;
      return 1 + roomBonus + ritualBonus + relicBonus;
    }
    function focusIdleMultiplier() {
      const roomBonus = roomEffectSum('focusIdlePct');
      const passiveBonus = (game.passive.focusFlow || 0) * -0.03;
      const relicBonus = relicModifiers().focusIdleMult || 0;
      return Math.max(0.35, 1 + roomBonus + passiveBonus + relicBonus);
    }
    function focusRegenMultiplier() {
      const roomBonus = roomEffectSum('focusPct');
      const passiveBonus = (game.passive.focusFlow || 0) * 0.05;
      const relicBonus = relicModifiers().focusRegenMult || 0;
      return 1 + roomBonus + passiveBonus + relicBonus;
    }
    function activeEffectMultiplier() {
      return (game.active && game.active.convergenceTimer > 0) ? 2 : 1;
    }
    function ritualDurationMultiplier() {
      const anchored = (game.passive.anchoredRituals || 0) * 0.04;
      return activeDurationMultiplier() * (1 + anchored);
    }
    function ritualCostMultiplier() {
      const anchored = (game.passive.anchoredRituals || 0) * 0.02;
      return Math.max(0.4, 1 - anchored);
    }
    function currentSpellCostDiscount() {
      if (game.active && game.active.spellCostDiscountTimer > 0) return game.active.spellCostDiscountPct || 0;
      return 0;
    }
    function activeCooldownCount() {
      const now = Date.now();
      let count = 0;
      if (game.active && game.active.cooldown > 0) count++;
      const seen = new Set();
      if (typeof ACTIVE_SPELLS !== 'undefined') {
        ACTIVE_SPELLS.forEach(s => {
          if (!s.cooldownKey) return;
          if (seen.has(s.cooldownKey)) return;
          seen.add(s.cooldownKey);
          if ((game[s.cooldownKey] || 0) > now) count++;
        });
      }
      return count;
    }
    function maxSpellSlots() {
      let slots = 1;
      SPECIAL_ROOM_NAMES.forEach(name => {
        const info = ROOMS[name];
        if (info && (info.extraSpellSlots || 0) > 0) {
          const lvl = countRooms(name);
          slots += lvl * (info.extraSpellSlots || 0);
        }
      });
      return slots;
    }
    function getSpellId(s, isActive) {
      if (isActive && s.id) return s.id;
      if (!isActive && s.key) return s.key;
      return (s.name || '').replace(/\s+/g, '').toLowerCase();
    }
    function isMemorized(spellId) {
      const list = game.memorizedSpells || [];
      return Array.isArray(list) && list.includes(spellId);
    }
    function hasAchievement(id) {
      return (game.stats && Array.isArray(game.stats.achievements)) ? game.stats.achievements.includes(id) : false;
    }
    function isSpellUnlocked(spell, isActive) {
      if (typeof spell.unlockCheck === 'function') return spell.unlockCheck();
      const floors = totalFloors();
      return floors >= (spell.unlock || 0);
    }
    function spellUnlockHint(spell) {
      if (typeof spell.unlockText === 'function') return spell.unlockText();
      if (typeof spell.unlock === 'number') return 'Unlocks at ' + spell.unlock + ' floors';
      return 'Unlock condition not met';
    }
    function effectiveSpellSwapCooldownMs() {
      let ms = SPELL_SWAP_COOLDOWN_MS * Math.max(0.1, 1 - chronurgySwapReduction());
      if (game.ritualOfBindingNextSwapHalved) ms *= 0.5;
      return ms;
    }
    function canSwapSpell() {
      return (game.spellSwapCooldownEnd || 0) <= Date.now();
    }
    function spellSwapCooldownRemaining() {
      const end = game.spellSwapCooldownEnd || 0;
      const rem = Math.max(0, (end - Date.now()) / 1000);
      return rem;
    }
    function forgetSpell(spellId) {
      if (!canSwapSpell()) return;
      const list = (game.memorizedSpells || []).filter(id => id !== spellId);
      game.memorizedSpells = list;
      const ms = effectiveSpellSwapCooldownMs();
      game.spellSwapCooldownEnd = Date.now() + ms;
      if (game.ritualOfBindingNextSwapHalved) game.ritualOfBindingNextSwapHalved = false;
      renderAll();
    }
    function memorizeSpell(spellId) {
      if (!canSwapSpell()) return;
      const list = game.memorizedSpells || [];
      if (list.length >= maxSpellSlots()) return;
      if (list.includes(spellId)) return;
      game.memorizedSpells = [...list, spellId];
      const ms = effectiveSpellSwapCooldownMs();
      game.spellSwapCooldownEnd = Date.now() + ms;
      if (game.ritualOfBindingNextSwapHalved) game.ritualOfBindingNextSwapHalved = false;
      renderAll();
    }

    function upgradeCost(roomName) {
      const r = (game.specialRooms || {})[roomName];
      const level = (r && r.built && r.level) ? r.level : 1;
      const base = UPGRADE_COST_BASE * Math.pow(1.5, level - 1);
      const roomDiscount = roomEffectSum('upgradeCostPct');
      const relicDiscount = relicModifiers().upgradeCostMult || 0;
      const mult = Math.max(0.2, 1 + roomDiscount + relicDiscount);
      return base * mult;
    }

    function spellEffectMultiplier() {
      const base = 1 + game.passive.arcane * 0.15;
      const libraryLevel = countRooms('Library');
      let mult = base * (1 + libraryLevel * LIBRARY_LEYLINE_PCT);
      SPECIAL_ROOM_NAMES.forEach(name => {
        if (name === 'Library') return;
        const info = ROOMS[name];
        if (!info.spellPct) return;
        const lvl = countRooms(name);
        mult *= (1 + lvl * info.spellPct);
      });
      mult *= (1 + (game.transcribeBonusPct || 0) / 100);
      mult *= (1 + (relicModifiers().spellEffectMult || 0));
      mult *= paragonSpellEffectMultiplier();
      return mult;
    }
    function milestoneManaMultiplier() {
      const ever = game.stats.totalFloorsEver || 0;
      let mult = 1;
      if (ever >= 200) mult += 0.01;
      if (ever >= 500) mult += 0.01;
      if (ever >= 1000) mult += 0.02;
      return mult;
    }
    function paragonManaMultiplier() {
      const s = game.paragonSpent || {};
      return 1 + (s.manaPct || 0) * 0.005;
    }
    function paragonSpellEffectMultiplier() {
      const s = game.paragonSpent || {};
      return 1 + (s.spellEffect || 0) * 0.01;
    }

    function astralManaMultiplier() {
      const obsLevel = countRooms('Observatory');
      const pct = (ROOMS.Observatory && ROOMS.Observatory.astralPct) ? ROOMS.Observatory.astralPct : 0.10;
      return 1 + game.passive.astral * pct * obsLevel;
    }

    function maxMana() {
      const base = BASE_MANA_MAX * Math.pow(1.07, game.studyCount || 0);
      const roomBonus = 1 + roomEffectSum('manaCapPct');
      const passiveBonus = 1 + (game.passive.manaReservoir || 0) * 0.04;
      const relicBonus = 1 + (relicModifiers().maxManaMult || 0);
      const worldweave = (game.active && game.active.worldweaveTimer > 0) ? 2 : 1;
      return base * roomBonus * passiveBonus * relicBonus * worldweave;
    }

    function capMana() {
      const cap = maxMana();
      if (game.mana > cap) game.mana = cap;
    }

    function maxStamina() {
      const well = (game.passive.staminaWell || 0) * 5;
      const paragon = (game.paragonSpent && game.paragonSpent.stamina) ? game.paragonSpent.stamina * 5 : 0;
      const relicBonus = relicModifiers().maxStaminaBonus || 0;
      const worldweave = (game.active && game.active.worldweaveTimer > 0) ? 2 : 1;
      return (BASE_STAMINA_MAX + well + paragon + relicBonus) * worldweave;
    }

    function staminaRoomBonusMult() {
      let raw = 0;
      SPECIAL_ROOM_NAMES.forEach(name => {
        const info = ROOMS[name];
        if (!info.staminaPct) return;
        const lvl = countRooms(name);
        raw += lvl * info.staminaPct;
      });
      return 1 + Math.min(raw, STAMINA_ROOM_BONUS_CAP);
    }

    function towerStrainStaminaMult() {
      const tf = totalFloors();
      if (tf < TOWER_STRAIN_FLOOR) return 1;
      const over = tf - TOWER_STRAIN_FLOOR;
      const pct = Math.floor(over / 10) * TOWER_STRAIN_PCT_PER_10;
      return Math.max(0.2, 1 - pct);
    }

    function staminaPerSecond() {
      const roomMult = staminaRoomBonusMult();
      const wellRegen = (game.passive.staminaWell || 0) * 0.01;
      const meditateBonus = Math.min(game.meditateStacks || 0, MEDITATE_CAP) * MEDITATE_PCT_PER_STACK;
      let mult = roomMult - 1 + wellRegen + meditateBonus + 1;
      const base = STAMINA_REGEN_BASE * mult;
      const boostTD = (game.active && game.active.boostTD) ? game.active.boostTD : 1;
      const boostHarvest = (game.active && game.active.boostHarvest) ? game.active.boostHarvest : 1;
      let sps = base * boostTD * boostHarvest;
      if (game.ritualBuffEnd && game.ritualBuffEnd > Date.now()) sps *= 2;
      sps *= towerStrainStaminaMult();
      if ((game.exhaustedUntil || 0) > Date.now()) sps *= 0.5;
      sps *= (1 + (relicModifiers().staminaRegenMult || 0));
      return Math.min(sps, STAMINA_REGEN_CAP);
    }

    function maxFocus() {
      const paragon = (game.paragonSpent && game.paragonSpent.focus) ? game.paragonSpent.focus * 5 : 0;
      const relicBonus = relicModifiers().maxFocusBonus || 0;
      const worldweave = (game.active && game.active.worldweaveTimer > 0) ? 2 : 1;
      return (BASE_FOCUS_MAX + paragon + relicBonus) * worldweave;
    }

    function focusIdleSeconds() {
      return (Date.now() - (game.lastActivityOrSpellAt || 0)) / 1000;
    }

    function isRestingForFocus() {
      return focusIdleSeconds() >= FOCUS_IDLE_SEC * focusIdleMultiplier();
    }

    function focusPerSecond() {
      if (!isRestingForFocus()) return 0;
      const condenser = (game.active && game.active.focusCondenserTimer > 0) ? 1.5 : 1;
      return FOCUS_REGEN_BASE * focusRegenMultiplier() * condenser;
    }

    function trySpendFocus(amount) {
      if (!amount || amount <= 0) return true;
      const f = game.focus || 0;
      if (f < amount) return false;
      game.focus = f - amount;
      return true;
    }

    function recordActivityOrSpell() {
      game.lastActivityOrSpellAt = Date.now();
    }

    function capFocus() {
      const cap = maxFocus();
      if ((game.focus || 0) > cap) game.focus = cap;
    }

    function setExhausted() {
      game.exhaustedUntil = Date.now() + EXHAUSTED_DURATION_MS;
    }

    function capStamina() {
      const cap = maxStamina();
      if (game.stamina > cap) game.stamina = cap;
    }

    function timeDilationCost(casts) {
      let cost = 5;
      const spellMult = spellEffectMultiplier();
      const growthFactor = 1 + 0.07 * spellMult;
      for (let i = 0; i < casts; i++) cost = (cost + 1) * growthFactor;
      return cost;
    }

    function manaPerSecond() {
      const floors = totalFloors();
      const sigilStacks = Math.min(game.sigilStacks || 0, SIGIL_STACK_CAP);
      const sigilMult = 1 + sigilStacks * SIGIL_STACK_PCT;
      const fontRate = MANA_FONT_RATE * sigilMult * (1 + roomEffectSum('fontPct')) * (1 + (relicModifiers().fontRateMult || 0));
      let m = (game.manaFonts * fontRate) * (1 + floors * FLOOR_BONUS);
      const vaultLevel = countRooms('Vault');
      m *= Math.min(1 + vaultLevel * 0.05, 1 + VAULT_CAP);
      m *= (1 + (game.stairs || 0) * STAIRS_MANA_PCT);
      SPECIAL_ROOM_NAMES.forEach(name => {
        if (name === 'Vault') return;
        const info = ROOMS[name];
        if (!info.manaPct) return;
        const lvl = countRooms(name);
        m *= (1 + lvl * info.manaPct);
      });
      const relicRoomPct = roomEffectSum('relicManaPct') * (game.relics || []).length;
      if (relicRoomPct > 0) m *= (1 + relicRoomPct);
      m *= astralManaMultiplier();
      m *= conduitMasteryMultiplier();
      m *= towerBondMultiplier();
      m *= leylineNexusMultiplier();
      if (game.active && game.active.runeStacks > 0) m *= (1 + game.active.runeStacks * 0.01);
      const boostTD = (game.active && game.active.boostTD) ? game.active.boostTD : 1;
      const boostHarvest = (game.active && game.active.boostHarvest) ? game.active.boostHarvest : 1;
      m *= boostTD * boostHarvest;
      if (game.active && game.active.leylineTapTimer > 0) m *= (1 + (game.active.leylineTapPct || 0));
      if (game.active && game.active.focusCondenserTimer > 0) m *= 0.8;
      if (game.active && game.active.overclockTimer > 0) m *= (game.active.overclockMult || 5);
      if (game.active && game.active.paradoxTimer > 0) m *= (2 / 3);
      if (game.ritualBuffEnd && game.ritualBuffEnd > Date.now()) m *= 2;
      const aetherLvl = game.passive.aetherFlux || 0;
      if (aetherLvl > 0) {
        const cdCount = activeCooldownCount();
        if (cdCount > 0) m *= (1 + cdCount * aetherLvl * 0.008);
      }
      m *= 1 + game.prestige * PRESTIGE_BONUS + game.softPrestige * PRESTIGE_SOFT_BONUS;
      m *= 1 + game.ascension * ASCENSION_BONUS_PER;
      const asc2 = (game.ascensionTier2 || 0) * ASCENSION_2_BONUS_PER;
      m *= 1 + asc2;
      m *= achievementManaMultiplier();
      m *= milestoneManaMultiplier();
      m *= paragonManaMultiplier();
      m *= (1 + (relicModifiers().manaMult || 0));
      return m;
    }

    // -------------------- ACHIEVEMENTS --------------------
    const ACHIEVEMENTS = [
      { id: 'first_10_floors', name: 'First Steps', desc: 'Reach 10 floors', check: g => totalFloorsFromGame(g) >= 10, reward: '+1% mana/sec' },
      { id: 'first_25', name: 'Tower Rising', desc: 'Reach 25 floors', check: g => totalFloorsFromGame(g) >= 25, reward: '+2% mana/sec' },
      { id: 'first_50', name: 'Half Century', desc: 'Reach 50 floors', check: g => totalFloorsFromGame(g) >= 50, reward: '+3% mana/sec' },
      { id: 'first_100', name: 'Century', desc: 'Reach 100 floors', check: g => totalFloorsFromGame(g) >= 100, reward: '+5% mana/sec' },
      { id: 'first_150', name: 'Spire', desc: 'Reach 150 floors', check: g => totalFloorsFromGame(g) >= 150, reward: '+1% mana/sec' },
      { id: 'first_200', name: 'Pinnacle', desc: 'Reach 200 floors', check: g => totalFloorsFromGame(g) >= 200, reward: '+1% mana/sec' },
      { id: 'first_250', name: 'Summit', desc: 'Reach 250 floors', check: g => totalFloorsFromGame(g) >= 250, reward: '+2% mana/sec' },
      { id: 'time_dilation_1', name: 'Time Walker', desc: 'Cast Time Dilation once', check: g => (g.stats && g.stats.timeDilationCasts) >= 1, reward: null },
      { id: 'arcane_harvest_10', name: 'Harvester', desc: 'Cast Arcane Harvest 10 times', check: g => (g.stats && g.stats.arcaneHarvestCasts) >= 10, reward: '+1% mana/sec' },
      { id: 'study_1', name: 'Scholar', desc: 'Study once', check: g => (g.studyCount || 0) >= 1, reward: null },
      { id: 'study_25', name: 'Sage', desc: 'Study 25 times', check: g => (g.studyCount || 0) >= 25, reward: '+1% mana/sec' },
      { id: 'prestige_1', name: 'Rebirth', desc: 'Prestige once', check: g => (g.prestige + g.softPrestige) >= 1, reward: null },
      { id: 'prestige_5', name: 'Veteran', desc: 'Prestige 5 times', check: g => (g.prestige + g.softPrestige) >= 5, reward: '+1% mana/sec' },
      { id: 'ascend_1', name: 'Ascendant', desc: 'Ascend once', check: g => (g.ascension + (g.ascensionTier2 || 0)) >= 1, reward: null },
      { id: 'ascend_3', name: 'Transcendent', desc: 'Ascend 3 times', check: g => (g.ascension + (g.ascensionTier2 || 0)) >= 3, reward: '+1% mana/sec' },
      { id: 'stamina_1000', name: 'Dedicated', desc: 'Spend 1000 total stamina on activities', check: g => (g.stats && g.stats.totalStaminaSpent) >= 1000, reward: '+1% mana/sec' },
      { id: 'rooms_10', name: 'Diverse', desc: 'Build 10 different room types', check: g => { const sr = g.specialRooms || {}; return SPECIAL_ROOM_NAMES.filter(n => sr[n] && sr[n].built).length >= 10; }, reward: '+1% mana/sec' },
      { id: 'upgrade_5', name: 'Investor', desc: 'Upgrade 5 rooms to level 2+', check: g => { const sr = g.specialRooms || {}; return SPECIAL_ROOM_NAMES.filter(n => sr[n] && sr[n].built && (sr[n].level || 1) >= 2).length >= 5; }, reward: null },
      { id: 'trial_no_arcanum_50', name: 'Pure Tower', desc: 'Reach 50 floors without building Arcanum', check: g => totalFloorsFromGame(g) >= 50 && !(g.specialRooms && g.specialRooms.Arcanum && g.specialRooms.Arcanum.built), reward: '+2% mana/sec' },
      { id: 'relic_1', name: 'Curiosity', desc: 'Claim 1 relic', check: g => (g.relics || []).length >= 1, reward: '+1% mana/sec' },
      { id: 'relic_4', name: 'Collector', desc: 'Claim 4 relics in a run', check: g => (g.relics || []).length >= 4, reward: '+2% mana/sec' },
      { id: 'relic_7', name: 'Vaulted', desc: 'Claim 7 relics in a run', check: g => (g.relics || []).length >= 7, reward: '+2% mana/sec' },
      { id: 'sigil_5', name: 'Rune Smith', desc: 'Forge 5 Sigils', check: g => (g.sigilStacks || 0) >= 5, reward: '+1% mana/sec' },
      { id: 'focus_surge_10', name: 'Mind Lance', desc: 'Cast Focus Surge 10 times', check: g => (g.stats && g.stats.focusSurgeCasts) >= 10, reward: '+1% mana/sec' },
      { id: 'first_300', name: 'Skyreach', desc: 'Reach 300 floors', check: g => totalFloorsFromGame(g) >= 300, reward: '+2% mana/sec' },
      { id: 'loop_master', name: 'Perfecting the Loop', desc: 'Cast 500 spells and reach 200 floors', check: g => (g.stats && g.stats.totalSpellsCast) >= 500 && totalFloorsFromGame(g) >= 200, reward: null },
      { id: 'overcharger', name: 'Overcharger', desc: 'Reach mana cap 50 times', check: g => (g.stats && g.stats.manaCapHits) >= 50, reward: null },
      { id: 'architect_nexus', name: 'Architect of the Nexus', desc: 'Build 1 of every room type', check: g => { const sr = g.specialRooms || {}; return SPECIAL_ROOM_NAMES.every(n => sr[n] && sr[n].built); }, reward: null },
      { id: 'master_grimoire', name: 'Master of the Grimoire', desc: 'Memorize 6 spells at once', check: g => (g.memorizedSpells || []).length >= 6, reward: null },
      { id: 'in_the_red', name: 'In the Red', desc: 'Cast a spell at 0 mana', check: g => (g.stats && g.stats.zeroManaCasts) >= 1, reward: null },
    ];

    function achievementManaMultiplier() {
      let mult = 1;
      ACHIEVEMENTS.forEach(a => {
        if (!a.reward || !(game.stats.achievements || []).includes(a.id)) return;
        const m = a.reward.match(/\+(\d+)%/);
        if (m) mult += Number(m[1]) / 100;
      });
      return mult;
    }

    function checkAchievements() {
      const list = game.stats.achievements || [];
      ACHIEVEMENTS.forEach(a => {
        if (list.includes(a.id)) return;
        if (a.check(game)) {
          game.stats.achievements = [...list, a.id];
          showToast(a.name, a.desc + (a.reward ? ' · ' + a.reward : ''));
          playSound('milestone');
        }
      });
    }

    function showToast(title, body) {
      const el = document.createElement('div');
      el.className = 'toast';
      el.innerHTML = '<div class="toast-title">' + title + '</div>' + (body ? body : '');
      toastContainer.appendChild(el);
      setTimeout(() => el.remove(), 3500);
    }

    // -------------------- SOUND --------------------
    let audioCtx = null;
    function playSound(type) {
      if (!game.soundEnabled) return;
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        gain.gain.value = 0.1;
        if (type === 'click') { osc.frequency.value = 400; osc.type = 'sine'; }
        else if (type === 'spell') { osc.frequency.value = 600; osc.type = 'sine'; }
        else { osc.frequency.value = 800; osc.type = 'sine'; }
        osc.start(audioCtx.currentTime);
        osc.stop(audioCtx.currentTime + 0.05);
      } catch (_) {}
    }

    // -------------------- CLICK MANA --------------------
    function clickManaGain() {
      // small, gentle scaling so clicking stays fun without breaking balance
      const f = totalFloors();
      const fonts = game.manaFonts || 0;
      const base = 1 + Math.floor(f / 10) + Math.floor(fonts / 20);
      const crit = Math.random() < 0.05;
      const relicMult = 1 + (relicModifiers().clickMult || 0);
      const amount = (crit ? base * 5 : base) * relicMult;
      return { amount, crit };
    }
    function centerClick(e) {
      if (!game.tutorial || typeof game.tutorial !== 'object') game.tutorial = { clicked: false, done: false, completedToast: false, settingsOpened: false, keysSeen: false, glossarySeen: false };
      game.tutorial.clicked = true;
      recordActivityOrSpell();
      if (game.active && game.active.runeTimer > 0) game.active.runeStacks = (game.active.runeStacks || 0) + 1;
      const g = clickManaGain();
      game.mana = Math.min(game.mana + g.amount, maxMana());
      game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + g.amount;
      playSound('click');
      const rect = towerContainer.getBoundingClientRect();
      const el = document.createElement('div');
      el.className = 'boost-number' + (g.crit ? ' crit' : '');
      el.textContent = '+' + formatNum(g.amount);
      el.style.left = (e.clientX - rect.left - 10) + 'px';
      el.style.top = (e.clientY - rect.top - 20) + 'px';
      towerContainer.appendChild(el);
      el.addEventListener('animationend', () => el.remove());

      const ripple = document.createElement('div');
      ripple.className = 'click-ripple';
      ripple.style.left = (e.clientX - rect.left) + 'px';
      ripple.style.top = (e.clientY - rect.top) + 'px';
      towerContainer.appendChild(ripple);
      ripple.addEventListener('animationend', () => ripple.remove());
    }
    document.getElementById('main').addEventListener('click', centerClick);

    // -------------------- SPELL COST (Spell Echo + Attune) --------------------
    function trySpendManaForSpell(baseCost) {
      const discount = (game.attuneDiscount || 0) + currentSpellCostDiscount();
      const actualCost = Math.max(0, baseCost * (1 - Math.min(0.9, discount)));
      const echoLvl = game.passive.spellEcho || 0;
      const now = Date.now();
      if (echoLvl > 0 && (game.spellEchoNextFreeAt || 0) <= now) {
        game.spellEchoNextFreeAt = now + SPELL_ECHO_FREE_COOLDOWN_MS;
        game.attuneDiscount = 0;
        if ((game.mana || 0) <= 0) game.stats.zeroManaCasts = (game.stats.zeroManaCasts || 0) + 1;
        return true;
      }
      if (game.mana < actualCost) return false;
      if ((game.mana || 0) <= 0 && actualCost <= 0) game.stats.zeroManaCasts = (game.stats.zeroManaCasts || 0) + 1;
      game.mana -= actualCost;
      game.attuneDiscount = 0;
      return true;
    }

    // -------------------- ACTIVE SPELLS --------------------
    const SPELL_SWAP_COOLDOWN_MS = 10 * 60 * 1000; // 10 minutes
    const ACTIVE_SPELLS = [
      {
        id: 'transmutate',
        name: 'Transmutate',
        unlock: 0,
        desc: 'Convert current mana into stamina at a 3:1 rate.',
        cooldownMs: 6000,
        cooldownKey: 'transmutateCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.transmutateCooldownEnd || 0) > now) return;
          const mana = game.mana || 0;
          if (mana <= 0) return;
          const casts = game.stats.transmutateCasts || 0;
          const fraction = Math.min(1, 0.30 * (1 + casts * 0.05));
          const efficiency = Math.max(0.4, 1 - casts * 0.05);
          const staminaRoom = maxStamina() - (game.stamina || 0);
          if (staminaRoom <= 0) return;
          const maxSpendForStamina = staminaRoom * 3;
          const manaSpend = Math.min(mana * fraction, maxSpendForStamina);
          if (manaSpend <= 0) return;
          game.mana -= manaSpend;
          game.stamina = Math.min((game.stamina || 0) + (manaSpend / 3) * efficiency, maxStamina());
          recordActivityOrSpell();
          game.stats.transmutateCasts = casts + 1;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.transmutateCooldownEnd = now + 6000;
          playSound('spell');
        },
        costText: () => {
          const casts = game.stats.transmutateCasts || 0;
          const pct = Math.min(1, 0.30 * (1 + casts * 0.05)) * 100;
          const eff = Math.max(0.4, 1 - casts * 0.05) * 100;
          return 'Convert ' + pct.toFixed(0) + '% mana → stamina (3:1). Efficiency ' + eff.toFixed(0) + '%. Cooldown 6s.';
        },
      },
      {
        id: 'timeDilation',
        name: 'Time Dilation',
        unlock: 5,
        focusCost: 15,
        desc: 'Triples passive mana gain.',
        hideWhenActive: true,
        effect: () => {
          if (!trySpendFocus(15)) return;
          const casts = game.stats.timeDilationCasts || 0;
          const baseCost = timeDilationCost(casts);
          if (!trySpendManaForSpell(baseCost)) return;
          recordActivityOrSpell();
          game.stats.timeDilationCasts = casts + 1;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          const mult = spellEffectMultiplier() * activeEffectMultiplier();
          const durMult = activeDurationMultiplier();
          game.active.boostTD = 3 * mult;
          game.active.duration = 10 * mult * durMult;
          game.active.timer = game.active.duration;
          game.active.cooldown = game.active.duration * 1.1;
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(timeDilationCost(game.stats.timeDilationCasts || 0)) + ' mana, 15 focus',
      },
      {
        id: 'manaSiphon',
        name: 'Mana Siphon',
        unlock: 6,
        focusCost: 10,
        desc: 'Instantly gain 5 seconds of mana/sec.',
        cooldownMs: 8000,
        cooldownKey: 'manaSiphonCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.manaSiphonCooldownEnd || 0) > now) return;
          if (!trySpendFocus(10)) return;
          const cost = 120;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const mult = spellEffectMultiplier() * activeEffectMultiplier();
          const gain = manaPerSecond() * 5 * mult;
          game.mana = Math.min(game.mana + gain, maxMana());
          game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + gain;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.manaSiphonCooldownEnd = now + 8000;
          playSound('spell');
        },
        costText: () => 'Cost 120 mana, 10 focus · Cooldown 8s',
      },
      {
        id: 'runeAccretion',
        name: 'Rune of Accretion',
        unlock: 7,
        desc: 'For 15s, each click adds +1% mana/sec (stacking).',
        cooldownMs: 20000,
        cooldownKey: 'runeAccretionCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.runeAccretionCooldownEnd || 0) > now) return;
          const cost = 400;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const mult = activeDurationMultiplier();
          game.active.runeTimer = 15 * mult;
          game.active.runeStacks = 0;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.runeAccretionCooldownEnd = now + 20000;
          playSound('spell');
        },
        costText: () => 'Cost 400 mana · Cooldown 20s',
      },
      {
        id: 'arcaneHarvest',
        name: 'Arcane Harvest',
        unlock: 8,
        focusCost: 20,
        desc: 'Double mana/sec for 5 seconds.',
        hideWhenActive: true,
        harvestKey: true,
        effect: () => {
          if (!trySpendFocus(20)) return;
          const cost = 200 * Math.pow(1.4, game.stats.arcaneHarvestCasts || 0);
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          game.stats.arcaneHarvestCasts = (game.stats.arcaneHarvestCasts || 0) + 1;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          const mult = spellEffectMultiplier() * activeEffectMultiplier();
          const durMult = activeDurationMultiplier();
          game.active.boostHarvest = 2 * mult;
          game.active.harvestTimer = 5 * mult * durMult;
          game.active.harvestDuration = 5 * mult * durMult;
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(200 * Math.pow(1.4, game.stats.arcaneHarvestCasts || 0)) + ' mana, 20 focus',
      },
      {
        id: 'focusSurge',
        name: 'Focus Surge',
        unlock: 12,
        desc: 'Restore 35 focus (scaled by spell effect).',
        effect: () => {
          const casts = game.stats.focusSurgeCasts || 0;
          const cost = 250 * Math.pow(1.35, casts);
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          game.stats.focusSurgeCasts = casts + 1;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          const mult = spellEffectMultiplier() * activeEffectMultiplier();
          const gain = 35 * mult;
          game.focus = Math.min((game.focus || 0) + gain, maxFocus());
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(250 * Math.pow(1.35, game.stats.focusSurgeCasts || 0)) + ' mana',
      },
      {
        id: 'staminaTransmute',
        name: 'Stamina Transmute',
        unlock: 14,
        focusCost: 15,
        desc: 'Convert 10% stamina into 20% mana (scaled by spell effect).',
        cooldownMs: 18000,
        cooldownKey: 'staminaTransmuteCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.staminaTransmuteCooldownEnd || 0) > now) return;
          if (!trySpendFocus(15)) return;
          const staminaCost = maxStamina() * 0.10;
          if ((game.stamina || 0) < staminaCost) return;
          game.stamina -= staminaCost;
          recordActivityOrSpell();
          const mult = spellEffectMultiplier() * activeEffectMultiplier();
          const gain = maxMana() * 0.20 * mult;
          game.mana = Math.min(game.mana + gain, maxMana());
          game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + gain;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.staminaTransmuteCooldownEnd = now + 18000;
          playSound('spell');
        },
        costText: () => 'Cost 10% stamina, 15 focus · Cooldown 18s',
      },
      {
        id: 'leylineSurge',
        name: 'Leyline Surge',
        unlock: 25,
        focusCost: 25,
        desc: '+' + (LEYLINE_TAP_PCT * 100) + '% mana/sec for ' + LEYLINE_TAP_DURATION + 's.',
        hideWhenActive: true,
        leylineTapKey: true,
        effect: () => {
          if (!trySpendFocus(25)) return;
          const casts = game.stats.leylineSurgeCasts || 0;
          const cost = 400 * Math.pow(1.5, casts);
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          game.stats.leylineSurgeCasts = (game.stats.leylineSurgeCasts || 0) + 1;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          const mult = spellEffectMultiplier() * activeEffectMultiplier();
          const durMult = activeDurationMultiplier();
          game.active.leylineTapPct = LEYLINE_TAP_PCT * mult;
          game.active.leylineTapTimer = LEYLINE_TAP_DURATION * mult * durMult;
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(400 * Math.pow(1.5, game.stats.leylineSurgeCasts || 0)) + ' mana, 25 focus',
      },
      {
        id: 'focusCondenser',
        name: 'Focus Condenser',
        unlock: 22,
        desc: 'For 12s, +50% focus regen but -20% mana/sec.',
        cooldownMs: 20000,
        cooldownKey: 'focusCondenserCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.focusCondenserCooldownEnd || 0) > now) return;
          const cost = 600;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const mult = activeDurationMultiplier();
          game.active.focusCondenserTimer = 12 * mult;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.focusCondenserCooldownEnd = now + 20000;
          playSound('spell');
        },
        costText: () => 'Cost 600 mana · Cooldown 20s',
      },
      {
        id: 'leylineResonance',
        name: 'Leyline Resonance',
        unlock: 32,
        focusCost: 25,
        desc: 'For 30s, spells cost 30% less mana.',
        cooldownMs: 45000,
        cooldownKey: 'leylineResonanceCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.leylineResonanceCooldownEnd || 0) > now) return;
          if (!trySpendFocus(25)) return;
          const cost = 1500;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const mult = activeDurationMultiplier();
          game.active.spellCostDiscountTimer = 30 * mult;
          game.active.spellCostDiscountPct = 0.30;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.leylineResonanceCooldownEnd = now + 45000;
          playSound('spell');
        },
        costText: () => 'Cost 1500 mana, 25 focus · Cooldown 45s',
      },
      {
        id: 'wardOfPreservation',
        name: 'Ward of Preservation',
        unlock: 40,
        desc: 'Next prestige or ascension keeps 5% of current mana.',
        effect: () => {
          if (game.wardOfPreservationUsed) return;
          const cost = 2000;
          if (!trySpendManaForSpell(cost)) return;
          game.wardOfPreservationUsed = true;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          playSound('spell');
          showToast('Ward of Preservation', 'Next reset will keep 5% of current mana.');
        },
        costText: () => 'Cost ' + formatNum(2000) + ' mana (one use per run)',
      },
      {
        id: 'ritualOfBinding',
        name: 'Ritual of Binding',
        unlock: 30,
        focusCost: 30,
        desc: 'Next spell swap has 50% shorter cooldown. 1h cooldown.',
        effect: () => {
          if ((game.ritualOfBindingCooldownEnd || 0) > Date.now()) return;
          if (!trySpendFocus(30)) return;
          const cost = 800;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          game.ritualOfBindingCooldownEnd = Date.now() + RITUAL_OF_BINDING_COOLDOWN_MS;
          game.ritualOfBindingNextSwapHalved = true;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          playSound('spell');
          showToast('Ritual of Binding', 'Next Memorize/Forget will have 50% shorter cooldown.');
        },
        costText: () => 'Cost ' + formatNum(800) + ' mana, 30 focus',
      },
      {
        id: 'towerPulse',
        name: 'Tower Pulse',
        unlock: 50,
        desc: 'Next floor costs -25% mana and stamina (single use).',
        cooldownMs: 30000,
        cooldownKey: 'towerPulseCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.towerPulseCooldownEnd || 0) > now) return;
          const cost = 3000;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          game.nextFloorDiscountPct = 0.25;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.towerPulseCooldownEnd = now + 30000;
          playSound('spell');
          showToast('Tower Pulse', 'Next floor costs 25% less.');
        },
        costText: () => 'Cost 3000 mana · Cooldown 30s',
      },
      {
        id: 'vigorInfusion',
        name: 'Vigor Infusion',
        unlock: 65,
        focusCost: 20,
        desc: 'Restore 25% stamina and 15 focus (scaled by spell effect).',
        effect: () => {
          if (!trySpendFocus(20)) return;
          const casts = game.stats.vigorInfusionCasts || 0;
          const cost = 1200 * Math.pow(1.45, casts);
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          game.stats.vigorInfusionCasts = casts + 1;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          const mult = spellEffectMultiplier() * activeEffectMultiplier();
          const staminaGain = maxStamina() * 0.25 * mult;
          const focusGain = 15 * mult;
          game.stamina = Math.min(game.stamina + staminaGain, maxStamina());
          game.focus = Math.min((game.focus || 0) + focusGain, maxFocus());
          playSound('spell');
        },
        costText: () => 'Cost ' + formatNum(1200 * Math.pow(1.45, game.stats.vigorInfusionCasts || 0)) + ' mana, 20 focus',
      },
      {
        id: 'chronoLoop',
        name: 'Chrono Loop',
        unlock: 0,
        unlockCheck: () => hasAchievement('loop_master'),
        unlockText: () => 'Unlocks: Perfecting the Loop (500 spells + 200 floors)',
        sortKey: 900,
        desc: 'Replays the last 60s of passive gains instantly.',
        cooldownMs: 60 * 60 * 1000,
        cooldownKey: 'chronoLoopCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.chronoLoopCooldownEnd || 0) > now) return;
          if (!trySpendFocus(35)) return;
          const cost = 5000;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const gainMana = manaPerSecond() * 60;
          const gainStamina = staminaPerSecond() * 60;
          const gainFocus = focusPerSecond() * 60;
          game.mana = Math.min(game.mana + gainMana, maxMana());
          game.stamina = Math.min(game.stamina + gainStamina, maxStamina());
          game.focus = Math.min((game.focus || 0) + gainFocus, maxFocus());
          game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + gainMana;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.chronoLoopCooldownEnd = now + 60 * 60 * 1000;
          playSound('milestone');
        },
        costText: () => 'Cost 5000 mana, 35 focus · Cooldown 1h',
      },
      {
        id: 'nexusOverclock',
        name: 'Nexus Overclock',
        unlock: 0,
        unlockCheck: () => hasAchievement('overcharger'),
        unlockText: () => 'Unlocks: Overcharger (cap mana 50 times)',
        sortKey: 901,
        desc: 'x5 mana/sec for 60s, then exhausted for 180s.',
        cooldownMs: 30 * 60 * 1000,
        cooldownKey: 'nexusOverclockCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.nexusOverclockCooldownEnd || 0) > now) return;
          if (!trySpendFocus(40)) return;
          const cost = 8000;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const mult = activeDurationMultiplier();
          game.active.overclockTimer = 60 * mult;
          game.active.overclockMult = 5;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.nexusOverclockCooldownEnd = now + 30 * 60 * 1000;
          playSound('milestone');
        },
        costText: () => 'Cost 8000 mana, 40 focus · Cooldown 30m',
      },
      {
        id: 'worldweave',
        name: 'Worldweave',
        unlock: 0,
        unlockCheck: () => hasAchievement('architect_nexus'),
        unlockText: () => 'Unlocks: Architect of the Nexus (build every room type)',
        sortKey: 902,
        desc: 'Double all resource caps for 15 minutes.',
        cooldownMs: 2 * 60 * 60 * 1000,
        cooldownKey: 'worldweaveCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.worldweaveCooldownEnd || 0) > now) return;
          if (!trySpendFocus(50)) return;
          const cost = 10000;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          game.active.worldweaveTimer = 15 * 60;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.worldweaveCooldownEnd = now + 2 * 60 * 60 * 1000;
          playSound('milestone');
        },
        costText: () => 'Cost 10000 mana, 50 focus · Cooldown 2h',
      },
      {
        id: 'leylineConvergence',
        name: 'Leyline Convergence',
        unlock: 0,
        unlockCheck: () => hasAchievement('master_grimoire'),
        unlockText: () => 'Unlocks: Master of the Grimoire (memorize 6 spells)',
        sortKey: 903,
        desc: 'All active spell effects +100% for 60s.',
        cooldownMs: 45 * 60 * 1000,
        cooldownKey: 'convergenceCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.convergenceCooldownEnd || 0) > now) return;
          if (!trySpendFocus(35)) return;
          const cost = 6000;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          const mult = activeDurationMultiplier();
          game.active.convergenceTimer = 60 * mult;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.convergenceCooldownEnd = now + 45 * 60 * 1000;
          playSound('milestone');
        },
        costText: () => 'Cost 6000 mana, 35 focus · Cooldown 45m',
      },
      {
        id: 'paradoxCast',
        name: 'Paradox Cast',
        unlock: 0,
        unlockCheck: () => hasAchievement('in_the_red'),
        unlockText: () => 'Unlocks: In the Red (cast a spell at 0 mana)',
        sortKey: 904,
        desc: 'Refresh all active spell cooldowns, but -33% mana/sec for 120s.',
        cooldownMs: 2 * 60 * 60 * 1000,
        cooldownKey: 'paradoxCastCooldownEnd',
        effect: () => {
          const now = Date.now();
          if ((game.paradoxCastCooldownEnd || 0) > now) return;
          if (!trySpendFocus(30)) return;
          const cost = 4000;
          if (!trySpendManaForSpell(cost)) return;
          recordActivityOrSpell();
          game.active.paradoxTimer = 120;
          const cooldownKeys = [
            'transmutateCooldownEnd',
            'manaSiphonCooldownEnd',
            'runeAccretionCooldownEnd',
            'staminaTransmuteCooldownEnd',
            'focusCondenserCooldownEnd',
            'leylineResonanceCooldownEnd',
            'towerPulseCooldownEnd',
            'chronoLoopCooldownEnd',
            'nexusOverclockCooldownEnd',
            'worldweaveCooldownEnd',
            'convergenceCooldownEnd',
          ];
          cooldownKeys.forEach(key => { game[key] = 0; });
          if (game.active && game.active.cooldown > 0) game.active.cooldown = 0;
          game.stats.totalSpellsCast = (game.stats.totalSpellsCast || 0) + 1;
          game.paradoxCastCooldownEnd = now + 2 * 60 * 60 * 1000;
          playSound('milestone');
        },
        costText: () => 'Cost 4000 mana, 30 focus · Cooldown 2h',
      },
    ];

    const PASSIVE_SPELLS = [
      {
        key: 'arcane',
        name: 'Leyline Manipulation',
        unlock: 10,
        desc: 'Each level +15% to all spell effects',
        cost: () => 100 * Math.pow(1.6, game.passive.arcane),
        effect: () => game.passive.arcane++,
      },
      {
        key: 'astral',
        name: 'Astral Insight',
        unlock: 20,
        desc: 'Each level +10% mana/sec per Observatory',
        cost: () => 500 * Math.pow(1.7, game.passive.astral),
        effect: () => game.passive.astral++,
      },
      {
        key: 'aetherFlux',
        name: 'Aether Flux',
        unlock: 24,
        desc: '+0.8% mana/sec per active spell on cooldown (per level).',
        cost: () => 900 * Math.pow(1.6, game.passive.aetherFlux),
        effect: () => game.passive.aetherFlux++,
      },
      {
        key: 'conduit',
        name: 'Conduit Mastery',
        unlock: 15,
        desc: '+1% mana/sec per Mana Font per level',
        cost: () => 300 * Math.pow(1.55, game.passive.conduit),
        effect: () => game.passive.conduit++,
      },
      {
        key: 'focusFlow',
        name: 'Focus Flow',
        unlock: 12,
        desc: '-3% focus idle time and +5% focus regen per level',
        cost: () => 260 * Math.pow(1.55, game.passive.focusFlow),
        effect: () => game.passive.focusFlow++,
      },
      {
        key: 'towerBond',
        name: 'Tower Bond',
        unlock: 35,
        desc: '+0.1% mana/sec per floor per level',
        cost: () => 2000 * Math.pow(1.8, game.passive.towerBond),
        effect: () => game.passive.towerBond++,
      },
      {
        key: 'anchoredRituals',
        name: 'Anchored Rituals',
        unlock: 38,
        desc: '+4% ritual duration and -2% ritual cost per level',
        cost: () => 2400 * Math.pow(1.65, game.passive.anchoredRituals),
        effect: () => game.passive.anchoredRituals++,
      },
      {
        key: 'staminaWell',
        name: 'Stamina Well',
        unlock: 18,
        desc: '+5 max stamina and +1% stamina regen per level',
        cost: () => 400 * Math.pow(1.6, game.passive.staminaWell),
        effect: () => game.passive.staminaWell++,
      },
      {
        key: 'manaReservoir',
        name: 'Mana Reservoir',
        unlock: 55,
        desc: '+4% max mana per level',
        cost: () => 2500 * Math.pow(1.7, game.passive.manaReservoir),
        effect: () => game.passive.manaReservoir++,
      },
      {
        key: 'spellEcho',
        name: 'Spell Echo',
        unlock: 45,
        desc: 'Once per 15 min, next spell cast is free (no mana cost).',
        cost: () => 5000 * Math.pow(2, game.passive.spellEcho),
        effect: () => game.passive.spellEcho++,
      },
      {
        key: 'ritualMastery',
        name: 'Ritual Mastery',
        unlock: 70,
        desc: '+5% active spell and ritual duration per level',
        cost: () => 6500 * Math.pow(1.85, game.passive.ritualMastery),
        effect: () => game.passive.ritualMastery++,
      },
    ];

    // -------------------- ACTIVITIES --------------------
    const ACTIVITIES = [
      {
        id: 'study',
        name: 'Study',
        desc: 'Increases max mana pool by 7%.',
        costStaminaPct: 0.33,
        focusCost: 10,
        effect: () => {
          if (!trySpendFocus(10)) return;
          const cost = maxStamina() * 0.33;
          if (game.stamina < cost) return;
          game.stamina -= cost;
          recordActivityOrSpell();
          setExhausted();
          game.studyCount = (game.studyCount || 0) + 1;
          capMana();
          playSound('spell');
        },
        costText: () => 'Cost 33% max stamina, 10 focus',
      },
      {
        id: 'channel',
        name: 'Channel',
        desc: 'Instant mana: 1.5× your current mana/sec.',
        unlockFloors: 4,
        costStaminaPct: 0.20,
        focusCost: 5,
        effect: () => {
          if (!trySpendFocus(5)) return;
          const cost = maxStamina() * 0.20;
          if (game.stamina < cost) return;
          game.stamina -= cost;
          recordActivityOrSpell();
          game.stats.totalStaminaSpent = (game.stats.totalStaminaSpent || 0) + cost;
          const gain = manaPerSecond() * 1.5;
          game.mana = Math.min(game.mana + gain, maxMana());
          game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + gain;
          playSound('spell');
        },
        costText: () => 'Cost 20% max stamina, 5 focus',
      },
      {
        id: 'meditate',
        name: 'Meditate',
        desc: '+5% stamina regen until next prestige. Stackable up to ' + MEDITATE_CAP + '.',
        unlockFloors: 10,
        costStaminaPct: 0.25,
        effect: () => {
          const cost = maxStamina() * 0.25;
          if (game.stamina < cost) return;
          game.stamina -= cost;
          game.stats.totalStaminaSpent = (game.stats.totalStaminaSpent || 0) + cost;
          game.meditateStacks = Math.min((game.meditateStacks || 0) + 1, MEDITATE_CAP);
          playSound('spell');
        },
        costText: () => 'Cost 25% max stamina (' + formatNum(Math.floor(maxStamina() * 0.25)) + ')',
      },
      {
        id: 'harvest',
        name: 'Harvest',
        desc: 'Instant mana: 2× your current mana/sec.',
        unlockFloors: 8,
        costStaminaPct: 0.50,
        focusCost: 15,
        effect: () => {
          if (!trySpendFocus(15)) return;
          const cost = maxStamina() * 0.50;
          if (game.stamina < cost) return;
          game.stamina -= cost;
          recordActivityOrSpell();
          game.stats.totalStaminaSpent = (game.stats.totalStaminaSpent || 0) + cost;
          const gain = manaPerSecond() * 2;
          game.mana = Math.min(game.mana + gain, maxMana());
          game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + gain;
          playSound('spell');
        },
        costText: () => 'Cost 50% max stamina, 15 focus',
      },
      {
        id: 'scry',
        name: 'Scry',
        desc: 'Lock next tower room choice (same room offered again).',
        unlockFloors: 15,
        costStaminaPct: 0.20,
        effect: () => {
          const cost = maxStamina() * 0.20;
          if (game.stamina < cost) return;
          game.stamina -= cost;
          game.stats.totalStaminaSpent = (game.stats.totalStaminaSpent || 0) + cost;
          const sr = game.specialRooms || {};
          const available = unlockedRoomNames().filter(n => !(sr[n] && sr[n].built));
          if (available.length > 0) {
            game.scryLockedRoom = available[Math.floor(Math.random() * available.length)];
            showToast('Scry', 'Next build will offer: ' + game.scryLockedRoom);
          }
          playSound('spell');
        },
        costText: () => 'Cost 20% max stamina (' + formatNum(Math.floor(maxStamina() * 0.20)) + ')',
      },
      {
        id: 'transcribe',
        name: 'Transcribe',
        desc: 'Permanent +1% spell effect.',
        unlockFloors: 25,
        costStaminaPct: 0.40,
        focusCost: 15,
        effect: () => {
          if (!trySpendFocus(15)) return;
          const cost = maxStamina() * 0.40;
          if (game.stamina < cost) return;
          game.stamina -= cost;
          recordActivityOrSpell();
          setExhausted();
          game.stats.totalStaminaSpent = (game.stats.totalStaminaSpent || 0) + cost;
          game.transcribeBonusPct = (game.transcribeBonusPct || 0) + 1;
          playSound('spell');
        },
        costText: () => 'Cost 40% max stamina, 15 focus',
      },
      {
        id: 'forgeSigil',
        name: 'Forge Sigil',
        desc: 'Add a Sigil stack: +2% Mana Font output (max ' + SIGIL_STACK_CAP + ').',
        unlockFloors: 22,
        costStaminaPct: 0.35,
        focusCost: 10,
        disabled: () => (game.sigilStacks || 0) >= SIGIL_STACK_CAP,
        effect: () => {
          if (!trySpendFocus(10)) return;
          if ((game.sigilStacks || 0) >= SIGIL_STACK_CAP) return;
          const cost = maxStamina() * 0.35;
          if (game.stamina < cost) return;
          game.stamina -= cost;
          recordActivityOrSpell();
          setExhausted();
          game.stats.totalStaminaSpent = (game.stats.totalStaminaSpent || 0) + cost;
          game.sigilStacks = Math.min((game.sigilStacks || 0) + 1, SIGIL_STACK_CAP);
          playSound('spell');
        },
        costText: () => 'Cost 35% max stamina, 10 focus · Sigils ' + (game.sigilStacks || 0) + '/' + SIGIL_STACK_CAP,
      },
      {
        id: 'ritual',
        name: 'Ritual',
        desc: '2× all gains for 60s. 30 min cooldown.',
        unlockFloors: 35,
        costStaminaPct: 0.80,
        focusCost: 25,
        cooldownMs: RITUAL_ACTIVITY_COOLDOWN_MS,
        cooldownKey: 'ritualActivityCooldownEnd',
        effect: () => {
          if (!trySpendFocus(25)) return;
          const cost = maxStamina() * 0.80 * ritualCostMultiplier();
          if (game.stamina < cost) return;
          if ((game.ritualActivityCooldownEnd || 0) > Date.now()) return;
          game.stamina -= cost;
          recordActivityOrSpell();
          setExhausted();
          game.stats.totalStaminaSpent = (game.stats.totalStaminaSpent || 0) + cost;
          game.ritualBuffEnd = Date.now() + 60 * 1000 * ritualDurationMultiplier();
          game.ritualActivityCooldownEnd = Date.now() + RITUAL_ACTIVITY_COOLDOWN_MS;
          playSound('spell');
          showToast('Ritual', '2× all gains for 60s.');
        },
        costText: () => 'Cost ' + Math.round(80 * ritualCostMultiplier()) + '% max stamina, 25 focus',
      },
      {
        id: 'relicHunt',
        name: 'Relic Hunt',
        desc: 'Scout for a relic draft outside milestones. 25 min cooldown.',
        unlockFloors: 45,
        costStaminaPct: 0.50,
        focusCost: 15,
        cooldownMs: RELIC_HUNT_COOLDOWN_MS,
        cooldownKey: 'relicHuntCooldownEnd',
        disabled: () => (Array.isArray(game.relicDraft) && game.relicDraft.length > 0) || availableRelics().length === 0,
        effect: () => {
          if (!trySpendFocus(15)) return;
          const cost = maxStamina() * 0.50;
          if (game.stamina < cost) return;
          if ((game.relicHuntCooldownEnd || 0) > Date.now()) return;
          if (Array.isArray(game.relicDraft) && game.relicDraft.length > 0) {
            showToast('Relic Hunt', 'You already have a relic draft waiting.');
            return;
          }
          const choices = pickRelicChoices(3);
          if (choices.length === 0) {
            showToast('Relic Hunt', 'No relics remain this run.');
            return;
          }
          game.stamina -= cost;
          recordActivityOrSpell();
          setExhausted();
          game.stats.totalStaminaSpent = (game.stats.totalStaminaSpent || 0) + cost;
          game.relicDraft = choices.map(r => r.id);
          game.relicDraftSeen = false;
          game.relicHuntCooldownEnd = Date.now() + RELIC_HUNT_COOLDOWN_MS;
          playSound('spell');
          openRelicDraft();
        },
        costText: () => 'Cost 50% max stamina, 15 focus',
      },
      {
        id: 'attune',
        name: 'Attune',
        desc: 'Next spell cast costs 20% less mana.',
        unlockFloors: 20,
        costStaminaPct: 0.15,
        effect: () => {
          const cost = maxStamina() * 0.15;
          if (game.stamina < cost) return;
          game.stamina -= cost;
          game.stats.totalStaminaSpent = (game.stats.totalStaminaSpent || 0) + cost;
          game.attuneDiscount = 0.20;
          playSound('spell');
          showToast('Attune', 'Next spell 20% cheaper.');
        },
        costText: () => 'Cost 15% max stamina (' + formatNum(Math.floor(maxStamina() * 0.15)) + ')',
      },
    ];

    // -------------------- RELICS --------------------
    function availableRelics() {
      const owned = new Set(game.relics || []);
      return RELICS.filter(r => !owned.has(r.id));
    }
    function pickRelicChoices(count) {
      const pool = availableRelics();
      if (pool.length === 0) return [];
      const choices = [];
      const bag = pool.slice();
      while (bag.length > 0 && choices.length < count) {
        const idx = Math.floor(Math.random() * bag.length);
        choices.push(bag.splice(idx, 1)[0]);
      }
      return choices;
    }
    function ensureRelicDraft() {
      if (Array.isArray(game.relicDraft) && game.relicDraft.length > 0) return;
      const reached = relicMilestonesReached();
      const owned = (game.relics || []).length;
      if (reached <= owned) return;
      const choices = pickRelicChoices(3);
      if (choices.length === 0) return;
      game.relicDraft = choices.map(r => r.id);
      game.relicDraftSeen = false;
    }
    function selectRelic(relicId) {
      if (!relicId) return;
      if (!Array.isArray(game.relics)) game.relics = [];
      if (!game.relics.includes(relicId)) game.relics.push(relicId);
      game.relicDraft = [];
      game.relicDraftSeen = false;
      if (relicModal) relicModal.style.display = 'none';
      const relic = RELIC_BY_ID[relicId];
      if (relic) showToast('Relic claimed', relic.name + ' · ' + relic.desc);
      playSound('milestone');
      renderAll();
    }
    function openRelicDraft() {
      if (!relicModal || !relicChoices) return;
      if (!Array.isArray(game.relicDraft) || game.relicDraft.length === 0) return;
      relicChoices.innerHTML = '';
      game.relicDraftSeen = true;
      game.relicDraft.forEach(id => {
        const relic = RELIC_BY_ID[id];
        if (!relic) return;
        const card = document.createElement('div');
        card.className = 'relic-card tier-' + relic.tier;
        card.innerHTML =
          '<div class="relic-tier">' + relic.tier + '</div>' +
          '<div class="relic-title">' + relic.name + '</div>' +
          '<div class="relic-desc">' + relic.desc + '</div>';
        card.onclick = () => selectRelic(id);
        relicChoices.appendChild(card);
      });
      relicModal.style.display = 'flex';
    }
    function renderRelicsPanel() {
      if (!relicSummary) return;
      ensureRelicDraft();
      const relics = game.relics || [];
      const next = nextRelicMilestone();
      let html = '<div><strong>Relics</strong></div>';
      html += '<div class="cost">Collected: ' + relics.length + ' / ' + RELIC_MILESTONES.length + '</div>';
      html += next ? '<div class="cost">Next relic at ' + next + ' floors.</div>' : '<div class="cost">All relic milestones reached.</div>';
      if (relics.length === 0) {
        html += '<div class="cost">No relics yet.</div>';
      } else {
        html += '<div class="relic-list">' + relics.map(id => {
          const relic = RELIC_BY_ID[id];
          if (!relic) return '';
          return '<div class="relic-item"><div class="relic-name">' + relic.name + '</div><div class="relic-note">' + relic.desc + '</div></div>';
        }).join('') + '</div>';
      }
      relicSummary.innerHTML = html;
      const hasDraft = Array.isArray(game.relicDraft) && game.relicDraft.length > 0;
      if (relicDraftSection) relicDraftSection.style.display = hasDraft ? 'block' : 'none';
      if (relicDraftBtn) relicDraftBtn.onclick = () => openRelicDraft();
      if (hasDraft && !game.relicDraftSeen) openRelicDraft();
    }

    // -------------------- RENDER --------------------
    function renderAll() { renderUI(); renderSpells(); renderTower(); renderActivities(); renderRelicsPanel(); }

    function clearTutorialLayer() {
      if (!tutorialLayer) return;
      tutorialLayer.innerHTML = '';
    }
    function addTutorialTip(target, html, pos) {
      if (!tutorialLayer || !target) return;
      const tip = document.createElement('div');
      tip.className = 'tutorial-tip pos-' + pos;
      tip.innerHTML = html;
      tutorialLayer.appendChild(tip);
      const rect = target.getBoundingClientRect();
      const tipRect = tip.getBoundingClientRect();
      const gap = 12;
      let top = rect.top;
      let left = rect.left;
      if (pos === 'top') {
        top = rect.top - tipRect.height - gap;
        left = rect.left + rect.width / 2 - tipRect.width / 2;
      } else if (pos === 'bottom') {
        top = rect.bottom + gap;
        left = rect.left + rect.width / 2 - tipRect.width / 2;
      } else if (pos === 'left') {
        top = rect.top + rect.height / 2 - tipRect.height / 2;
        left = rect.left - tipRect.width - gap;
      } else {
        top = rect.top + rect.height / 2 - tipRect.height / 2;
        left = rect.right + gap;
      }
      const pad = 8;
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      left = Math.max(pad, Math.min(left, vw - tipRect.width - pad));
      top = Math.max(pad, Math.min(top, vh - tipRect.height - pad));
      tip.style.left = left + 'px';
      tip.style.top = top + 'px';
    }
    function renderTutorialHints() {
      if (!tutorialLayer) return;
      if (!game.tutorial || typeof game.tutorial !== 'object') game.tutorial = { clicked: false, done: false, completedToast: false, settingsOpened: false, keysSeen: false, glossarySeen: false };
      if (typeof game.tutorial.settingsOpened !== 'boolean') game.tutorial.settingsOpened = false;
      if (typeof game.tutorial.keysSeen !== 'boolean') game.tutorial.keysSeen = false;
      if (typeof game.tutorial.glossarySeen !== 'boolean') game.tutorial.glossarySeen = false;
      if (typeof game.wasManaCapped !== 'boolean') game.wasManaCapped = false;
      if (!game.settings || typeof game.settings !== 'object') game.settings = { showTutorial: true, keybinds: {} };
      if (typeof game.settings.showTutorial !== 'boolean') game.settings.showTutorial = true;
      ensureKeybinds();
      if (!game.settings.showTutorial || game.tutorial.done) { clearTutorialLayer(); return; }

      const task1 = !!game.tutorial.clicked;
      const task2 = (game.manaFonts || 0) >= 1;
      const task3 = totalFloors() >= 1;
      const task4 = (game.stats && game.stats.totalStaminaSpent) > 0;
      const task5 = !!game.tutorial.settingsOpened;
      const task6 = !!game.tutorial.keysSeen;
      const task7 = !!game.tutorial.glossarySeen;
      const doneCount = [task1, task2, task3, task4, task5, task6, task7].filter(Boolean).length;
      if (doneCount >= 7) {
        game.tutorial.done = true;
        clearTutorialLayer();
        if (!game.tutorial.completedToast) {
          game.tutorial.completedToast = true;
          showToast('All set', 'Tutorial complete. You can keep building your tower!');
        }
        return;
      }

      clearTutorialLayer();
      if (!task1) {
        addTutorialTip(towerContainer, '<strong>Start here</strong><br>Click the tower to collect mana.', 'right');
        return;
      }
      if (!task2) {
        const canBuyFont = (game.mana || 0) >= manaFontCost();
        if (!canBuyFont) {
          addTutorialTip(towerContainer, '<strong>Gather mana</strong><br>Keep clicking until you can buy a Mana Font.', 'right');
          return;
        }
        if (!towerModal.classList.contains('show')) {
          addTutorialTip(towerTab, '<strong>Tower</strong><br>Open this tab to buy a Mana Font.', 'top');
        } else {
          addTutorialTip(manaFontBtn, '<strong>Mana Font</strong><br>Buy one to grow mana/sec. (Tip: press M)', 'left');
        }
        return;
      }
      if (!task3) {
        const floorCost = effectiveFloorCost();
        const floorStamCost = maxStamina() * FLOOR_STAMINA_COST_PCT;
        const canBuild = (game.mana || 0) >= floorCost && (game.stamina || 0) >= floorStamCost;
        if (!canBuild) {
          const needStam = (game.stamina || 0) < floorStamCost;
          addTutorialTip(needStam ? staminaBlock : manaBlock, '<strong>Prepare</strong><br>Wait for resources to raise a floor.', 'bottom');
          return;
        }
        if (!towerModal.classList.contains('show')) {
          addTutorialTip(towerTab, '<strong>Raise a floor</strong><br>Open Tower to build your first room.', 'top');
        } else {
          addTutorialTip(towerBtn, '<strong>Raise a floor</strong><br>Build your first room to grow the tower.', 'left');
        }
        return;
      }
      if (!task4) {
        const now = Date.now();
        const affordable = ACTIVITIES.find(a => {
          const unlockFloors = Number(a.unlockFloors) || 0;
          if (totalFloors() < unlockFloors) return false;
          const stamCost = (a.costStaminaPct || 0) * maxStamina();
          const focusCost = a.focusCost || 0;
          if ((game.stamina || 0) < stamCost) return false;
          if ((game.focus || 0) < focusCost) return false;
          const cooldownKey = a.cooldownKey || 'ritualActivityCooldownEnd';
          if (a.cooldownMs && (game[cooldownKey] || 0) > now) return false;
          if (typeof a.disabled === 'function' && a.disabled()) return false;
          return true;
        });
        if (!affordable) { clearTutorialLayer(); return; }
        if (!document.getElementById('activitiesModal').classList.contains('show')) {
          addTutorialTip(activitiesTab, '<strong>Activities</strong><br>Spend stamina and focus to gain upgrades.', 'top');
        } else {
          const firstAction = activitiesDiv ? activitiesDiv.querySelector('button') : null;
          addTutorialTip(firstAction || activitiesTab, '<strong>Try an action</strong><br>Actions improve your tower and magic.', 'left');
        }
        return;
      }
      if (!task5) {
        addTutorialTip(settingsBtn, '<strong>Settings</strong><br>Open settings to customize and review info.', 'left');
        return;
      }
      if (!task6) {
        if (!settingsModal || settingsModal.style.display !== 'flex') {
          addTutorialTip(settingsBtn, '<strong>Keybinds</strong><br>Open settings to view keybinds.', 'left');
        } else {
          addTutorialTip(settingsTabKeys, '<strong>Keybinds</strong><br>Open this tab to view or rebind keys.', 'bottom');
        }
        return;
      }
      if (!task7) {
        if (!settingsModal || settingsModal.style.display !== 'flex') {
          addTutorialTip(settingsBtn, '<strong>Glossary</strong><br>Open settings to view the glossary.', 'left');
        } else {
          addTutorialTip(settingsTabGlossary, '<strong>Glossary</strong><br>Open this tab to review core concepts.', 'bottom');
        }
      }
    }
    function showLoreTip() {
      if (!loreTip) return;
      loreTip.style.display = 'block';
    }
    function hideLoreTip() {
      if (!loreTip) return;
      loreTip.style.display = 'none';
      try { localStorage.setItem('mageTowerLoreSeen', '1'); } catch (e) {}
    }

    function updateBadges() {
      // Tower: can buy font / build floor / upgrade a room
      const canBuyFont = (game.mana || 0) >= manaFontCost();
      const effCost = effectiveFloorCost();
      const floorStamCost = effectiveFloorStaminaCost();
      const canBuild = (game.mana || 0) >= effCost && (game.stamina || 0) >= floorStamCost;
      let canUpgrade = false;
      const sr = game.specialRooms || {};
      SPECIAL_ROOM_NAMES.forEach(name => {
        if (canUpgrade) return;
        const r = sr[name];
        if (!r || !r.built) return;
        if ((game.mana || 0) >= upgradeCost(name)) canUpgrade = true;
      });
      setTabBadge('towerModal', canBuyFont || canBuild || canUpgrade);

      // Activities: any unlocked activity affordable (basic check)
      const now = Date.now();
      let canAct = false;
      if (typeof ACTIVITIES !== 'undefined') {
        for (const a of ACTIVITIES) {
          if (totalFloors() < a.unlockFloors) continue;
          const ritualMult = a.id === 'ritual' ? ritualCostMultiplier() : 1;
          const stamCost = (a.costStaminaPct || 0) * maxStamina() * ritualMult;
          const focusCost = a.focusCost || 0;
          if ((game.stamina || 0) < stamCost) continue;
          if ((game.focus || 0) < focusCost) continue;
          const cooldownKey = a.cooldownKey || 'ritualActivityCooldownEnd';
          if (a.cooldownMs && (game[cooldownKey] || 0) > now) continue;
          if (typeof a.disabled === 'function' && a.disabled()) continue;
          canAct = true;
          break;
        }
      }
      setTabBadge('activitiesModal', canAct);

      // Grimoire: spell swap ready and there exists something new to memorize, or passive upgrade affordable
      const swapReady = canSwapSpell();
      const usedSlots = (game.memorizedSpells || []).length;
      const totalSlots = maxSpellSlots();
      let canMemorize = false;
      if (swapReady && usedSlots < totalSlots) {
        const f = totalFloors();
        const seen = new Set(game.memorizedSpells || []);
        const anyUnlockedUnmemorized = (list, isActive) => list.some(s => isSpellUnlocked(s, isActive) && !seen.has(getSpellId(s, isActive)));
        if (typeof ACTIVE_SPELLS !== 'undefined' && anyUnlockedUnmemorized(ACTIVE_SPELLS, true)) canMemorize = true;
        if (typeof PASSIVE_SPELLS !== 'undefined' && anyUnlockedUnmemorized(PASSIVE_SPELLS, false)) canMemorize = true;
      }
      let canPassiveBuy = false;
      if (typeof PASSIVE_SPELLS !== 'undefined') {
        for (const s of PASSIVE_SPELLS) {
          if (!isSpellUnlocked(s, false)) continue;
          const spellId = getSpellId(s, false);
          if (!isMemorized(spellId)) continue;
          const cost = (s.cost ? s.cost() * SCALE : 0);
          if ((game.mana || 0) >= cost && cost > 0) { canPassiveBuy = true; break; }
        }
      }
      setTabBadge('grimoireModal', canMemorize || canPassiveBuy);

      // Ascension: can ascend now
      setTabBadge('ascensionModal', totalFloors() >= ASCENSION_FLOOR);
      setTabBadge('relicsModal', Array.isArray(game.relicDraft) && game.relicDraft.length > 0);
    }

    function renderUI() {
      mana.textContent = formatNum(game.mana);
      manaMaxEl.textContent = formatNum(maxMana());
      manaPerSec.textContent = formatRate(manaPerSecond()) + '/s';
      staminaEl.textContent = formatNum(game.stamina);
      staminaMaxEl.textContent = formatNum(maxStamina());
      staminaPerSecEl.textContent = formatRate(staminaPerSecond()) + '/s';
      if (focusEl) focusEl.textContent = formatNum(game.focus || 0);
      if (focusMaxEl) focusMaxEl.textContent = formatNum(maxFocus());
      if (focusPerSecEl) focusPerSecEl.textContent = formatRate(focusPerSecond()) + '/s';
      if (focusIdleHint) {
        const idleSec = Math.round(FOCUS_IDLE_SEC * focusIdleMultiplier());
        focusIdleHint.textContent = '(after ' + idleSec + 's idle)';
      }
      setMiniBar(manaFillEl, game.mana || 0, maxMana());
      setMiniBar(staminaFillEl, game.stamina || 0, maxStamina());
      setMiniBar(focusFillEl, game.focus || 0, maxFocus());
      updateResourceFullState(manaBlock, game.mana, maxMana());
      updateResourceFullState(staminaBlock, game.stamina, maxStamina());
      updateResourceFullState(focusBlock, game.focus || 0, maxFocus());
      const exhaustedEnd = game.exhaustedUntil || 0;
      if (exhaustedHint) {
        if (exhaustedEnd > Date.now()) {
          exhaustedHint.style.display = 'block';
          const sec = Math.ceil((exhaustedEnd - Date.now()) / 1000);
          const m = Math.floor(sec / 60);
          const s = sec % 60;
          exhaustedHint.textContent = 'Exhausted: ' + m + ':' + (s < 10 ? '0' : '') + s + ' (50% stamina regen)';
        } else {
          exhaustedHint.style.display = 'none';
        }
      }
      floors.textContent = totalFloors();
      manaFontCostEl.textContent = 'Cost: ' + formatNum(manaFontCost()) + ' mana (Shift: x10, Ctrl: max)';
      const currentMps = manaPerSecond();
      const sigilStacks = Math.min(game.sigilStacks || 0, SIGIL_STACK_CAP);
      const sigilMult = 1 + sigilStacks * SIGIL_STACK_PCT;
      const fontRate = MANA_FONT_RATE * sigilMult * (1 + roomEffectSum('fontPct')) * (1 + (relicModifiers().fontRateMult || 0));
      const mpsGainFromFont = fontRate * (1 + totalFloors() * FLOOR_BONUS);
      const fontGainPct = currentMps > 0 ? ((mpsGainFromFont / currentMps) * 100).toFixed(1) : '0';
      if (manaFontPreview) manaFontPreview.textContent = '+' + formatRate(mpsGainFromFont) + '/s (+' + fontGainPct + '%)';
      const effCost = effectiveFloorCost();
      const floorStamCost = effectiveFloorStaminaCost();
      const discountTag = (game.nextFloorDiscountPct || 0) > 0 ? ' (Tower Pulse: -25%)' : '';
      towerCostEl.textContent = game.nextFloorBonus ? 'Next floor: Free (+ ' + formatNum(floorStamCost) + ' stamina)' : (game.nextFloorCursed ? 'Next floor: ' + formatNum(effCost) + ' mana, ' + formatNum(floorStamCost) + ' stamina (2× cost, 2× effect)' : 'Cost: ' + formatNum(effCost) + ' mana, ' + formatNum(floorStamCost) + ' stamina' + discountTag);
      if (towerPreview) towerPreview.textContent = '+' + (FLOOR_BONUS * 100).toFixed(1) + '% mana/sec';

      const canFullPrestige = totalFloors() >= PRESTIGE_FLOOR;
      const canSoftPrestige = totalFloors() >= PRESTIGE_SOFT_FLOOR && totalFloors() < PRESTIGE_FLOOR;
      prestigeSection.style.display = (canFullPrestige || canSoftPrestige) ? 'block' : 'none';
      const prestigeTokensEl = document.getElementById('prestigeTokensEl');
      const prestigeTokenChoices = document.getElementById('prestigeTokenChoices');
      if (prestigeTokensEl && (canFullPrestige || canSoftPrestige)) prestigeTokensEl.textContent = 'Prestige Tokens: ' + (game.prestigeTokens || 0);
      if (prestigeTokenChoices) {
        if (!canFullPrestige) prestigeTokenChoices.innerHTML = '';
        else {
          prestigeTokenChoices.innerHTML = '';
          const tok = game.prestigeTokens || 0;
          let choice = game.prestigeTokenChoice;
          if (choice === 'relic' && (game.relics || []).length === 0) {
            game.prestigeTokenChoice = null;
            choice = null;
          }
          const addOpt = (key, label, enabled = true) => {
            const btn = document.createElement('button');
            btn.className = 'spell-slot-btn';
            btn.textContent = (choice === key ? '[X] ' : '') + label + ' (1 token)';
            btn.disabled = tok < 1 || !enabled;
            btn.onclick = () => { game.prestigeTokenChoice = game.prestigeTokenChoice === key ? null : key; renderAll(); };
            prestigeTokenChoices.appendChild(btn);
          };
          addOpt('font', 'Keep 1 Mana Font');
          addOpt('study', 'Keep 5% Study count');
          addOpt('relic', 'Keep 1 Relic', (game.relics || []).length > 0);
        }
      }
      if (canFullPrestige) {
        const nextBonus = PRESTIGE_BONUS * 100;
        prestigeDesc.textContent = 'Reset tower for +' + nextBonus + '% mana/sec (permanent). You have ' + totalFloors() + ' floors.';
        prestigeBtn.textContent = 'Prestige (+10%)';
        prestigeBtn.onclick = () => {
          if (!confirm('Prestige now? You will reset floors, rooms, and upgrades but gain +10% mana/sec permanently. Current bonus: ' + (game.prestige * 10) + '% → ' + ((game.prestige + 1) * 10) + '%.')) return;
          doPrestige(false);
        };
      } else if (canSoftPrestige) {
        prestigeDesc.textContent = 'Soft Prestige: reset for +5% mana/sec. Reach ' + PRESTIGE_FLOOR + ' floors for full +10%.';
        prestigeBtn.textContent = 'Soft Prestige (+5%)';
        prestigeBtn.onclick = () => {
          if (!confirm('Soft Prestige? Reset for +5% mana/sec. You have ' + totalFloors() + ' floors.')) return;
          doPrestige(true);
        };
      }

      const canAscend = totalFloors() >= ASCENSION_FLOOR;
      const canAscendTier2 = totalFloors() >= ASCENSION_FLOOR_2;
      ascensionDesc.textContent = canAscend
        ? (canAscendTier2
          ? 'Ascend Tier 2 (150 floors): +3% mana/sec. Or ascend at 100 for +2%. Current: ' + (game.ascension * 2 + (game.ascensionTier2 || 0) * 3) + '% total.'
          : 'Ascend: +2% mana/sec (100 floors). Reach 150 for Tier 2 (+3%). Current: ' + totalFloors() + ' floors.')
        : 'Reach ' + ASCENSION_FLOOR + ' floors to ascend. Current: ' + totalFloors() + ' floors.';
      ascendBtn.onclick = () => {
        if (totalFloors() < ASCENSION_FLOOR) return;
        if (!confirm('Ascend? This resets prestige, soft prestige, floors, and rooms. You keep ascension bonus. Continue?')) return;
        const savedMana = game.wardOfPreservationUsed ? game.mana * 0.05 : 0;
        const hallLvl = countRooms('Hall of Preservation');
        const savedFloorsKept = hallLvl >= 1 ? Math.floor(totalFloors() * PRESTIGE_KEEP_FLOORS_PCT) : 0;
        game.stats.totalFloorsEver = (game.stats.totalFloorsEver || 0) + totalFloors();
        if (totalFloors() >= ASCENSION_FLOOR_2) game.ascensionTier2 = (game.ascensionTier2 || 0) + 1;
        else game.ascension++;
        game.prestige = 0;
        game.softPrestige = 0;
        game.specialRooms = initialSpecialRooms();
        game.memorizedSpells = (game.memorizedSpells || []).slice(0, maxSpellSlots());
        game.stairs = 0;
        game.floorsKept = savedFloorsKept;
        game.mana = savedMana;
        game.manaFonts = 0;
        game.passive = { arcane: 0, astral: 0, conduit: 0, towerBond: 0, staminaWell: 0, spellEcho: 0, focusFlow: 0, manaReservoir: 0, ritualMastery: 0, aetherFlux: 0, anchoredRituals: 0 };
        game.active = {
          boost: 1,
          boostTD: 1,
          boostHarvest: 1,
          timer: 0,
          duration: 0,
          cooldown: 0,
          harvestTimer: 0,
          harvestDuration: 0,
          leylineTapTimer: 0,
          leylineTapPct: 0,
          runeTimer: 0,
          runeStacks: 0,
          focusCondenserTimer: 0,
          spellCostDiscountTimer: 0,
          spellCostDiscountPct: 0,
          overclockTimer: 0,
          overclockMult: 1,
          worldweaveTimer: 0,
          convergenceTimer: 0,
          paradoxTimer: 0,
        };
        game.studyCount = 0;
        game.stamina = maxStamina();
        game.wardOfPreservationUsed = false;
        game.meditateStacks = 0;
        game.scryLockedRoom = null;
        game.ritualBuffEnd = 0;
        game.attuneDiscount = 0;
        game.relics = [];
        game.relicDraft = [];
        game.relicDraftSeen = false;
        game.sigilStacks = 0;
        game.relicHuntCooldownEnd = 0;
        game.transmutateCooldownEnd = 0;
        game.manaSiphonCooldownEnd = 0;
        game.runeAccretionCooldownEnd = 0;
        game.staminaTransmuteCooldownEnd = 0;
        game.focusCondenserCooldownEnd = 0;
        game.leylineResonanceCooldownEnd = 0;
        game.towerPulseCooldownEnd = 0;
        game.chronoLoopCooldownEnd = 0;
        game.nexusOverclockCooldownEnd = 0;
        game.worldweaveCooldownEnd = 0;
        game.convergenceCooldownEnd = 0;
        game.paradoxCastCooldownEnd = 0;
        game.nextFloorDiscountPct = 0;
        game.nextFloorDuplicate = null;
        game.nextFloorCursed = false;
        game.nextFloorBonus = false;
        game.stats.focusSurgeCasts = 0;
        game.stats.vigorInfusionCasts = 0;
        game.stats.transmutateCasts = 0;
        renderAll();
        playSound('milestone');
      };
      ascendBtn.disabled = !canAscend;

      const hasAscended = (game.ascension || 0) + (game.ascensionTier2 || 0) >= 1;
      const showParagon = hasAscended && totalFloors() >= PARAGON_FLOOR_MIN;
      if (paragonSection) paragonSection.style.display = showParagon ? 'block' : 'none';
      if (showParagon && paragonXpEl) {
        const xp = game.paragonXp || 0;
        paragonXpEl.textContent = 'Paragon XP: ' + formatNum(xp);
      }
      if (showParagon && paragonNodes) {
        const s = game.paragonSpent || { manaPct: 0, spellEffect: 0, stamina: 0, focus: 0 };
        const xp = game.paragonXp || 0;
        paragonNodes.innerHTML = '';
        const addNode = (key, label, maxLvl) => {
          const cur = s[key] || 0;
          const btn = document.createElement('button');
          btn.textContent = label + ' (' + cur + '/' + maxLvl + ') — ' + PARAGON_NODE_COST + ' XP';
          btn.disabled = xp < PARAGON_NODE_COST || cur >= maxLvl;
          btn.onclick = () => {
            if (game.paragonXp < PARAGON_NODE_COST) return;
            if ((s[key] || 0) >= maxLvl) return;
            game.paragonXp -= PARAGON_NODE_COST;
            if (!game.paragonSpent) game.paragonSpent = { manaPct: 0, spellEffect: 0, stamina: 0, focus: 0 };
            game.paragonSpent[key] = (game.paragonSpent[key] || 0) + 1;
            renderAll();
          };
          paragonNodes.appendChild(btn);
        };
        addNode('manaPct', '+0.5% mana/sec', 20);
        addNode('spellEffect', '+1% spell effect', 15);
        addNode('stamina', '+5 max stamina', 10);
        addNode('focus', '+5 max focus', 10);
      }

      const ascensionTabUnlocked = totalFloors() >= ASCENSION_TAB_UNLOCK;
      if (ascensionTab) {
        if (ascensionTabUnlocked) {
          ascensionTab.classList.remove('tab-locked');
          ascensionTab.title = 'Ascension';
        } else {
          ascensionTab.classList.add('tab-locked');
          ascensionTab.title = 'Unlocks at ' + ASCENSION_TAB_UNLOCK + ' floors';
        }
      }
      if (relicTab) {
        const relicUnlocked = (game.relics || []).length > 0;
        if (relicUnlocked) {
          relicTab.classList.remove('tab-locked');
          relicTab.title = 'Relics';
        } else {
          relicTab.classList.add('tab-locked');
          relicTab.title = 'Unlocks after claiming your first relic';
        }
      }

      renderRoomSummary();
      renderTowerUpgrades();
      renderTimeDilationStatus();
      renderTutorialHints();
      ensureRelicDraft();
      updateBadges();
    }

    function renderTowerUpgrades() {
      towerUpgradeButtons.innerHTML = '';
      const sr = game.specialRooms || {};
      const built = SPECIAL_ROOM_NAMES.filter(name => sr[name] && sr[name].built);
      if (built.length === 0) return;
      const title = document.createElement('p');
      title.className = 'section-title';
      title.textContent = 'Upgrade built rooms';
      towerUpgradeButtons.appendChild(title);
      built.forEach(name => {
        const r = sr[name];
        const cost = upgradeCost(name);
        const btn = document.createElement('button');
        btn.innerHTML = 'Upgrade ' + name + '<span class="cost">Cost: ' + formatNum(cost) + ' mana</span>';
        btn.onclick = () => {
          if (game.mana < cost) return;
          game.mana -= cost;
          r.level = (r.level || 1) + 1;
          renderAll();
        };
        if (game.mana < cost) btn.disabled = true;
        towerUpgradeButtons.appendChild(btn);
      });
    }

    function renderActivities() {
      activitiesDiv.innerHTML = '';
      const floors = Number(totalFloors()) || 0;
      const stamina = Number(game.stamina) || 0;
      const focus = Number(game.focus) || 0;
      const EPS = 1e-3;
      const unlocked = [];
      const locked = [];
      ACTIVITIES.forEach(a => {
        const unlockFloors = Number(a.unlockFloors) || 0;
        if (floors >= unlockFloors) unlocked.push(a);
        else locked.push(a);
      });
      locked.sort((a, b) => (Number(a.unlockFloors) || 0) - (Number(b.unlockFloors) || 0));
      const activitiesToShow = unlocked.concat(locked.slice(0, 3));
      activitiesToShow.forEach(a => {
        const btn = document.createElement('button');
        btn.textContent = a.name;
        const unlockFloors = Number(a.unlockFloors) || 0;
        const locked = unlockFloors > 0 && floors < unlockFloors;
        let detail = a.costText ? a.costText() : '';
        if (a.cooldownMs) {
          const cooldownKey = a.cooldownKey || 'ritualActivityCooldownEnd';
          const end = game[cooldownKey] || 0;
          const rem = Math.max(0, (end - Date.now()) / 1000);
          if (rem > 0) {
            const m = Math.floor(rem / 60);
            const s = Math.floor(rem % 60);
            detail = 'Available in ' + m + ':' + (s < 10 ? '0' : '') + s;
          }
        }
        const desc = document.createElement('span');
        desc.className = 'desc';
        desc.innerHTML = a.desc + '<br><span class="detail">' + detail + '</span>';
        btn.appendChild(desc);
        const ritualMult = a.id === 'ritual' ? ritualCostMultiplier() : 1;
        const costAmount = a.costStaminaPct != null ? maxStamina() * a.costStaminaPct * ritualMult : 0;
        const cooldownKey = a.cooldownKey || 'ritualActivityCooldownEnd';
        const onCooldown = a.cooldownMs && (game[cooldownKey] || 0) > Date.now();
        const lowFocus = a.focusCost != null && focus < a.focusCost - EPS;
        const lowStamina = a.costStaminaPct != null && stamina < costAmount - EPS;
        const customDisabled = typeof a.disabled === 'function' ? a.disabled() : false;
        btn.onclick = () => {
          if (locked) return;
          if (a.costStaminaPct != null && game.stamina < costAmount) return;
          if (onCooldown) return;
          a.effect();
          renderAll();
        };
        btn.disabled = locked || lowFocus || lowStamina || onCooldown || customDisabled;
        if (locked) {
          const hint = document.createElement('span');
          hint.className = 'unlock-hint';
          hint.textContent = 'Unlocks at ' + unlockFloors + ' floors';
          btn.appendChild(hint);
        }
        activitiesDiv.appendChild(btn);
      });
    }

    function renderTimeDilationStatus() {
      const active = game.active && game.active.timer > 0;
      const harvestActive = game.active && game.active.harvestTimer > 0;
      timeDilationStatus.style.display = active || harvestActive ? 'block' : 'none';
      if (!active && !harvestActive) return;
      const boost = (game.active.boostTD || 1) * (game.active.boostHarvest || 1);
      if (active) {
        const dur = (game.active.duration && game.active.duration > 0) ? game.active.duration : game.active.timer;
        const frac = Math.max(0, Math.min(1, game.active.timer / dur));
        timeDilationFill.style.width = (frac * 100).toFixed(2) + '%';
        timeDilationTime.textContent = Math.max(0, game.active.timer).toFixed(1) + 's left';
        timeDilationBoost.textContent = 'Boost: x' + boost.toFixed(2);
      } else {
        const dur = game.active.harvestDuration || 5;
        const frac = Math.max(0, Math.min(1, game.active.harvestTimer / dur));
        timeDilationFill.style.width = (frac * 100).toFixed(2) + '%';
        timeDilationTime.textContent = 'Arcane Harvest: ' + game.active.harvestTimer.toFixed(1) + 's';
        timeDilationBoost.textContent = 'Boost: x' + boost.toFixed(2);
      }
    }

    function formatSwapCooldown(sec) {
      if (sec <= 0) return 'Ready to swap';
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      return 'Next swap in: ' + m + ':' + (s < 10 ? '0' : '') + s;
    }

    function renderSpells() {
      const usedSlots = (game.memorizedSpells || []).length;
      const totalSlots = maxSpellSlots();
      grimoireSpellSlotsEl.textContent = 'Spell slots: ' + usedSlots + ' / ' + totalSlots;
      const swapRem = spellSwapCooldownRemaining();
      grimoireSwapTimerEl.textContent = formatSwapCooldown(swapRem);

      activeSpellsDiv.innerHTML = '';
      passiveSpellsDiv.innerHTML = '';

      const tdActive = !!(game.active && game.active.timer > 0);
      const harvestActive = !!(game.active && game.active.harvestTimer > 0);
      const floors = totalFloors();
      const swapReady = canSwapSpell();

      const floorLockedActive = ACTIVE_SPELLS.filter(s => !isSpellUnlocked(s, true) && !s.unlockCheck && typeof s.unlock === 'number');
      floorLockedActive.sort((a, b) => (a.unlock || 0) - (b.unlock || 0));
      const nextLockedActive = floorLockedActive[0];
      const activeToShow = ACTIVE_SPELLS.filter(s => isSpellUnlocked(s, true) || s.unlockCheck || s === nextLockedActive);
      const activeSort = (s) => {
        if (typeof s.sortKey === 'number') return s.sortKey;
        if (s.unlockCheck && !isSpellUnlocked(s, true)) return 900;
        return typeof s.unlock === 'number' ? s.unlock : 999;
      };
      activeToShow.sort((a, b) => activeSort(a) - activeSort(b));

      const leylineSurgeActive = !!(game.active && game.active.leylineTapTimer > 0);
      activeToShow.forEach(s => {
        const spellId = getSpellId(s, true);
        const memorized = isMemorized(spellId);
        const hideWhenActive = s.hideWhenActive && ((s.name === 'Time Dilation' && tdActive) || (s.harvestKey && harvestActive) || (s.leylineTapKey && leylineSurgeActive));
        if (hideWhenActive) return;
        const onSpellCooldown = s.name === 'Time Dilation' && game.active && game.active.cooldown > 0;
        const cooldownKey = s.cooldownKey;
        const cooldownMs = s.cooldownMs || 0;
        const cooldownEnd = cooldownKey ? (game[cooldownKey] || 0) : 0;
        const cooldownRem = Math.max(0, (cooldownEnd - Date.now()) / 1000);
        const onCooldown = cooldownRem > 0;
        if (onSpellCooldown) return;

        const wrap = document.createElement('div');
        wrap.className = 'spell-row';
        const btn = document.createElement('button');
        btn.textContent = s.name;
        const unlocked = isSpellUnlocked(s, true);
        if (!unlocked) {
          btn.disabled = true;
          const hint = document.createElement('span');
          hint.className = 'unlock-hint';
          hint.textContent = spellUnlockHint(s);
          hint.style.display = 'block';
          btn.appendChild(hint);
          wrap.appendChild(btn);
        } else if (memorized) {
          const desc = document.createElement('span');
          desc.className = 'desc';
          const cooldownText = onCooldown ? ('Cooldown ' + cooldownRem.toFixed(1) + 's') : '';
          const detail = [s.costText ? s.costText() : '', cooldownText].filter(Boolean).join(' · ');
          desc.innerHTML = s.desc + '<br><span class="detail">' + detail + '</span>';
          btn.appendChild(desc);
          btn.onclick = () => s.effect();
          const lowFocus = (s.focusCost != null && (game.focus || 0) < s.focusCost);
          btn.disabled = lowFocus || onCooldown;
          if (cooldownMs > 0) {
            const overlay = document.createElement('div');
            overlay.className = 'cooldown-overlay';
            const frac = onCooldown ? (1 - Math.min(1, (cooldownRem * 1000) / cooldownMs)) : 1;
            overlay.style.width = (frac * 100).toFixed(2) + '%';
            btn.appendChild(overlay);
          }
          const forgetBtn = document.createElement('button');
          forgetBtn.textContent = 'Forget';
          forgetBtn.className = 'spell-slot-btn';
          forgetBtn.disabled = !swapReady;
          forgetBtn.onclick = (e) => { e.stopPropagation(); forgetSpell(spellId); };
          wrap.appendChild(btn);
          wrap.appendChild(forgetBtn);
        } else {
          const desc = document.createElement('span');
          desc.className = 'desc';
          desc.innerHTML = s.desc + '<br><span class="detail">Not memorized</span>';
          btn.appendChild(desc);
          btn.disabled = true;
          const memBtn = document.createElement('button');
          memBtn.textContent = 'Memorize';
          memBtn.className = 'spell-slot-btn';
          memBtn.disabled = !swapReady || usedSlots >= totalSlots;
          memBtn.onclick = (e) => { e.stopPropagation(); memorizeSpell(spellId); };
          wrap.appendChild(btn);
          wrap.appendChild(memBtn);
        }
        activeSpellsDiv.appendChild(wrap);
      });

      const floorLockedPassive = PASSIVE_SPELLS.filter(s => !isSpellUnlocked(s, false) && !s.unlockCheck && typeof s.unlock === 'number');
      floorLockedPassive.sort((a, b) => (a.unlock || 0) - (b.unlock || 0));
      const nextLockedPassive = floorLockedPassive[0];
      const passiveToShow = PASSIVE_SPELLS.filter(s => isSpellUnlocked(s, false) || s.unlockCheck || s === nextLockedPassive);
      const passiveSort = (s) => {
        if (s.unlockCheck && !isSpellUnlocked(s, false)) return 900;
        return typeof s.unlock === 'number' ? s.unlock : 999;
      };
      passiveToShow.sort((a, b) => passiveSort(a) - passiveSort(b));

      passiveToShow.forEach(s => {
        const spellId = getSpellId(s, false);
        const memorized = isMemorized(spellId);
        const wrap = document.createElement('div');
        wrap.className = 'spell-row';
        const btn = document.createElement('button');
        btn.textContent = s.name;
        const unlocked = isSpellUnlocked(s, false);
        if (!unlocked) {
          btn.disabled = true;
          const hint = document.createElement('span');
          hint.className = 'unlock-hint';
          hint.textContent = spellUnlockHint(s);
          hint.style.display = 'block';
          btn.appendChild(hint);
          wrap.appendChild(btn);
        } else if (memorized) {
          const level = s.key ? (game.passive[s.key] ?? 0) : 0;
          const cost = s.cost ? s.cost() * SCALE : 0;
          const desc = document.createElement('span');
          desc.className = 'desc';
          desc.innerHTML = s.desc + '<br><span class="detail">Level ' + level + ' · Cost ' + formatNum(cost) + ' mana</span>';
          btn.appendChild(desc);
          btn.onclick = () => {
            const c = s.cost() * SCALE;
            if (game.mana >= c) {
              game.mana -= c;
              s.effect();
              renderAll();
            }
          };
          const forgetBtn = document.createElement('button');
          forgetBtn.textContent = 'Forget';
          forgetBtn.className = 'spell-slot-btn';
          forgetBtn.disabled = !swapReady;
          forgetBtn.onclick = (e) => { e.stopPropagation(); forgetSpell(spellId); };
          wrap.appendChild(btn);
          wrap.appendChild(forgetBtn);
        } else {
          const level = s.key ? (game.passive[s.key] ?? 0) : 0;
          const desc = document.createElement('span');
          desc.className = 'desc';
          desc.innerHTML = s.desc + '<br><span class="detail">Level ' + level + ' · Not memorized</span>';
          btn.appendChild(desc);
          btn.disabled = true;
          const memBtn = document.createElement('button');
          memBtn.textContent = 'Memorize';
          memBtn.className = 'spell-slot-btn';
          memBtn.disabled = !swapReady || (game.memorizedSpells || []).length >= maxSpellSlots();
          memBtn.onclick = (e) => { e.stopPropagation(); memorizeSpell(spellId); };
          wrap.appendChild(btn);
          wrap.appendChild(memBtn);
        }
        passiveSpellsDiv.appendChild(wrap);
      });
    }

    function anyActiveSpellCooldown() {
      return activeCooldownCount() > 0;
    }

    function towerTier(f) { if (f >= 40) return 4; if (f >= 30) return 3; if (f >= 10) return 2; return 1; }
    function renderTower() {
      towerContainer.innerHTML = '';
      const sr = game.specialRooms || {};
      const blocks = [{ type: 'Foundation' }];
      for (let i = 0; i < (game.stairs || 0); i++) {
        const side = i % 3 === 1 ? 'side-left' : (i % 3 === 2 ? 'side-right' : '');
        blocks.push({ type: 'Stairs', side });
      }
      SPECIAL_ROOM_NAMES.forEach(name => {
        if (sr[name] && sr[name].built) blocks.push({ type: name, level: sr[name].level || 1, side: blocks.length % 2 ? 'side-right' : 'side-left' });
      });
      blocks.forEach((b, i) => {
        const el = document.createElement('div');
        const height = i + 1;
        const isTop = i === blocks.length - 1;
        const addCrenel = isTop && height >= 6;
        const addTurrets = isTop && height >= 14;
        const tier = towerTier(height);
        const foundationClass = b.type === 'Foundation' ? ' foundation' : '';
        el.className = 'tower-block tier-' + tier + foundationClass + (b.side ? ' ' + b.side : '');
        const label = (b.type === 'Foundation') ? 'Foundation' : (b.level ? b.type + ' Lv.' + b.level : b.type);
        const topper = (addCrenel || addTurrets)
          ? '<div class="tower-topper">' +
              (addCrenel ? '<div class="tower-crenel"></div>' : '') +
              (addTurrets ? '<div class="tower-turrets"><div class="turret left"></div><div class="turret right"></div></div>' : '') +
            '</div>'
          : '';
        // windows: show more as the tower grows (keeps silhouette clean, adds detail)
        const windowCount = Math.min(6, Math.max(0, Math.floor(height / 6)));
        let windowsHtml = '';
        if (windowCount > 0) {
          const win = [];
          for (let w = 0; w < windowCount; w++) win.push('<div class="tower-window"></div>');
          windowsHtml = '<div class="tower-windows">' + win.join('') + '</div>';
        }
        el.innerHTML = topper + windowsHtml + '<div class="room">' + label + '</div>';
        if (b.type === 'Foundation') {
          el.style.cursor = 'pointer';
          el.title = 'Foundation: the base of your tower.';
          el.onclick = openFoundationDetail;
        } else if (b.type !== 'Stairs' && ROOMS[b.type]) {
          el.style.cursor = 'pointer';
          el.dataset.room = b.type;
          el.title = ROOMS[b.type].desc || '';
          el.onclick = () => openRoomDetail(b.type);
        } else if (b.type === 'Stairs' && ROOMS.Stairs) el.title = ROOMS.Stairs.desc || '';
        towerContainer.appendChild(el);
      });
    }

    function renderRoomSummary() {
      const sr = game.specialRooms || {};
      let html = '<strong>Rooms</strong><br>';
      html += 'Foundation<br><span class="cost">The base of your tower. No bonuses.</span><br>';
      if ((game.stairs || 0) > 0) html += 'Stairs x' + game.stairs + '<br><span class="cost">' + (ROOMS.Stairs && ROOMS.Stairs.desc) + '</span><br>';
      SPECIAL_ROOM_NAMES.forEach(name => {
        const r = sr[name];
        if (r && r.built) {
          const level = r.level || 1;
          html += name + ' (Lv.' + level + ')<br><span class="cost">' + (ROOMS[name] && ROOMS[name].desc) + '</span><br>';
        }
      });
      roomSummary.innerHTML = html || 'No rooms yet.';
    }

    function doPrestige(soft) {
      const savedMana = game.wardOfPreservationUsed ? game.mana * 0.05 : 0;
      const hallLvl = countRooms('Hall of Preservation');
      const savedFloorsKept = hallLvl >= 1 ? Math.floor(totalFloors() * PRESTIGE_KEEP_FLOORS_PCT) : 0;
      game.stats.totalFloorsEver = (game.stats.totalFloorsEver || 0) + totalFloors();
      const fullPrestige = !soft;
      if (fullPrestige) game.prestigeTokens = (game.prestigeTokens || 0) + 1;
      const choice = game.prestigeTokenChoice;
      const keepManaFont = fullPrestige && choice === 'font' && game.prestigeTokens >= 1;
      const keepStudyPct = fullPrestige && choice === 'study' && game.prestigeTokens >= 1;
      const keepRelic = fullPrestige && choice === 'relic' && game.prestigeTokens >= 1 && (game.relics || []).length > 0;
      if (keepManaFont) game.prestigeTokens--;
      if (keepStudyPct) game.prestigeTokens--;
      if (keepRelic) game.prestigeTokens--;
      const studyKept = keepStudyPct ? Math.floor((game.studyCount || 0) * 0.05) : 0;
      const relicKept = keepRelic ? [game.relics[0]] : [];
      game.prestige = soft ? game.prestige : game.prestige + 1;
      game.softPrestige = soft ? game.softPrestige + 1 : game.softPrestige;
      game.mana = savedMana;
      game.manaFonts = keepManaFont ? 1 : 0;
      game.specialRooms = initialSpecialRooms();
      game.memorizedSpells = (game.memorizedSpells || []).slice(0, maxSpellSlots());
      game.stairs = 0;
      game.floorsKept = savedFloorsKept;
      game.passive = { arcane: 0, astral: 0, conduit: 0, towerBond: 0, staminaWell: 0, spellEcho: 0, focusFlow: 0, manaReservoir: 0, ritualMastery: 0, aetherFlux: 0, anchoredRituals: 0 };
      game.active = {
        boost: 1,
        boostTD: 1,
        boostHarvest: 1,
        timer: 0,
        duration: 0,
        cooldown: 0,
        harvestTimer: 0,
        harvestDuration: 0,
        leylineTapTimer: 0,
        leylineTapPct: 0,
        runeTimer: 0,
        runeStacks: 0,
        focusCondenserTimer: 0,
        spellCostDiscountTimer: 0,
        spellCostDiscountPct: 0,
        overclockTimer: 0,
        overclockMult: 1,
        worldweaveTimer: 0,
        convergenceTimer: 0,
        paradoxTimer: 0,
      };
      game.studyCount = studyKept;
      game.stamina = maxStamina();
      game.wardOfPreservationUsed = false;
      game.prestigeTokenChoice = null;
      game.meditateStacks = 0;
      game.scryLockedRoom = null;
      game.ritualBuffEnd = 0;
      game.attuneDiscount = 0;
      game.relics = relicKept;
      game.relicDraft = [];
      game.relicDraftSeen = false;
      game.sigilStacks = 0;
      game.relicHuntCooldownEnd = 0;
      game.transmutateCooldownEnd = 0;
      game.nextFloorDuplicate = null;
      game.nextFloorCursed = false;
      game.nextFloorBonus = false;
      game.nextFloorDiscountPct = 0;
      game.stats.timeDilationCasts = 0;
      game.stats.arcaneHarvestCasts = 0;
      game.stats.transmutateCasts = 0;
      game.stats.focusSurgeCasts = 0;
      game.stats.vigorInfusionCasts = 0;
      renderAll();
      playSound('milestone');
    }

    // -------------------- ROOM MODAL --------------------
    function openRoomSelect() {
      roomModal.style.display = 'flex';
      roomChoices.innerHTML = '';
      const sr = game.specialRooms || {};
      if (totalFloors() >= 1 && !game.nextFloorCursed && !game.nextFloorBonus) {
        if (Math.random() < 0.12) game.nextFloorCursed = true;
        else if (Math.random() < 0.12) game.nextFloorBonus = true;
      }
      const cost = effectiveFloorCost();
      const floorStaminaCost = effectiveFloorStaminaCost();
      const suffix = game.nextFloorCursed ? ' (Cursed: 1.5× cost, 2× effect)' : (game.nextFloorBonus ? ' (Bonus: free)' : '');
      const levelGain = game.nextFloorCursed ? 2 : 1;
      const addCard = (name) => {
        const info = ROOMS[name];
        if (!info) return;
        const card = document.createElement('div');
        card.className = 'room-card';
        const built = sr[name] && sr[name].built;
        let label = built ? ('Duplicate: +' + levelGain + ' lvl to ' + name) : name;
        if (suffix) label += suffix;
        card.textContent = label;
        const tooltip = document.createElement('span');
        tooltip.className = 'tooltip';
        tooltip.textContent = info.desc;
        card.appendChild(tooltip);
        if (!info.unlock()) {
          card.classList.add('disabled');
          const hint = document.createElement('span');
          hint.className = 'unlock-hint';
          hint.textContent = 'Unlocks at ' + info.unlockFloors + ' floors';
          card.appendChild(hint);
        } else {
          card.onclick = () => {
            if (game.mana < cost || game.stamina < floorStaminaCost) {
              showToast('Need more resources', 'This floor costs ' + formatNum(cost) + ' mana and ' + formatNum(Math.floor(floorStaminaCost)) + ' stamina.');
              return;
            }
            game.mana -= cost;
            game.stamina -= floorStaminaCost;
            if (!sr[name]) game.specialRooms[name] = { built: false, level: 0 };
            if (built) {
              sr[name].level = (sr[name].level || 1) + levelGain;
              game.stairs++;
            } else {
              game.specialRooms[name].built = true;
              game.specialRooms[name].level = levelGain;
            }
            game.nextFloorCursed = false;
            game.nextFloorBonus = false;
            game.nextFloorDiscountPct = 0;
            game.scryLockedRoom = null;
            roomModal.style.display = 'none';
            renderAll();
          };
        }
        roomChoices.appendChild(card);
      };
      const unlocked = unlockedRoomNames();
      if (unlocked.length === 0) {
        roomChoices.innerHTML = '<div class="stat">No rooms available yet.</div>';
        return;
      }
      const offered = [];
      if (game.scryLockedRoom && unlocked.includes(game.scryLockedRoom)) {
        offered.push(game.scryLockedRoom);
      }
      const pool = unlocked.filter(name => !offered.includes(name));
      while (offered.length < 3 && pool.length > 0) {
        const idx = Math.floor(Math.random() * pool.length);
        offered.push(pool.splice(idx, 1)[0]);
      }
      offered.forEach(name => addCard(name));
    }

    let currentRoomDetailName = null;
    function openFoundationDetail() {
      currentRoomDetailName = 'Foundation';
      roomDetailTitle.textContent = 'Foundation';
      roomDetailDesc.textContent = 'The bedrock of your mage tower. It provides stability but no bonuses.';
      roomDetailLevel.textContent = '0';
      roomDetailUpgradeBtn.style.display = 'none';
      roomDetailUpgradeBtn.disabled = true;
      roomDetailModal.style.display = 'flex';
    }
    function openRoomDetail(roomName) {
      const info = ROOMS[roomName];
      const r = (game.specialRooms || {})[roomName];
      if (!info || !r || !r.built) return;
      roomDetailUpgradeBtn.style.display = '';
      roomDetailUpgradeBtn.disabled = false;
      currentRoomDetailName = roomName;
      roomDetailTitle.textContent = roomName;
      roomDetailDesc.textContent = info.desc || '';
      const lvl = r.level || 1;
      roomDetailLevel.textContent = lvl;
      const refreshUpgradeBtn = () => {
        const cost = upgradeCost(roomName);
        roomDetailUpgradeBtn.innerHTML = 'Upgrade<span class="cost">Cost: ' + formatNum(cost) + ' mana (Shift: x10, Ctrl: max)</span>';
        roomDetailUpgradeBtn.disabled = (game.mana || 0) < cost;
      };
      refreshUpgradeBtn();
      roomDetailUpgradeBtn.onclick = (e) => {
        const isMax = e && (e.ctrlKey || e.metaKey);
        const want = isMax ? 100000 : (e && e.shiftKey) ? 10 : 1;
        let done = 0;
        for (let i = 0; i < want; i++) {
          const c = upgradeCost(roomName);
          if ((game.mana || 0) < c) break;
          game.mana -= c;
          r.level = (r.level || 1) + 1;
          done++;
        }
        if (done > 0) {
          playSound('click');
          roomDetailLevel.textContent = r.level;
          renderAll();
        }
        refreshUpgradeBtn();
      };
      roomDetailModal.style.display = 'flex';
    }
    function closeRoomDetail() {
      roomDetailModal.style.display = 'none';
      roomDetailUpgradeBtn.style.display = '';
      currentRoomDetailName = null;
    }
    roomDetailClose.onclick = closeRoomDetail;
    roomDetailModal.addEventListener('click', (e) => { if (e.target === roomDetailModal) closeRoomDetail(); });
    roomDetailModal.querySelector('.modal-content').addEventListener('click', (e) => e.stopPropagation());
    if (relicModal) {
      relicModal.addEventListener('click', (e) => { if (e.target === relicModal) relicModal.style.display = 'none'; });
      const relicContent = relicModal.querySelector('.modal-content');
      if (relicContent) relicContent.addEventListener('click', (e) => e.stopPropagation());
    }

    // -------------------- BUTTONS --------------------
    manaFontBtn.onclick = (e) => {
      const maxN = maxAffordableManaFonts();
      const wantN = (e && (e.ctrlKey || e.metaKey)) ? maxN : (e && e.shiftKey) ? Math.min(10, maxN) : Math.min(1, maxN);
      if (wantN <= 0) return;
      const bought = buyManaFonts(wantN);
      if (bought > 0) {
        playSound('click');
        renderAll();
      }
    };
    towerBtn.onclick = openRoomSelect;

    function closeSettings() { settingsModal.style.display = 'none'; }
    settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) closeSettings(); });
    settingsModal.querySelector('.modal-content').addEventListener('click', (e) => e.stopPropagation());

    function setSettingsTab(tab) {
      const onPrefs = tab === 'prefs';
      const onGlossary = tab === 'glossary';
      const onKeys = tab === 'keys';
      if (settingsTabPrefs) {
        settingsTabPrefs.classList.toggle('active', onPrefs);
        settingsTabPrefs.setAttribute('aria-selected', String(onPrefs));
      }
      if (settingsTabGlossary) {
        settingsTabGlossary.classList.toggle('active', onGlossary);
        settingsTabGlossary.setAttribute('aria-selected', String(onGlossary));
      }
      if (settingsTabKeys) {
        settingsTabKeys.classList.toggle('active', onKeys);
        settingsTabKeys.setAttribute('aria-selected', String(onKeys));
      }
      if (settingsPagePrefs) settingsPagePrefs.classList.toggle('hidden', !onPrefs);
      if (settingsPageGlossary) settingsPageGlossary.classList.toggle('hidden', !onGlossary);
      if (settingsPageKeys) settingsPageKeys.classList.toggle('hidden', !onKeys);
      if (!game.tutorial || typeof game.tutorial !== 'object') game.tutorial = { clicked: false, done: false, completedToast: false };
      if (onKeys) game.tutorial.keysSeen = true;
      if (onGlossary) game.tutorial.glossarySeen = true;
      if (onKeys) renderKeybinds();
      renderTutorialHints();
    }

    function openPanel(id) {
      document.querySelectorAll('.panel-modal').forEach(m => m.classList.remove('show'));
      document.querySelectorAll('#bottomNav .tab').forEach(t => t.classList.remove('active'));
      const modal = document.getElementById(id);
      const tab = document.querySelector('#bottomNav .tab[data-panel="' + id + '"]');
      if (modal) modal.classList.add('show');
      if (tab) tab.classList.add('active');
    }
    function closePanel(id) {
      const modal = document.getElementById(id);
      const tab = document.querySelector('#bottomNav .tab[data-panel="' + id + '"]');
      if (modal) modal.classList.remove('show');
      if (tab) tab.classList.remove('active');
    }
    document.querySelectorAll('#bottomNav .tab').forEach(tab => {
      tab.addEventListener('click', () => {
        if (tab.classList.contains('tab-locked')) {
          const panelId = tab.getAttribute('data-panel');
          if (panelId === 'ascensionModal') showToast('Ascension', 'Unlocks at ' + ASCENSION_TAB_UNLOCK + ' floors.');
          else if (panelId === 'relicsModal') showToast('Relics', 'Claim your first relic to unlock this tab.');
          else showToast('Locked', 'This tab is currently locked.');
          return;
        }
        const panelId = tab.getAttribute('data-panel');
        const modal = document.getElementById(panelId);
        if (modal && modal.classList.contains('show')) closePanel(panelId);
        else openPanel(panelId);
      });
    });

    function closeAllOverlays() {
      document.querySelectorAll('.panel-modal').forEach(m => m.classList.remove('show'));
      document.querySelectorAll('#bottomNav .tab').forEach(t => t.classList.remove('active'));
      if (roomModal) roomModal.style.display = 'none';
      if (relicModal) relicModal.style.display = 'none';
      if (settingsModal) settingsModal.style.display = 'none';
      if (statsModal) statsModal.style.display = 'none';
      if (introModal) introModal.style.display = 'none';
      if (roomDetailModal) roomDetailModal.style.display = 'none';
      if (loreTip) loreTip.style.display = 'none';
    }
    function togglePanelById(id) {
      const modal = document.getElementById(id);
      if (!modal) return;
      if (modal.classList.contains('show')) closePanel(id);
      else openPanel(id);
    }
    function normalizeKeyEvent(e) {
      if (e.key === 'Escape') return 'esc';
      if (e.key === '?' || (e.key === '/' && e.shiftKey)) return '?';
      if (e.key && e.key.length === 1) return e.key.toLowerCase();
      return null;
    }
    document.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      const tag = (e.target && e.target.tagName) ? String(e.target.tagName).toLowerCase() : '';
      if (tag === 'input' || tag === 'textarea') return;

      if (awaitingRebind) {
        const nextKey = normalizeKeyEvent(e);
        if (!nextKey) return;
        e.preventDefault();
        e.stopPropagation();
        const binds = ensureKeybinds();
        binds[awaitingRebind] = nextKey;
        awaitingRebind = null;
        renderKeybinds();
        renderTutorialHints();
        return;
      }

      const k = normalizeKeyEvent(e);
      if (!k) return;
      const binds = ensureKeybinds();
      if (k === binds.close) { closeAllOverlays(); return; }
      if (k === binds.activities) togglePanelById('activitiesModal');
      else if (k === binds.grimoire) togglePanelById('grimoireModal');
      else if (k === binds.tower) togglePanelById('towerModal');
      else if (k === binds.ascension) {
        if (ascensionTab && ascensionTab.classList.contains('tab-locked')) {
          showToast('Ascension', 'Unlocks at ' + ASCENSION_TAB_UNLOCK + ' floors.');
          return;
        }
        togglePanelById('ascensionModal');
      }
      else if (k === binds.relics) {
        if (relicTab && relicTab.classList.contains('tab-locked')) {
          showToast('Relics', 'Claim your first relic to unlock this tab.');
          return;
        }
        togglePanelById('relicsModal');
      }
      else if (k === binds.settings) {
        if (settingsModal) {
          const open = settingsModal.style.display !== 'flex';
          settingsModal.style.display = open ? 'flex' : 'none';
          if (open) {
            setSettingsTab('prefs');
            if (!game.tutorial || typeof game.tutorial !== 'object') game.tutorial = { clicked: false, done: false, completedToast: false };
            game.tutorial.settingsOpened = true;
            renderTutorialHints();
          }
        }
      }
      else if (k === binds.help) { if (introModal) introModal.style.display = 'flex'; }
      else if (k === binds.manaFont) { manaFontBtn && manaFontBtn.click(); }
    });
    document.querySelectorAll('.panel-modal').forEach(modal => {
      modal.addEventListener('click', (e) => { if (e.target === modal) closePanel(modal.id); });
    });
    document.querySelectorAll('.panel-content').forEach(content => {
      content.addEventListener('click', (e) => e.stopPropagation());
    });
    window.addEventListener('resize', () => { renderTutorialHints(); });

    soundCheckbox.checked = game.soundEnabled;
    soundCheckbox.onchange = () => { game.soundEnabled = soundCheckbox.checked; };
    renderKeybinds();

    if (tutorialCheckbox) {
      tutorialCheckbox.checked = !!game.settings.showTutorial;
      tutorialCheckbox.onchange = () => {
        game.settings.showTutorial = tutorialCheckbox.checked;
        renderTutorialHints();
      };
    }
    if (tutorialResetBtn) {
      tutorialResetBtn.onclick = () => {
        game.tutorial = { clicked: false, done: false, completedToast: false, settingsOpened: false, keysSeen: false, glossarySeen: false };
        renderTutorialHints();
      };
    }
    if (loreCloseBtn) loreCloseBtn.onclick = (e) => { e.stopPropagation(); hideLoreTip(); };
    if (loreTip) loreTip.onclick = () => hideLoreTip();
    if (settingsTabPrefs) settingsTabPrefs.onclick = () => setSettingsTab('prefs');
    if (settingsTabGlossary) settingsTabGlossary.onclick = () => setSettingsTab('glossary');
    if (settingsTabKeys) settingsTabKeys.onclick = () => setSettingsTab('keys');
    if (settingsBtn) {
      settingsBtn.onclick = () => {
        settingsModal.style.display = 'flex';
        setSettingsTab('prefs');
        if (!game.tutorial || typeof game.tutorial !== 'object') game.tutorial = { clicked: false, done: false, completedToast: false };
        game.tutorial.settingsOpened = true;
        renderTutorialHints();
      };
    }

    document.getElementById('statsBtn').onclick = () => {
      statsModal.style.display = 'flex';
      const played = (game.stats.timePlayedMs || 0) / 1000;
      const mins = Math.floor(played / 60);
      const hours = Math.floor(mins / 60);
      const timeStr = hours ? hours + 'h ' + (mins % 60) + 'm' : mins + 'm';
      const maxFloors = game.stats.maxFloorsReached || 0;
      const maxMps = game.stats.maxManaPerSecReached || 0;
      const goalReached = game.stats.goalManaReached ? ' (Goal reached!)' : '';
      statsGrid.innerHTML =
        '<span>Total mana earned</span><span class="value">' + formatNum(game.stats.totalManaEarned || 0) + '</span>' +
        '<span>Total spells cast</span><span class="value">' + (game.stats.totalSpellsCast || 0) + '</span>' +
        '<span>Time played</span><span class="value">' + timeStr + '</span>' +
        '<span>High score: max floors</span><span class="value">' + maxFloors + '</span>' +
        '<span>High score: max mana/sec</span><span class="value">' + formatRate(maxMps) + '/s' + goalReached + '</span>' +
        '<span>Relics (current run)</span><span class="value">' + ((game.relics || []).length) + '</span>' +
        '<span>Sigil stacks</span><span class="value">' + (game.sigilStacks || 0) + '</span>' +
        '<span>Goal: ' + formatNum(GOAL_MANA_PER_SEC) + ' mana/sec</span><span class="value">' + (game.stats.goalManaReached ? 'Done' : '—') + '</span>' +
        '<span>Prestiges</span><span class="value">' + (game.prestige + game.softPrestige) + '</span>' +
        '<span>Ascensions</span><span class="value">' + game.ascension + '</span>';
      achievementsList.innerHTML = '';
      ACHIEVEMENTS.forEach(a => {
        const got = (game.stats.achievements || []).includes(a.id);
        const line = document.createElement('div');
        line.style.marginBottom = '6px';
        line.innerHTML = (got ? '&#10003; ' : '&#9726; ') + '<strong>' + a.name + '</strong>: ' + a.desc + (a.reward ? ' (' + a.reward + ')' : '');
        line.style.opacity = got ? '1' : '0.6';
        achievementsList.appendChild(line);
      });
    };
    function closeStats() { statsModal.style.display = 'none'; }

    document.getElementById('exportBtn').onclick = () => {
      const json = JSON.stringify(game);
      navigator.clipboard.writeText(json).then(() => showToast('Export', 'Save copied to clipboard.')).catch(() => showToast('Export', 'Copy failed.'));
    };
    document.getElementById('importBtn').onclick = () => {
      const raw = prompt('Paste your save data:');
      if (!raw) return;
      try {
        const data = JSON.parse(raw);
        Object.assign(game, data);
        if (!game.stats) game.stats = { timeDilationCasts: 0, arcaneHarvestCasts: 0, leylineSurgeCasts: 0, focusSurgeCasts: 0, vigorInfusionCasts: 0, transmutateCasts: 0, manaCapHits: 0, zeroManaCasts: 0, totalManaEarned: 0, totalSpellsCast: 0, timePlayedMs: 0, achievements: [] };
        if (!game.passive || typeof game.passive !== 'object') game.passive = {};
        const passiveDefaults = { arcane: 0, astral: 0, conduit: 0, towerBond: 0, staminaWell: 0, spellEcho: 0, focusFlow: 0, manaReservoir: 0, ritualMastery: 0, aetherFlux: 0, anchoredRituals: 0 };
        Object.keys(passiveDefaults).forEach(k => { if (typeof game.passive[k] !== 'number') game.passive[k] = passiveDefaults[k]; });
        if (!game.active) game.active = { boost: 1, boostTD: 1, boostHarvest: 1, timer: 0, duration: 0, cooldown: 0, harvestTimer: 0, harvestDuration: 0, leylineTapTimer: 0, leylineTapPct: 0, runeTimer: 0, runeStacks: 0, focusCondenserTimer: 0, spellCostDiscountTimer: 0, spellCostDiscountPct: 0, overclockTimer: 0, overclockMult: 1, worldweaveTimer: 0, convergenceTimer: 0, paradoxTimer: 0 };
        if (typeof game.active.boostTD !== 'number') game.active.boostTD = 1;
        if (typeof game.active.boostHarvest !== 'number') game.active.boostHarvest = 1;
        if (typeof game.active.leylineTapTimer !== 'number') game.active.leylineTapTimer = 0;
        if (typeof game.active.leylineTapPct !== 'number') game.active.leylineTapPct = 0;
        if (typeof game.active.runeTimer !== 'number') game.active.runeTimer = 0;
        if (typeof game.active.runeStacks !== 'number') game.active.runeStacks = 0;
        if (typeof game.active.focusCondenserTimer !== 'number') game.active.focusCondenserTimer = 0;
        if (typeof game.active.spellCostDiscountTimer !== 'number') game.active.spellCostDiscountTimer = 0;
        if (typeof game.active.spellCostDiscountPct !== 'number') game.active.spellCostDiscountPct = 0;
        if (typeof game.active.overclockTimer !== 'number') game.active.overclockTimer = 0;
        if (typeof game.active.overclockMult !== 'number') game.active.overclockMult = 1;
        if (typeof game.active.worldweaveTimer !== 'number') game.active.worldweaveTimer = 0;
        if (typeof game.active.convergenceTimer !== 'number') game.active.convergenceTimer = 0;
        if (typeof game.active.paradoxTimer !== 'number') game.active.paradoxTimer = 0;
        if (typeof game.studyCount !== 'number') game.studyCount = 0;
        if (typeof game.stamina !== 'number') game.stamina = 0;
        if (typeof game.focus !== 'number') game.focus = 0;
        if (!Array.isArray(game.relics)) game.relics = [];
        if (!Array.isArray(game.relicDraft)) game.relicDraft = [];
        if (typeof game.relicDraftSeen !== 'boolean') game.relicDraftSeen = false;
        if (typeof game.sigilStacks !== 'number') game.sigilStacks = 0;
        if (typeof game.relicHuntCooldownEnd !== 'number') game.relicHuntCooldownEnd = 0;
        game.relics = (game.relics || []).filter(id => RELIC_BY_ID[id]);
        game.relicDraft = (game.relicDraft || []).filter(id => RELIC_BY_ID[id]);
        if (typeof game.transmutateCooldownEnd !== 'number') game.transmutateCooldownEnd = 0;
        if (typeof game.manaSiphonCooldownEnd !== 'number') game.manaSiphonCooldownEnd = 0;
        if (typeof game.runeAccretionCooldownEnd !== 'number') game.runeAccretionCooldownEnd = 0;
        if (typeof game.staminaTransmuteCooldownEnd !== 'number') game.staminaTransmuteCooldownEnd = 0;
        if (typeof game.focusCondenserCooldownEnd !== 'number') game.focusCondenserCooldownEnd = 0;
        if (typeof game.leylineResonanceCooldownEnd !== 'number') game.leylineResonanceCooldownEnd = 0;
        if (typeof game.towerPulseCooldownEnd !== 'number') game.towerPulseCooldownEnd = 0;
        if (typeof game.chronoLoopCooldownEnd !== 'number') game.chronoLoopCooldownEnd = 0;
        if (typeof game.nexusOverclockCooldownEnd !== 'number') game.nexusOverclockCooldownEnd = 0;
        if (typeof game.worldweaveCooldownEnd !== 'number') game.worldweaveCooldownEnd = 0;
        if (typeof game.convergenceCooldownEnd !== 'number') game.convergenceCooldownEnd = 0;
        if (typeof game.paradoxCastCooldownEnd !== 'number') game.paradoxCastCooldownEnd = 0;
        if (typeof game.nextFloorDiscountPct !== 'number') game.nextFloorDiscountPct = 0;
        if (typeof game.transmutateCooldownEnd !== 'number') game.transmutateCooldownEnd = 0;
        if (!game.paragonSpent || typeof game.paragonSpent.manaPct !== 'number') game.paragonSpent = { manaPct: 0, spellEffect: 0, stamina: 0, focus: 0 };
        if (!game.settings || typeof game.settings !== 'object') game.settings = { showTutorial: true, keybinds: {} };
        if (typeof game.settings.showTutorial !== 'boolean') game.settings.showTutorial = true;
        ensureKeybinds();
        if (!game.tutorial || typeof game.tutorial !== 'object') game.tutorial = { clicked: false, done: false, completedToast: false, settingsOpened: false, keysSeen: false, glossarySeen: false };
        if (typeof game.tutorial.clicked !== 'boolean') game.tutorial.clicked = false;
        if (typeof game.tutorial.done !== 'boolean') game.tutorial.done = false;
        if (typeof game.tutorial.completedToast !== 'boolean') game.tutorial.completedToast = false;
        if (typeof game.tutorial.settingsOpened !== 'boolean') game.tutorial.settingsOpened = false;
        if (typeof game.tutorial.keysSeen !== 'boolean') game.tutorial.keysSeen = false;
        if (typeof game.tutorial.glossarySeen !== 'boolean') game.tutorial.glossarySeen = false;
        if (typeof game.wasManaCapped !== 'boolean') game.wasManaCapped = false;
        if (typeof game.paragonSpent.focus !== 'number') game.paragonSpent.focus = 0;
        if (game.prestigeTokenChoice !== 'font' && game.prestigeTokenChoice !== 'study' && game.prestigeTokenChoice !== 'relic') game.prestigeTokenChoice = null;
        capMana();
        capStamina();
        capFocus();
        renderAll();
        showToast('Import', 'Save loaded.');
      } catch (e) {
        showToast('Import failed', String(e.message));
      }
    };

    function resetGame() {
      if (!confirm('Reset all progress? This cannot be undone.')) return;
      window._resettingSave = true;
      try {
        localStorage.removeItem('mageTowerSave');
        localStorage.removeItem('mageTowerIntroSeen');
        localStorage.removeItem('mageTowerLoreSeen');
        for (let i = localStorage.length - 1; i >= 0; i--) {
          const k = localStorage.key(i);
          if (k && k.toLowerCase().includes('magetower')) localStorage.removeItem(k);
        }
      } catch (e) {}
      location.reload();
    }

    // -------------------- SAVE / LOAD / OFFLINE --------------------
    function saveGame() {
      if (window._resettingSave) return;
      game.lastSave = Date.now();
      localStorage.setItem('mageTowerSave', JSON.stringify(game));
    }

    function loadGame() {
      try {
      const s = localStorage.getItem('mageTowerSave');
      if (!s) return;
      const data = JSON.parse(s);
      Object.assign(game, data);
      if (!game.specialRooms) game.specialRooms = initialSpecialRooms();
      SPECIAL_ROOM_NAMES.forEach(name => {
        if (!game.specialRooms[name]) game.specialRooms[name] = { built: false, level: 0 };
      });
      if (typeof game.stairs !== 'number') game.stairs = 0;
      if (Array.isArray(game.rooms) && game.rooms.length > 0) {
        const count = (name) => game.rooms.filter(r => r === name).length;
        if (count('Vault') >= 1) { game.specialRooms.Vault = { built: true, level: Math.max(1, count('Vault')) }; }
        if (count('Library') >= 1) { game.specialRooms.Library = { built: true, level: Math.max(1, count('Library')) }; }
        if (count('Observatory') >= 1) { game.specialRooms.Observatory = { built: true, level: Math.max(1, count('Observatory')) }; }
        game.stairs = game.rooms.filter(r => r === 'Stairs').length;
        delete game.rooms;
        delete game.floors;
      }
      const statDefaults = { timeDilationCasts: 0, arcaneHarvestCasts: 0, leylineSurgeCasts: 0, focusSurgeCasts: 0, vigorInfusionCasts: 0, transmutateCasts: 0, manaCapHits: 0, zeroManaCasts: 0, totalManaEarned: 0, totalSpellsCast: 0, timePlayedMs: 0, totalFloorsEver: 0, totalStaminaSpent: 0, maxFloorsReached: 0, maxManaPerSecReached: 0 };
      if (!game.stats) game.stats = { ...statDefaults, achievements: [] };
      Object.keys(statDefaults).forEach(k => { if (typeof game.stats[k] !== 'number') game.stats[k] = statDefaults[k]; });
      if (!Array.isArray(game.stats.achievements)) game.stats.achievements = [];
      if (!game.passive || typeof game.passive !== 'object') game.passive = {};
      const passiveDefaults = { arcane: 0, astral: 0, conduit: 0, towerBond: 0, staminaWell: 0, spellEcho: 0, focusFlow: 0, manaReservoir: 0, ritualMastery: 0, aetherFlux: 0, anchoredRituals: 0 };
      Object.keys(passiveDefaults).forEach(k => { if (typeof game.passive[k] !== 'number') game.passive[k] = passiveDefaults[k]; });
      if (!game.active) game.active = { boost: 1, boostTD: 1, boostHarvest: 1, timer: 0, duration: 0, cooldown: 0, harvestTimer: 0, harvestDuration: 0, leylineTapTimer: 0, leylineTapPct: 0, runeTimer: 0, runeStacks: 0, focusCondenserTimer: 0, spellCostDiscountTimer: 0, spellCostDiscountPct: 0, overclockTimer: 0, overclockMult: 1, worldweaveTimer: 0, convergenceTimer: 0, paradoxTimer: 0 };
      if (typeof game.active.boostTD !== 'number') game.active.boostTD = 1;
      if (typeof game.active.boostHarvest !== 'number') game.active.boostHarvest = 1;
      if (typeof game.active.harvestTimer !== 'number') game.active.harvestTimer = 0;
      if (typeof game.active.harvestDuration !== 'number') game.active.harvestDuration = 0;
      if (typeof game.active.leylineTapTimer !== 'number') game.active.leylineTapTimer = 0;
      if (typeof game.active.leylineTapPct !== 'number') game.active.leylineTapPct = 0;
      if (typeof game.active.runeTimer !== 'number') game.active.runeTimer = 0;
      if (typeof game.active.runeStacks !== 'number') game.active.runeStacks = 0;
      if (typeof game.active.focusCondenserTimer !== 'number') game.active.focusCondenserTimer = 0;
      if (typeof game.active.spellCostDiscountTimer !== 'number') game.active.spellCostDiscountTimer = 0;
      if (typeof game.active.spellCostDiscountPct !== 'number') game.active.spellCostDiscountPct = 0;
      if (typeof game.active.overclockTimer !== 'number') game.active.overclockTimer = 0;
      if (typeof game.active.overclockMult !== 'number') game.active.overclockMult = 1;
      if (typeof game.active.worldweaveTimer !== 'number') game.active.worldweaveTimer = 0;
      if (typeof game.active.convergenceTimer !== 'number') game.active.convergenceTimer = 0;
      if (typeof game.active.paradoxTimer !== 'number') game.active.paradoxTimer = 0;
      if (typeof game.softPrestige !== 'number') game.softPrestige = 0;
      if (typeof game.ascension !== 'number') game.ascension = 0;
      if (typeof game.studyCount !== 'number') game.studyCount = 0;
      if (typeof game.stamina !== 'number') game.stamina = 0;
      if (typeof game.focus !== 'number') game.focus = 0;
      if (!Array.isArray(game.relics)) game.relics = [];
      if (!Array.isArray(game.relicDraft)) game.relicDraft = [];
      if (typeof game.relicDraftSeen !== 'boolean') game.relicDraftSeen = false;
      if (typeof game.sigilStacks !== 'number') game.sigilStacks = 0;
      if (typeof game.relicHuntCooldownEnd !== 'number') game.relicHuntCooldownEnd = 0;
      game.relics = (game.relics || []).filter(id => RELIC_BY_ID[id]);
      game.relicDraft = (game.relicDraft || []).filter(id => RELIC_BY_ID[id]);
      if (typeof game.transmutateCooldownEnd !== 'number') game.transmutateCooldownEnd = 0;
      if (typeof game.manaSiphonCooldownEnd !== 'number') game.manaSiphonCooldownEnd = 0;
      if (typeof game.runeAccretionCooldownEnd !== 'number') game.runeAccretionCooldownEnd = 0;
      if (typeof game.staminaTransmuteCooldownEnd !== 'number') game.staminaTransmuteCooldownEnd = 0;
      if (typeof game.focusCondenserCooldownEnd !== 'number') game.focusCondenserCooldownEnd = 0;
      if (typeof game.leylineResonanceCooldownEnd !== 'number') game.leylineResonanceCooldownEnd = 0;
      if (typeof game.towerPulseCooldownEnd !== 'number') game.towerPulseCooldownEnd = 0;
      if (typeof game.chronoLoopCooldownEnd !== 'number') game.chronoLoopCooldownEnd = 0;
      if (typeof game.nexusOverclockCooldownEnd !== 'number') game.nexusOverclockCooldownEnd = 0;
      if (typeof game.worldweaveCooldownEnd !== 'number') game.worldweaveCooldownEnd = 0;
      if (typeof game.convergenceCooldownEnd !== 'number') game.convergenceCooldownEnd = 0;
      if (typeof game.paradoxCastCooldownEnd !== 'number') game.paradoxCastCooldownEnd = 0;
      if (typeof game.nextFloorDiscountPct !== 'number') game.nextFloorDiscountPct = 0;
      if (!game.settings || typeof game.settings !== 'object') game.settings = { showTutorial: true, keybinds: {} };
      if (typeof game.settings.showTutorial !== 'boolean') game.settings.showTutorial = true;
      ensureKeybinds();
      if (!game.tutorial || typeof game.tutorial !== 'object') game.tutorial = { clicked: false, done: false, completedToast: false, settingsOpened: false, keysSeen: false, glossarySeen: false };
      if (typeof game.tutorial.clicked !== 'boolean') game.tutorial.clicked = false;
      if (typeof game.tutorial.done !== 'boolean') game.tutorial.done = false;
      if (typeof game.tutorial.completedToast !== 'boolean') game.tutorial.completedToast = false;
      if (typeof game.tutorial.settingsOpened !== 'boolean') game.tutorial.settingsOpened = false;
      if (typeof game.tutorial.keysSeen !== 'boolean') game.tutorial.keysSeen = false;
      if (typeof game.tutorial.glossarySeen !== 'boolean') game.tutorial.glossarySeen = false;
      if (!Array.isArray(game.memorizedSpells)) game.memorizedSpells = [];
      if (typeof game.spellSwapCooldownEnd !== 'number') game.spellSwapCooldownEnd = 0;
      if (!game.paragonSpent || typeof game.paragonSpent.manaPct !== 'number') game.paragonSpent = { manaPct: 0, spellEffect: 0, stamina: 0, focus: 0 };
      if (typeof game.paragonSpent.focus !== 'number') game.paragonSpent.focus = 0;
      if (game.prestigeTokenChoice !== 'font' && game.prestigeTokenChoice !== 'study' && game.prestigeTokenChoice !== 'relic') game.prestigeTokenChoice = null;
      capMana();
      capStamina();
      capFocus();

      const now = Date.now();
      const last = game.lastSave || now;
      const dtMs = Math.min(now - last, OFFLINE_CAP_HOURS * 3600 * 1000);
      if (dtMs > 60000) {
        const dtSec = dtMs / 1000;
        const gained = manaPerSecond() * dtSec * 0.5;
        game.mana = Math.min(game.mana + gained, maxMana());
        game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + gained;
        const staminaGain = staminaPerSecond() * dtSec * 0.25;
        game.stamina = Math.min(game.stamina + staminaGain, maxStamina());
        const focusWarmupSec = (FOCUS_IDLE_SEC * focusIdleMultiplier()) / FOCUS_OFFLINE_DIVISOR;
        const focusRegenSec = Math.max(0, dtSec - focusWarmupSec);
        const focusGain = focusRegenSec * FOCUS_REGEN_BASE * OFFLINE_FOCUS_RATE * focusRegenMultiplier();
        game.focus = Math.min((game.focus || 0) + focusGain, maxFocus());
        const cooldownTick = dtMs * 0.5;
        if (game.spellSwapCooldownEnd > 0) game.spellSwapCooldownEnd = Math.max(now, (game.spellSwapCooldownEnd || now) - cooldownTick);
        if (game.ritualOfBindingCooldownEnd > 0) game.ritualOfBindingCooldownEnd = Math.max(now, (game.ritualOfBindingCooldownEnd || now) - cooldownTick);
        if (game.ritualActivityCooldownEnd > 0) game.ritualActivityCooldownEnd = Math.max(now, (game.ritualActivityCooldownEnd || now) - cooldownTick);
        if (game.relicHuntCooldownEnd > 0) game.relicHuntCooldownEnd = Math.max(now, (game.relicHuntCooldownEnd || now) - cooldownTick);
        if (game.transmutateCooldownEnd > 0) game.transmutateCooldownEnd = Math.max(now, (game.transmutateCooldownEnd || now) - cooldownTick);
        if (game.manaSiphonCooldownEnd > 0) game.manaSiphonCooldownEnd = Math.max(now, (game.manaSiphonCooldownEnd || now) - cooldownTick);
        if (game.runeAccretionCooldownEnd > 0) game.runeAccretionCooldownEnd = Math.max(now, (game.runeAccretionCooldownEnd || now) - cooldownTick);
        if (game.staminaTransmuteCooldownEnd > 0) game.staminaTransmuteCooldownEnd = Math.max(now, (game.staminaTransmuteCooldownEnd || now) - cooldownTick);
        if (game.focusCondenserCooldownEnd > 0) game.focusCondenserCooldownEnd = Math.max(now, (game.focusCondenserCooldownEnd || now) - cooldownTick);
        if (game.leylineResonanceCooldownEnd > 0) game.leylineResonanceCooldownEnd = Math.max(now, (game.leylineResonanceCooldownEnd || now) - cooldownTick);
        if (game.towerPulseCooldownEnd > 0) game.towerPulseCooldownEnd = Math.max(now, (game.towerPulseCooldownEnd || now) - cooldownTick);
        if (game.chronoLoopCooldownEnd > 0) game.chronoLoopCooldownEnd = Math.max(now, (game.chronoLoopCooldownEnd || now) - cooldownTick);
        if (game.nexusOverclockCooldownEnd > 0) game.nexusOverclockCooldownEnd = Math.max(now, (game.nexusOverclockCooldownEnd || now) - cooldownTick);
        if (game.worldweaveCooldownEnd > 0) game.worldweaveCooldownEnd = Math.max(now, (game.worldweaveCooldownEnd || now) - cooldownTick);
        if (game.convergenceCooldownEnd > 0) game.convergenceCooldownEnd = Math.max(now, (game.convergenceCooldownEnd || now) - cooldownTick);
        if (game.paradoxCastCooldownEnd > 0) game.paradoxCastCooldownEnd = Math.max(now, (game.paradoxCastCooldownEnd || now) - cooldownTick);
        if (dtMs >= 5 * 60 * 1000) {
          showOfflineProgress(gained, staminaGain, focusGain, dtMs);
        } else {
          showToast('Offline progress', 'Earned ' + formatNum(gained) + ' mana, ' + formatNum(staminaGain) + ' stamina' + (focusGain > 0 ? ', ' + formatNum(focusGain) + ' focus' : '') + ' while away.');
        }
      }
      } catch (loadErr) {
        localStorage.removeItem('mageTowerSave');
      }
    }

    if (typeof location !== 'undefined' && location.search && location.search.includes('clearSave=1')) {
      try { localStorage.removeItem('mageTowerSave'); } catch (e) {}
    }
    loadGame();
    renderAll();
    checkAchievements();
    openPanel('towerModal');

    if (!localStorage.getItem('mageTowerLoreSeen')) {
      showLoreTip();
    }
    introCloseBtn.onclick = () => {
      try { localStorage.setItem('mageTowerIntroSeen', '1'); } catch (e) {}
      introModal.style.display = 'none';
    };
    introModal.addEventListener('click', (e) => {
      if (e.target === introModal) {
        try { localStorage.setItem('mageTowerIntroSeen', '1'); } catch (e2) {}
        introModal.style.display = 'none';
      }
    });
    introModal.querySelector('.modal-content').addEventListener('click', (e) => e.stopPropagation());

    // -------------------- GAME LOOP --------------------
    let lastTickTime = Date.now();
    let towerPulseIndex = 0;
    let lastActivitiesRender = 0;
    let lastSpellRender = 0;
    setInterval(() => {
      const now = Date.now();
      const dt = (now - lastTickTime) / 1000;
      lastTickTime = now;
      game.stats.timePlayedMs = (game.stats.timePlayedMs || 0) + Math.round(dt * 1000);
      const tf = totalFloors();
      if (tf > (game.stats.maxFloorsReached || 0)) game.stats.maxFloorsReached = tf;
      const mps = manaPerSecond();
      if (mps > (game.stats.maxManaPerSecReached || 0)) game.stats.maxManaPerSecReached = mps;
      if (mps >= GOAL_MANA_PER_SEC && !(game.stats.goalManaReached)) {
        game.stats.goalManaReached = true;
        showToast('Goal reached!', 'You reached ' + formatNum(GOAL_MANA_PER_SEC) + ' mana/sec!');
        playSound('milestone');
      }
      if (tf >= PARAGON_FLOOR_MIN && (game.ascension || game.ascensionTier2) >= 1) {
        game.paragonXp = (game.paragonXp || 0) + PARAGON_XP_PER_TICK;
      }

      const gained = mps * Math.min(dt, TICK / 1000 * 2);
      game.mana = Math.min(game.mana + gained, maxMana());
      game.stats.totalManaEarned = (game.stats.totalManaEarned || 0) + gained;
      const manaCap = maxMana();
      const atCap = game.mana >= manaCap * 0.999;
      if (atCap && !game.wasManaCapped) {
        game.stats.manaCapHits = (game.stats.manaCapHits || 0) + 1;
        game.wasManaCapped = true;
      } else if (!atCap) {
        game.wasManaCapped = false;
      }

      const sps = staminaPerSecond();
      const staminaGain = sps * Math.min(dt, TICK / 1000 * 2);
      game.stamina = Math.min(game.stamina + staminaGain, maxStamina());

      if (isRestingForFocus()) {
        const fps = focusPerSecond();
        const focusGain = fps * Math.min(dt, TICK / 1000 * 2);
        game.focus = Math.min((game.focus || 0) + focusGain, maxFocus());
      }
      capFocus();

      const hadActiveSpell = game.active.timer > 0 || game.active.harvestTimer > 0 || game.active.leylineTapTimer > 0;
      if (game.active.timer > 0) {
        game.active.timer -= dt;
        if (game.active.timer <= 0) {
          game.active.boostTD = 1;
          game.active.duration = 0;
        }
      }
      if (game.active.harvestTimer > 0) {
        game.active.harvestTimer -= dt;
        if (game.active.harvestTimer <= 0) game.active.boostHarvest = 1;
      }
      if (game.active.leylineTapTimer > 0) {
        game.active.leylineTapTimer -= dt;
        if (game.active.leylineTapTimer <= 0) game.active.leylineTapPct = 0;
      }
      if (game.active.runeTimer > 0) {
        game.active.runeTimer -= dt;
        if (game.active.runeTimer <= 0) game.active.runeStacks = 0;
      }
      if (game.active.focusCondenserTimer > 0) {
        game.active.focusCondenserTimer -= dt;
        if (game.active.focusCondenserTimer < 0) game.active.focusCondenserTimer = 0;
      }
      if (game.active.spellCostDiscountTimer > 0) {
        game.active.spellCostDiscountTimer -= dt;
        if (game.active.spellCostDiscountTimer <= 0) game.active.spellCostDiscountPct = 0;
      }
      const hadOverclock = game.active.overclockTimer > 0;
      if (game.active.overclockTimer > 0) {
        game.active.overclockTimer -= dt;
        if (game.active.overclockTimer <= 0) {
          game.active.overclockMult = 1;
        }
      }
      if (hadOverclock && game.active.overclockTimer <= 0) {
        game.exhaustedUntil = Math.max(game.exhaustedUntil || 0, Date.now() + 180 * 1000);
      }
      if (game.active.worldweaveTimer > 0) {
        game.active.worldweaveTimer -= dt;
        if (game.active.worldweaveTimer < 0) game.active.worldweaveTimer = 0;
      }
      if (game.active.convergenceTimer > 0) {
        game.active.convergenceTimer -= dt;
        if (game.active.convergenceTimer < 0) game.active.convergenceTimer = 0;
      }
      if (game.active.paradoxTimer > 0) {
        game.active.paradoxTimer -= dt;
        if (game.active.paradoxTimer < 0) game.active.paradoxTimer = 0;
      }
      if (hadActiveSpell && game.active.timer <= 0 && game.active.harvestTimer <= 0 && game.active.leylineTapTimer <= 0) renderSpells();

      const hadCooldown = game.active.cooldown > 0;
      if (game.active.cooldown > 0) {
        game.active.cooldown -= dt;
        if (game.active.cooldown < 0) game.active.cooldown = 0;
      }
      if (hadCooldown && game.active.cooldown <= 0) renderSpells();

      renderUI();
      if (now - lastActivitiesRender > 250) {
        renderActivities();
        lastActivitiesRender = now;
      }
      const cooldownActive = anyActiveSpellCooldown();
      if (cooldownActive && now - lastSpellRender > 150) {
        renderSpells();
        lastSpellRender = now;
      } else if (!cooldownActive && lastSpellRender !== 0) {
        renderSpells();
        lastSpellRender = 0;
      }
      checkAchievements();

      towerPulseIndex++;
      if (towerContainer.children.length && towerPulseIndex % 50 === 0) {
        const block = towerContainer.children[towerContainer.children.length - 1];
        if (block && block.classList) {
          block.classList.add('tick-pulse');
          setTimeout(() => block.classList.remove('tick-pulse'), 300);
        }
      }

      saveGame();
    }, TICK);
  </script>
</body>
</html>
